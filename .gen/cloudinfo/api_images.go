/*
Product Info.

The product info application uses the cloud provider APIs to asynchronously fetch and parse instance type attributes and prices, while storing the results in an in memory cache and making it available as structured data through a REST API.

API version: 0.9.5
Contact: info@banzaicloud.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cloudinfo

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ImagesApiService ImagesApi service
type ImagesApiService service

type ApiGetImagesRequest struct {
	ctx context.Context
	ApiService *ImagesApiService
	provider string
	service string
	region string
	gpu *string
	cr *string
	version *string
	os *string
	pkeVersion *string
	latestOnly *string
}

func (r ApiGetImagesRequest) Gpu(gpu string) ApiGetImagesRequest {
	r.gpu = &gpu
	return r
}

func (r ApiGetImagesRequest) Cr(cr string) ApiGetImagesRequest {
	r.cr = &cr
	return r
}

func (r ApiGetImagesRequest) Version(version string) ApiGetImagesRequest {
	r.version = &version
	return r
}

func (r ApiGetImagesRequest) Os(os string) ApiGetImagesRequest {
	r.os = &os
	return r
}

func (r ApiGetImagesRequest) PkeVersion(pkeVersion string) ApiGetImagesRequest {
	r.pkeVersion = &pkeVersion
	return r
}

func (r ApiGetImagesRequest) LatestOnly(latestOnly string) ApiGetImagesRequest {
	r.latestOnly = &latestOnly
	return r
}

func (r ApiGetImagesRequest) Execute() ([]Image, *http.Response, error) {
	return r.ApiService.GetImagesExecute(r)
}

/*
GetImages Provides a list of available images on a given provider in a specific region for a service.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param provider
 @param service
 @param region
 @return ApiGetImagesRequest
*/
func (a *ImagesApiService) GetImages(ctx context.Context, provider string, service string, region string) ApiGetImagesRequest {
	return ApiGetImagesRequest{
		ApiService: a,
		ctx: ctx,
		provider: provider,
		service: service,
		region: region,
	}
}

// Execute executes the request
//  @return []Image
func (a *ImagesApiService) GetImagesExecute(r ApiGetImagesRequest) ([]Image, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Image
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/providers/{provider}/services/{service}/regions/{region}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"provider"+"}", url.PathEscape(parameterToString(r.provider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"region"+"}", url.PathEscape(parameterToString(r.region, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.gpu != nil {
		localVarQueryParams.Add("gpu", parameterToString(*r.gpu, ""))
	}
	if r.cr != nil {
		localVarQueryParams.Add("cr", parameterToString(*r.cr, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.os != nil {
		localVarQueryParams.Add("os", parameterToString(*r.os, ""))
	}
	if r.pkeVersion != nil {
		localVarQueryParams.Add("pkeVersion", parameterToString(*r.pkeVersion, ""))
	}
	if r.latestOnly != nil {
		localVarQueryParams.Add("latestOnly", parameterToString(*r.latestOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
