// +build !ignore_autogenerated

// Code generated by mga tool. DO NOT EDIT.

package awsmocks

import (
	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/banzaicloud/cadence-aws-sdk/clients"
	"github.com/banzaicloud/cadence-aws-sdk/clients/ec2stub"
	"github.com/stretchr/testify/mock"
	internal "go.uber.org/cadence/workflow"
)

// Mockec2clientstub is an autogenerated mock for the ec2clientstub type.
type Mockec2clientstub struct {
	mock.Mock
}

// AcceptReservedInstancesExchangeQuote provides a mock function.
func (_m *Mockec2clientstub) AcceptReservedInstancesExchangeQuote(ctx internal.Context, input *ec2.AcceptReservedInstancesExchangeQuoteInput) (_result_0 *ec2.AcceptReservedInstancesExchangeQuoteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AcceptReservedInstancesExchangeQuoteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput) *ec2.AcceptReservedInstancesExchangeQuoteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptReservedInstancesExchangeQuoteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptReservedInstancesExchangeQuoteAsync provides a mock function.
func (_m *Mockec2clientstub) AcceptReservedInstancesExchangeQuoteAsync(ctx internal.Context, input *ec2.AcceptReservedInstancesExchangeQuoteInput) (_result_0 *ec2stub.AcceptReservedInstancesExchangeQuoteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AcceptReservedInstancesExchangeQuoteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput) *ec2stub.AcceptReservedInstancesExchangeQuoteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AcceptReservedInstancesExchangeQuoteFuture)
		}
	}

	return r0
}

// AcceptTransitGatewayPeeringAttachment provides a mock function.
func (_m *Mockec2clientstub) AcceptTransitGatewayPeeringAttachment(ctx internal.Context, input *ec2.AcceptTransitGatewayPeeringAttachmentInput) (_result_0 *ec2.AcceptTransitGatewayPeeringAttachmentOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AcceptTransitGatewayPeeringAttachmentOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput) *ec2.AcceptTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayPeeringAttachmentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptTransitGatewayPeeringAttachmentAsync provides a mock function.
func (_m *Mockec2clientstub) AcceptTransitGatewayPeeringAttachmentAsync(ctx internal.Context, input *ec2.AcceptTransitGatewayPeeringAttachmentInput) (_result_0 *ec2stub.AcceptTransitGatewayPeeringAttachmentFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AcceptTransitGatewayPeeringAttachmentFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput) *ec2stub.AcceptTransitGatewayPeeringAttachmentFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AcceptTransitGatewayPeeringAttachmentFuture)
		}
	}

	return r0
}

// AcceptTransitGatewayVpcAttachment provides a mock function.
func (_m *Mockec2clientstub) AcceptTransitGatewayVpcAttachment(ctx internal.Context, input *ec2.AcceptTransitGatewayVpcAttachmentInput) (_result_0 *ec2.AcceptTransitGatewayVpcAttachmentOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AcceptTransitGatewayVpcAttachmentOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput) *ec2.AcceptTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayVpcAttachmentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptTransitGatewayVpcAttachmentAsync provides a mock function.
func (_m *Mockec2clientstub) AcceptTransitGatewayVpcAttachmentAsync(ctx internal.Context, input *ec2.AcceptTransitGatewayVpcAttachmentInput) (_result_0 *ec2stub.AcceptTransitGatewayVpcAttachmentFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AcceptTransitGatewayVpcAttachmentFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput) *ec2stub.AcceptTransitGatewayVpcAttachmentFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AcceptTransitGatewayVpcAttachmentFuture)
		}
	}

	return r0
}

// AcceptVpcEndpointConnections provides a mock function.
func (_m *Mockec2clientstub) AcceptVpcEndpointConnections(ctx internal.Context, input *ec2.AcceptVpcEndpointConnectionsInput) (_result_0 *ec2.AcceptVpcEndpointConnectionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AcceptVpcEndpointConnectionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptVpcEndpointConnectionsInput) *ec2.AcceptVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptVpcEndpointConnectionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AcceptVpcEndpointConnectionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptVpcEndpointConnectionsAsync provides a mock function.
func (_m *Mockec2clientstub) AcceptVpcEndpointConnectionsAsync(ctx internal.Context, input *ec2.AcceptVpcEndpointConnectionsInput) (_result_0 *ec2stub.AcceptVpcEndpointConnectionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AcceptVpcEndpointConnectionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptVpcEndpointConnectionsInput) *ec2stub.AcceptVpcEndpointConnectionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AcceptVpcEndpointConnectionsFuture)
		}
	}

	return r0
}

// AcceptVpcPeeringConnection provides a mock function.
func (_m *Mockec2clientstub) AcceptVpcPeeringConnection(ctx internal.Context, input *ec2.AcceptVpcPeeringConnectionInput) (_result_0 *ec2.AcceptVpcPeeringConnectionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AcceptVpcPeeringConnectionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptVpcPeeringConnectionInput) *ec2.AcceptVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptVpcPeeringConnectionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AcceptVpcPeeringConnectionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptVpcPeeringConnectionAsync provides a mock function.
func (_m *Mockec2clientstub) AcceptVpcPeeringConnectionAsync(ctx internal.Context, input *ec2.AcceptVpcPeeringConnectionInput) (_result_0 *ec2stub.AcceptVpcPeeringConnectionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AcceptVpcPeeringConnectionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AcceptVpcPeeringConnectionInput) *ec2stub.AcceptVpcPeeringConnectionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AcceptVpcPeeringConnectionFuture)
		}
	}

	return r0
}

// AdvertiseByoipCidr provides a mock function.
func (_m *Mockec2clientstub) AdvertiseByoipCidr(ctx internal.Context, input *ec2.AdvertiseByoipCidrInput) (_result_0 *ec2.AdvertiseByoipCidrOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AdvertiseByoipCidrOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AdvertiseByoipCidrInput) *ec2.AdvertiseByoipCidrOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AdvertiseByoipCidrOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AdvertiseByoipCidrInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AdvertiseByoipCidrAsync provides a mock function.
func (_m *Mockec2clientstub) AdvertiseByoipCidrAsync(ctx internal.Context, input *ec2.AdvertiseByoipCidrInput) (_result_0 *ec2stub.AdvertiseByoipCidrFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AdvertiseByoipCidrFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AdvertiseByoipCidrInput) *ec2stub.AdvertiseByoipCidrFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AdvertiseByoipCidrFuture)
		}
	}

	return r0
}

// AllocateAddress provides a mock function.
func (_m *Mockec2clientstub) AllocateAddress(ctx internal.Context, input *ec2.AllocateAddressInput) (_result_0 *ec2.AllocateAddressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AllocateAddressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AllocateAddressInput) *ec2.AllocateAddressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateAddressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AllocateAddressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateAddressAsync provides a mock function.
func (_m *Mockec2clientstub) AllocateAddressAsync(ctx internal.Context, input *ec2.AllocateAddressInput) (_result_0 *ec2stub.AllocateAddressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AllocateAddressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AllocateAddressInput) *ec2stub.AllocateAddressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AllocateAddressFuture)
		}
	}

	return r0
}

// AllocateHosts provides a mock function.
func (_m *Mockec2clientstub) AllocateHosts(ctx internal.Context, input *ec2.AllocateHostsInput) (_result_0 *ec2.AllocateHostsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AllocateHostsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AllocateHostsInput) *ec2.AllocateHostsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateHostsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AllocateHostsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateHostsAsync provides a mock function.
func (_m *Mockec2clientstub) AllocateHostsAsync(ctx internal.Context, input *ec2.AllocateHostsInput) (_result_0 *ec2stub.AllocateHostsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AllocateHostsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AllocateHostsInput) *ec2stub.AllocateHostsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AllocateHostsFuture)
		}
	}

	return r0
}

// ApplySecurityGroupsToClientVpnTargetNetwork provides a mock function.
func (_m *Mockec2clientstub) ApplySecurityGroupsToClientVpnTargetNetwork(ctx internal.Context, input *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput) (_result_0 *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput) *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplySecurityGroupsToClientVpnTargetNetworkAsync provides a mock function.
func (_m *Mockec2clientstub) ApplySecurityGroupsToClientVpnTargetNetworkAsync(ctx internal.Context, input *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput) (_result_0 *ec2stub.ApplySecurityGroupsToClientVpnTargetNetworkFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ApplySecurityGroupsToClientVpnTargetNetworkFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput) *ec2stub.ApplySecurityGroupsToClientVpnTargetNetworkFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ApplySecurityGroupsToClientVpnTargetNetworkFuture)
		}
	}

	return r0
}

// AssignIpv6Addresses provides a mock function.
func (_m *Mockec2clientstub) AssignIpv6Addresses(ctx internal.Context, input *ec2.AssignIpv6AddressesInput) (_result_0 *ec2.AssignIpv6AddressesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssignIpv6AddressesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssignIpv6AddressesInput) *ec2.AssignIpv6AddressesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssignIpv6AddressesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssignIpv6AddressesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssignIpv6AddressesAsync provides a mock function.
func (_m *Mockec2clientstub) AssignIpv6AddressesAsync(ctx internal.Context, input *ec2.AssignIpv6AddressesInput) (_result_0 *ec2stub.AssignIpv6AddressesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssignIpv6AddressesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssignIpv6AddressesInput) *ec2stub.AssignIpv6AddressesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssignIpv6AddressesFuture)
		}
	}

	return r0
}

// AssignPrivateIpAddresses provides a mock function.
func (_m *Mockec2clientstub) AssignPrivateIpAddresses(ctx internal.Context, input *ec2.AssignPrivateIpAddressesInput) (_result_0 *ec2.AssignPrivateIpAddressesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssignPrivateIpAddressesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssignPrivateIpAddressesInput) *ec2.AssignPrivateIpAddressesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssignPrivateIpAddressesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssignPrivateIpAddressesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssignPrivateIpAddressesAsync provides a mock function.
func (_m *Mockec2clientstub) AssignPrivateIpAddressesAsync(ctx internal.Context, input *ec2.AssignPrivateIpAddressesInput) (_result_0 *ec2stub.AssignPrivateIpAddressesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssignPrivateIpAddressesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssignPrivateIpAddressesInput) *ec2stub.AssignPrivateIpAddressesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssignPrivateIpAddressesFuture)
		}
	}

	return r0
}

// AssociateAddress provides a mock function.
func (_m *Mockec2clientstub) AssociateAddress(ctx internal.Context, input *ec2.AssociateAddressInput) (_result_0 *ec2.AssociateAddressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateAddressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateAddressInput) *ec2.AssociateAddressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateAddressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateAddressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateAddressAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateAddressAsync(ctx internal.Context, input *ec2.AssociateAddressInput) (_result_0 *ec2stub.AssociateAddressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateAddressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateAddressInput) *ec2stub.AssociateAddressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateAddressFuture)
		}
	}

	return r0
}

// AssociateClientVpnTargetNetwork provides a mock function.
func (_m *Mockec2clientstub) AssociateClientVpnTargetNetwork(ctx internal.Context, input *ec2.AssociateClientVpnTargetNetworkInput) (_result_0 *ec2.AssociateClientVpnTargetNetworkOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateClientVpnTargetNetworkOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateClientVpnTargetNetworkInput) *ec2.AssociateClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateClientVpnTargetNetworkOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateClientVpnTargetNetworkInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateClientVpnTargetNetworkAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateClientVpnTargetNetworkAsync(ctx internal.Context, input *ec2.AssociateClientVpnTargetNetworkInput) (_result_0 *ec2stub.AssociateClientVpnTargetNetworkFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateClientVpnTargetNetworkFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateClientVpnTargetNetworkInput) *ec2stub.AssociateClientVpnTargetNetworkFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateClientVpnTargetNetworkFuture)
		}
	}

	return r0
}

// AssociateDhcpOptions provides a mock function.
func (_m *Mockec2clientstub) AssociateDhcpOptions(ctx internal.Context, input *ec2.AssociateDhcpOptionsInput) (_result_0 *ec2.AssociateDhcpOptionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateDhcpOptionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateDhcpOptionsInput) *ec2.AssociateDhcpOptionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateDhcpOptionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateDhcpOptionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateDhcpOptionsAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateDhcpOptionsAsync(ctx internal.Context, input *ec2.AssociateDhcpOptionsInput) (_result_0 *ec2stub.AssociateDhcpOptionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateDhcpOptionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateDhcpOptionsInput) *ec2stub.AssociateDhcpOptionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateDhcpOptionsFuture)
		}
	}

	return r0
}

// AssociateEnclaveCertificateIamRole provides a mock function.
func (_m *Mockec2clientstub) AssociateEnclaveCertificateIamRole(ctx internal.Context, input *ec2.AssociateEnclaveCertificateIamRoleInput) (_result_0 *ec2.AssociateEnclaveCertificateIamRoleOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateEnclaveCertificateIamRoleOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateEnclaveCertificateIamRoleInput) *ec2.AssociateEnclaveCertificateIamRoleOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateEnclaveCertificateIamRoleOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateEnclaveCertificateIamRoleInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateEnclaveCertificateIamRoleAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateEnclaveCertificateIamRoleAsync(ctx internal.Context, input *ec2.AssociateEnclaveCertificateIamRoleInput) (_result_0 *ec2stub.AssociateEnclaveCertificateIamRoleFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateEnclaveCertificateIamRoleFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateEnclaveCertificateIamRoleInput) *ec2stub.AssociateEnclaveCertificateIamRoleFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateEnclaveCertificateIamRoleFuture)
		}
	}

	return r0
}

// AssociateIamInstanceProfile provides a mock function.
func (_m *Mockec2clientstub) AssociateIamInstanceProfile(ctx internal.Context, input *ec2.AssociateIamInstanceProfileInput) (_result_0 *ec2.AssociateIamInstanceProfileOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateIamInstanceProfileOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateIamInstanceProfileInput) *ec2.AssociateIamInstanceProfileOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateIamInstanceProfileOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateIamInstanceProfileInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateIamInstanceProfileAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateIamInstanceProfileAsync(ctx internal.Context, input *ec2.AssociateIamInstanceProfileInput) (_result_0 *ec2stub.AssociateIamInstanceProfileFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateIamInstanceProfileFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateIamInstanceProfileInput) *ec2stub.AssociateIamInstanceProfileFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateIamInstanceProfileFuture)
		}
	}

	return r0
}

// AssociateRouteTable provides a mock function.
func (_m *Mockec2clientstub) AssociateRouteTable(ctx internal.Context, input *ec2.AssociateRouteTableInput) (_result_0 *ec2.AssociateRouteTableOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateRouteTableOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateRouteTableInput) *ec2.AssociateRouteTableOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateRouteTableOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateRouteTableInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateRouteTableAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateRouteTableAsync(ctx internal.Context, input *ec2.AssociateRouteTableInput) (_result_0 *ec2stub.AssociateRouteTableFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateRouteTableFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateRouteTableInput) *ec2stub.AssociateRouteTableFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateRouteTableFuture)
		}
	}

	return r0
}

// AssociateSubnetCidrBlock provides a mock function.
func (_m *Mockec2clientstub) AssociateSubnetCidrBlock(ctx internal.Context, input *ec2.AssociateSubnetCidrBlockInput) (_result_0 *ec2.AssociateSubnetCidrBlockOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateSubnetCidrBlockOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateSubnetCidrBlockInput) *ec2.AssociateSubnetCidrBlockOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateSubnetCidrBlockOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateSubnetCidrBlockInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateSubnetCidrBlockAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateSubnetCidrBlockAsync(ctx internal.Context, input *ec2.AssociateSubnetCidrBlockInput) (_result_0 *ec2stub.AssociateSubnetCidrBlockFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateSubnetCidrBlockFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateSubnetCidrBlockInput) *ec2stub.AssociateSubnetCidrBlockFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateSubnetCidrBlockFuture)
		}
	}

	return r0
}

// AssociateTransitGatewayMulticastDomain provides a mock function.
func (_m *Mockec2clientstub) AssociateTransitGatewayMulticastDomain(ctx internal.Context, input *ec2.AssociateTransitGatewayMulticastDomainInput) (_result_0 *ec2.AssociateTransitGatewayMulticastDomainOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateTransitGatewayMulticastDomainOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateTransitGatewayMulticastDomainInput) *ec2.AssociateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTransitGatewayMulticastDomainOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateTransitGatewayMulticastDomainInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateTransitGatewayMulticastDomainAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateTransitGatewayMulticastDomainAsync(ctx internal.Context, input *ec2.AssociateTransitGatewayMulticastDomainInput) (_result_0 *ec2stub.AssociateTransitGatewayMulticastDomainFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateTransitGatewayMulticastDomainFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateTransitGatewayMulticastDomainInput) *ec2stub.AssociateTransitGatewayMulticastDomainFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateTransitGatewayMulticastDomainFuture)
		}
	}

	return r0
}

// AssociateTransitGatewayRouteTable provides a mock function.
func (_m *Mockec2clientstub) AssociateTransitGatewayRouteTable(ctx internal.Context, input *ec2.AssociateTransitGatewayRouteTableInput) (_result_0 *ec2.AssociateTransitGatewayRouteTableOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateTransitGatewayRouteTableOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateTransitGatewayRouteTableInput) *ec2.AssociateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTransitGatewayRouteTableOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateTransitGatewayRouteTableInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateTransitGatewayRouteTableAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateTransitGatewayRouteTableAsync(ctx internal.Context, input *ec2.AssociateTransitGatewayRouteTableInput) (_result_0 *ec2stub.AssociateTransitGatewayRouteTableFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateTransitGatewayRouteTableFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateTransitGatewayRouteTableInput) *ec2stub.AssociateTransitGatewayRouteTableFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateTransitGatewayRouteTableFuture)
		}
	}

	return r0
}

// AssociateVpcCidrBlock provides a mock function.
func (_m *Mockec2clientstub) AssociateVpcCidrBlock(ctx internal.Context, input *ec2.AssociateVpcCidrBlockInput) (_result_0 *ec2.AssociateVpcCidrBlockOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AssociateVpcCidrBlockOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateVpcCidrBlockInput) *ec2.AssociateVpcCidrBlockOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateVpcCidrBlockOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AssociateVpcCidrBlockInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateVpcCidrBlockAsync provides a mock function.
func (_m *Mockec2clientstub) AssociateVpcCidrBlockAsync(ctx internal.Context, input *ec2.AssociateVpcCidrBlockInput) (_result_0 *ec2stub.AssociateVpcCidrBlockFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AssociateVpcCidrBlockFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AssociateVpcCidrBlockInput) *ec2stub.AssociateVpcCidrBlockFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AssociateVpcCidrBlockFuture)
		}
	}

	return r0
}

// AttachClassicLinkVpc provides a mock function.
func (_m *Mockec2clientstub) AttachClassicLinkVpc(ctx internal.Context, input *ec2.AttachClassicLinkVpcInput) (_result_0 *ec2.AttachClassicLinkVpcOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AttachClassicLinkVpcOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachClassicLinkVpcInput) *ec2.AttachClassicLinkVpcOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachClassicLinkVpcOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AttachClassicLinkVpcInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachClassicLinkVpcAsync provides a mock function.
func (_m *Mockec2clientstub) AttachClassicLinkVpcAsync(ctx internal.Context, input *ec2.AttachClassicLinkVpcInput) (_result_0 *ec2stub.AttachClassicLinkVpcFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AttachClassicLinkVpcFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachClassicLinkVpcInput) *ec2stub.AttachClassicLinkVpcFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AttachClassicLinkVpcFuture)
		}
	}

	return r0
}

// AttachInternetGateway provides a mock function.
func (_m *Mockec2clientstub) AttachInternetGateway(ctx internal.Context, input *ec2.AttachInternetGatewayInput) (_result_0 *ec2.AttachInternetGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AttachInternetGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachInternetGatewayInput) *ec2.AttachInternetGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachInternetGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AttachInternetGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachInternetGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) AttachInternetGatewayAsync(ctx internal.Context, input *ec2.AttachInternetGatewayInput) (_result_0 *ec2stub.AttachInternetGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AttachInternetGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachInternetGatewayInput) *ec2stub.AttachInternetGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AttachInternetGatewayFuture)
		}
	}

	return r0
}

// AttachNetworkInterface provides a mock function.
func (_m *Mockec2clientstub) AttachNetworkInterface(ctx internal.Context, input *ec2.AttachNetworkInterfaceInput) (_result_0 *ec2.AttachNetworkInterfaceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AttachNetworkInterfaceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachNetworkInterfaceInput) *ec2.AttachNetworkInterfaceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachNetworkInterfaceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AttachNetworkInterfaceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachNetworkInterfaceAsync provides a mock function.
func (_m *Mockec2clientstub) AttachNetworkInterfaceAsync(ctx internal.Context, input *ec2.AttachNetworkInterfaceInput) (_result_0 *ec2stub.AttachNetworkInterfaceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AttachNetworkInterfaceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachNetworkInterfaceInput) *ec2stub.AttachNetworkInterfaceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AttachNetworkInterfaceFuture)
		}
	}

	return r0
}

// AttachVolume provides a mock function.
func (_m *Mockec2clientstub) AttachVolume(ctx internal.Context, input *ec2.AttachVolumeInput) (_result_0 *ec2.VolumeAttachment, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.VolumeAttachment
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachVolumeInput) *ec2.VolumeAttachment); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.VolumeAttachment)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AttachVolumeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachVolumeAsync provides a mock function.
func (_m *Mockec2clientstub) AttachVolumeAsync(ctx internal.Context, input *ec2.AttachVolumeInput) (_result_0 *ec2stub.AttachVolumeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AttachVolumeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachVolumeInput) *ec2stub.AttachVolumeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AttachVolumeFuture)
		}
	}

	return r0
}

// AttachVpnGateway provides a mock function.
func (_m *Mockec2clientstub) AttachVpnGateway(ctx internal.Context, input *ec2.AttachVpnGatewayInput) (_result_0 *ec2.AttachVpnGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AttachVpnGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachVpnGatewayInput) *ec2.AttachVpnGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachVpnGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AttachVpnGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachVpnGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) AttachVpnGatewayAsync(ctx internal.Context, input *ec2.AttachVpnGatewayInput) (_result_0 *ec2stub.AttachVpnGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AttachVpnGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AttachVpnGatewayInput) *ec2stub.AttachVpnGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AttachVpnGatewayFuture)
		}
	}

	return r0
}

// AuthorizeClientVpnIngress provides a mock function.
func (_m *Mockec2clientstub) AuthorizeClientVpnIngress(ctx internal.Context, input *ec2.AuthorizeClientVpnIngressInput) (_result_0 *ec2.AuthorizeClientVpnIngressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AuthorizeClientVpnIngressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AuthorizeClientVpnIngressInput) *ec2.AuthorizeClientVpnIngressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeClientVpnIngressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AuthorizeClientVpnIngressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeClientVpnIngressAsync provides a mock function.
func (_m *Mockec2clientstub) AuthorizeClientVpnIngressAsync(ctx internal.Context, input *ec2.AuthorizeClientVpnIngressInput) (_result_0 *ec2stub.AuthorizeClientVpnIngressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AuthorizeClientVpnIngressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AuthorizeClientVpnIngressInput) *ec2stub.AuthorizeClientVpnIngressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AuthorizeClientVpnIngressFuture)
		}
	}

	return r0
}

// AuthorizeSecurityGroupEgress provides a mock function.
func (_m *Mockec2clientstub) AuthorizeSecurityGroupEgress(ctx internal.Context, input *ec2.AuthorizeSecurityGroupEgressInput) (_result_0 *ec2.AuthorizeSecurityGroupEgressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AuthorizeSecurityGroupEgressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AuthorizeSecurityGroupEgressInput) *ec2.AuthorizeSecurityGroupEgressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeSecurityGroupEgressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AuthorizeSecurityGroupEgressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeSecurityGroupEgressAsync provides a mock function.
func (_m *Mockec2clientstub) AuthorizeSecurityGroupEgressAsync(ctx internal.Context, input *ec2.AuthorizeSecurityGroupEgressInput) (_result_0 *ec2stub.AuthorizeSecurityGroupEgressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AuthorizeSecurityGroupEgressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AuthorizeSecurityGroupEgressInput) *ec2stub.AuthorizeSecurityGroupEgressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AuthorizeSecurityGroupEgressFuture)
		}
	}

	return r0
}

// AuthorizeSecurityGroupIngress provides a mock function.
func (_m *Mockec2clientstub) AuthorizeSecurityGroupIngress(ctx internal.Context, input *ec2.AuthorizeSecurityGroupIngressInput) (_result_0 *ec2.AuthorizeSecurityGroupIngressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.AuthorizeSecurityGroupIngressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AuthorizeSecurityGroupIngressInput) *ec2.AuthorizeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeSecurityGroupIngressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.AuthorizeSecurityGroupIngressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeSecurityGroupIngressAsync provides a mock function.
func (_m *Mockec2clientstub) AuthorizeSecurityGroupIngressAsync(ctx internal.Context, input *ec2.AuthorizeSecurityGroupIngressInput) (_result_0 *ec2stub.AuthorizeSecurityGroupIngressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.AuthorizeSecurityGroupIngressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.AuthorizeSecurityGroupIngressInput) *ec2stub.AuthorizeSecurityGroupIngressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.AuthorizeSecurityGroupIngressFuture)
		}
	}

	return r0
}

// BundleInstance provides a mock function.
func (_m *Mockec2clientstub) BundleInstance(ctx internal.Context, input *ec2.BundleInstanceInput) (_result_0 *ec2.BundleInstanceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.BundleInstanceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.BundleInstanceInput) *ec2.BundleInstanceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.BundleInstanceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.BundleInstanceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BundleInstanceAsync provides a mock function.
func (_m *Mockec2clientstub) BundleInstanceAsync(ctx internal.Context, input *ec2.BundleInstanceInput) (_result_0 *ec2stub.BundleInstanceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.BundleInstanceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.BundleInstanceInput) *ec2stub.BundleInstanceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.BundleInstanceFuture)
		}
	}

	return r0
}

// CancelBundleTask provides a mock function.
func (_m *Mockec2clientstub) CancelBundleTask(ctx internal.Context, input *ec2.CancelBundleTaskInput) (_result_0 *ec2.CancelBundleTaskOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CancelBundleTaskOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelBundleTaskInput) *ec2.CancelBundleTaskOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelBundleTaskOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CancelBundleTaskInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelBundleTaskAsync provides a mock function.
func (_m *Mockec2clientstub) CancelBundleTaskAsync(ctx internal.Context, input *ec2.CancelBundleTaskInput) (_result_0 *ec2stub.CancelBundleTaskFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CancelBundleTaskFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelBundleTaskInput) *ec2stub.CancelBundleTaskFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CancelBundleTaskFuture)
		}
	}

	return r0
}

// CancelCapacityReservation provides a mock function.
func (_m *Mockec2clientstub) CancelCapacityReservation(ctx internal.Context, input *ec2.CancelCapacityReservationInput) (_result_0 *ec2.CancelCapacityReservationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CancelCapacityReservationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelCapacityReservationInput) *ec2.CancelCapacityReservationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelCapacityReservationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CancelCapacityReservationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelCapacityReservationAsync provides a mock function.
func (_m *Mockec2clientstub) CancelCapacityReservationAsync(ctx internal.Context, input *ec2.CancelCapacityReservationInput) (_result_0 *ec2stub.CancelCapacityReservationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CancelCapacityReservationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelCapacityReservationInput) *ec2stub.CancelCapacityReservationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CancelCapacityReservationFuture)
		}
	}

	return r0
}

// CancelConversionTask provides a mock function.
func (_m *Mockec2clientstub) CancelConversionTask(ctx internal.Context, input *ec2.CancelConversionTaskInput) (_result_0 *ec2.CancelConversionTaskOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CancelConversionTaskOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelConversionTaskInput) *ec2.CancelConversionTaskOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelConversionTaskOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CancelConversionTaskInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelConversionTaskAsync provides a mock function.
func (_m *Mockec2clientstub) CancelConversionTaskAsync(ctx internal.Context, input *ec2.CancelConversionTaskInput) (_result_0 *ec2stub.CancelConversionTaskFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CancelConversionTaskFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelConversionTaskInput) *ec2stub.CancelConversionTaskFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CancelConversionTaskFuture)
		}
	}

	return r0
}

// CancelExportTask provides a mock function.
func (_m *Mockec2clientstub) CancelExportTask(ctx internal.Context, input *ec2.CancelExportTaskInput) (_result_0 *ec2.CancelExportTaskOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CancelExportTaskOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelExportTaskInput) *ec2.CancelExportTaskOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelExportTaskOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CancelExportTaskInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelExportTaskAsync provides a mock function.
func (_m *Mockec2clientstub) CancelExportTaskAsync(ctx internal.Context, input *ec2.CancelExportTaskInput) (_result_0 *ec2stub.CancelExportTaskFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CancelExportTaskFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelExportTaskInput) *ec2stub.CancelExportTaskFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CancelExportTaskFuture)
		}
	}

	return r0
}

// CancelImportTask provides a mock function.
func (_m *Mockec2clientstub) CancelImportTask(ctx internal.Context, input *ec2.CancelImportTaskInput) (_result_0 *ec2.CancelImportTaskOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CancelImportTaskOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelImportTaskInput) *ec2.CancelImportTaskOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelImportTaskOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CancelImportTaskInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelImportTaskAsync provides a mock function.
func (_m *Mockec2clientstub) CancelImportTaskAsync(ctx internal.Context, input *ec2.CancelImportTaskInput) (_result_0 *ec2stub.CancelImportTaskFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CancelImportTaskFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelImportTaskInput) *ec2stub.CancelImportTaskFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CancelImportTaskFuture)
		}
	}

	return r0
}

// CancelReservedInstancesListing provides a mock function.
func (_m *Mockec2clientstub) CancelReservedInstancesListing(ctx internal.Context, input *ec2.CancelReservedInstancesListingInput) (_result_0 *ec2.CancelReservedInstancesListingOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CancelReservedInstancesListingOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelReservedInstancesListingInput) *ec2.CancelReservedInstancesListingOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelReservedInstancesListingOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CancelReservedInstancesListingInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelReservedInstancesListingAsync provides a mock function.
func (_m *Mockec2clientstub) CancelReservedInstancesListingAsync(ctx internal.Context, input *ec2.CancelReservedInstancesListingInput) (_result_0 *ec2stub.CancelReservedInstancesListingFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CancelReservedInstancesListingFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelReservedInstancesListingInput) *ec2stub.CancelReservedInstancesListingFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CancelReservedInstancesListingFuture)
		}
	}

	return r0
}

// CancelSpotFleetRequests provides a mock function.
func (_m *Mockec2clientstub) CancelSpotFleetRequests(ctx internal.Context, input *ec2.CancelSpotFleetRequestsInput) (_result_0 *ec2.CancelSpotFleetRequestsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CancelSpotFleetRequestsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelSpotFleetRequestsInput) *ec2.CancelSpotFleetRequestsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelSpotFleetRequestsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CancelSpotFleetRequestsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSpotFleetRequestsAsync provides a mock function.
func (_m *Mockec2clientstub) CancelSpotFleetRequestsAsync(ctx internal.Context, input *ec2.CancelSpotFleetRequestsInput) (_result_0 *ec2stub.CancelSpotFleetRequestsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CancelSpotFleetRequestsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelSpotFleetRequestsInput) *ec2stub.CancelSpotFleetRequestsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CancelSpotFleetRequestsFuture)
		}
	}

	return r0
}

// CancelSpotInstanceRequests provides a mock function.
func (_m *Mockec2clientstub) CancelSpotInstanceRequests(ctx internal.Context, input *ec2.CancelSpotInstanceRequestsInput) (_result_0 *ec2.CancelSpotInstanceRequestsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CancelSpotInstanceRequestsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelSpotInstanceRequestsInput) *ec2.CancelSpotInstanceRequestsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelSpotInstanceRequestsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CancelSpotInstanceRequestsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSpotInstanceRequestsAsync provides a mock function.
func (_m *Mockec2clientstub) CancelSpotInstanceRequestsAsync(ctx internal.Context, input *ec2.CancelSpotInstanceRequestsInput) (_result_0 *ec2stub.CancelSpotInstanceRequestsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CancelSpotInstanceRequestsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CancelSpotInstanceRequestsInput) *ec2stub.CancelSpotInstanceRequestsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CancelSpotInstanceRequestsFuture)
		}
	}

	return r0
}

// ConfirmProductInstance provides a mock function.
func (_m *Mockec2clientstub) ConfirmProductInstance(ctx internal.Context, input *ec2.ConfirmProductInstanceInput) (_result_0 *ec2.ConfirmProductInstanceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ConfirmProductInstanceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ConfirmProductInstanceInput) *ec2.ConfirmProductInstanceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ConfirmProductInstanceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ConfirmProductInstanceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfirmProductInstanceAsync provides a mock function.
func (_m *Mockec2clientstub) ConfirmProductInstanceAsync(ctx internal.Context, input *ec2.ConfirmProductInstanceInput) (_result_0 *ec2stub.ConfirmProductInstanceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ConfirmProductInstanceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ConfirmProductInstanceInput) *ec2stub.ConfirmProductInstanceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ConfirmProductInstanceFuture)
		}
	}

	return r0
}

// CopyFpgaImage provides a mock function.
func (_m *Mockec2clientstub) CopyFpgaImage(ctx internal.Context, input *ec2.CopyFpgaImageInput) (_result_0 *ec2.CopyFpgaImageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CopyFpgaImageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CopyFpgaImageInput) *ec2.CopyFpgaImageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopyFpgaImageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CopyFpgaImageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyFpgaImageAsync provides a mock function.
func (_m *Mockec2clientstub) CopyFpgaImageAsync(ctx internal.Context, input *ec2.CopyFpgaImageInput) (_result_0 *ec2stub.CopyFpgaImageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CopyFpgaImageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CopyFpgaImageInput) *ec2stub.CopyFpgaImageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CopyFpgaImageFuture)
		}
	}

	return r0
}

// CopyImage provides a mock function.
func (_m *Mockec2clientstub) CopyImage(ctx internal.Context, input *ec2.CopyImageInput) (_result_0 *ec2.CopyImageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CopyImageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CopyImageInput) *ec2.CopyImageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopyImageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CopyImageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyImageAsync provides a mock function.
func (_m *Mockec2clientstub) CopyImageAsync(ctx internal.Context, input *ec2.CopyImageInput) (_result_0 *ec2stub.CopyImageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CopyImageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CopyImageInput) *ec2stub.CopyImageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CopyImageFuture)
		}
	}

	return r0
}

// CopySnapshot provides a mock function.
func (_m *Mockec2clientstub) CopySnapshot(ctx internal.Context, input *ec2.CopySnapshotInput) (_result_0 *ec2.CopySnapshotOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CopySnapshotOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CopySnapshotInput) *ec2.CopySnapshotOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopySnapshotOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CopySnapshotInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopySnapshotAsync provides a mock function.
func (_m *Mockec2clientstub) CopySnapshotAsync(ctx internal.Context, input *ec2.CopySnapshotInput) (_result_0 *ec2stub.CopySnapshotFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CopySnapshotFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CopySnapshotInput) *ec2stub.CopySnapshotFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CopySnapshotFuture)
		}
	}

	return r0
}

// CreateCapacityReservation provides a mock function.
func (_m *Mockec2clientstub) CreateCapacityReservation(ctx internal.Context, input *ec2.CreateCapacityReservationInput) (_result_0 *ec2.CreateCapacityReservationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateCapacityReservationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateCapacityReservationInput) *ec2.CreateCapacityReservationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCapacityReservationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateCapacityReservationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCapacityReservationAsync provides a mock function.
func (_m *Mockec2clientstub) CreateCapacityReservationAsync(ctx internal.Context, input *ec2.CreateCapacityReservationInput) (_result_0 *ec2stub.CreateCapacityReservationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateCapacityReservationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateCapacityReservationInput) *ec2stub.CreateCapacityReservationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateCapacityReservationFuture)
		}
	}

	return r0
}

// CreateCarrierGateway provides a mock function.
func (_m *Mockec2clientstub) CreateCarrierGateway(ctx internal.Context, input *ec2.CreateCarrierGatewayInput) (_result_0 *ec2.CreateCarrierGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateCarrierGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateCarrierGatewayInput) *ec2.CreateCarrierGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCarrierGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateCarrierGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCarrierGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) CreateCarrierGatewayAsync(ctx internal.Context, input *ec2.CreateCarrierGatewayInput) (_result_0 *ec2stub.CreateCarrierGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateCarrierGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateCarrierGatewayInput) *ec2stub.CreateCarrierGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateCarrierGatewayFuture)
		}
	}

	return r0
}

// CreateClientVpnEndpoint provides a mock function.
func (_m *Mockec2clientstub) CreateClientVpnEndpoint(ctx internal.Context, input *ec2.CreateClientVpnEndpointInput) (_result_0 *ec2.CreateClientVpnEndpointOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateClientVpnEndpointOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateClientVpnEndpointInput) *ec2.CreateClientVpnEndpointOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateClientVpnEndpointOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateClientVpnEndpointInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientVpnEndpointAsync provides a mock function.
func (_m *Mockec2clientstub) CreateClientVpnEndpointAsync(ctx internal.Context, input *ec2.CreateClientVpnEndpointInput) (_result_0 *ec2stub.CreateClientVpnEndpointFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateClientVpnEndpointFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateClientVpnEndpointInput) *ec2stub.CreateClientVpnEndpointFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateClientVpnEndpointFuture)
		}
	}

	return r0
}

// CreateClientVpnRoute provides a mock function.
func (_m *Mockec2clientstub) CreateClientVpnRoute(ctx internal.Context, input *ec2.CreateClientVpnRouteInput) (_result_0 *ec2.CreateClientVpnRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateClientVpnRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateClientVpnRouteInput) *ec2.CreateClientVpnRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateClientVpnRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateClientVpnRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientVpnRouteAsync provides a mock function.
func (_m *Mockec2clientstub) CreateClientVpnRouteAsync(ctx internal.Context, input *ec2.CreateClientVpnRouteInput) (_result_0 *ec2stub.CreateClientVpnRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateClientVpnRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateClientVpnRouteInput) *ec2stub.CreateClientVpnRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateClientVpnRouteFuture)
		}
	}

	return r0
}

// CreateCustomerGateway provides a mock function.
func (_m *Mockec2clientstub) CreateCustomerGateway(ctx internal.Context, input *ec2.CreateCustomerGatewayInput) (_result_0 *ec2.CreateCustomerGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateCustomerGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateCustomerGatewayInput) *ec2.CreateCustomerGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCustomerGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateCustomerGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomerGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) CreateCustomerGatewayAsync(ctx internal.Context, input *ec2.CreateCustomerGatewayInput) (_result_0 *ec2stub.CreateCustomerGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateCustomerGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateCustomerGatewayInput) *ec2stub.CreateCustomerGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateCustomerGatewayFuture)
		}
	}

	return r0
}

// CreateDefaultSubnet provides a mock function.
func (_m *Mockec2clientstub) CreateDefaultSubnet(ctx internal.Context, input *ec2.CreateDefaultSubnetInput) (_result_0 *ec2.CreateDefaultSubnetOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateDefaultSubnetOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateDefaultSubnetInput) *ec2.CreateDefaultSubnetOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDefaultSubnetOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateDefaultSubnetInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDefaultSubnetAsync provides a mock function.
func (_m *Mockec2clientstub) CreateDefaultSubnetAsync(ctx internal.Context, input *ec2.CreateDefaultSubnetInput) (_result_0 *ec2stub.CreateDefaultSubnetFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateDefaultSubnetFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateDefaultSubnetInput) *ec2stub.CreateDefaultSubnetFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateDefaultSubnetFuture)
		}
	}

	return r0
}

// CreateDefaultVpc provides a mock function.
func (_m *Mockec2clientstub) CreateDefaultVpc(ctx internal.Context, input *ec2.CreateDefaultVpcInput) (_result_0 *ec2.CreateDefaultVpcOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateDefaultVpcOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateDefaultVpcInput) *ec2.CreateDefaultVpcOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDefaultVpcOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateDefaultVpcInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDefaultVpcAsync provides a mock function.
func (_m *Mockec2clientstub) CreateDefaultVpcAsync(ctx internal.Context, input *ec2.CreateDefaultVpcInput) (_result_0 *ec2stub.CreateDefaultVpcFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateDefaultVpcFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateDefaultVpcInput) *ec2stub.CreateDefaultVpcFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateDefaultVpcFuture)
		}
	}

	return r0
}

// CreateDhcpOptions provides a mock function.
func (_m *Mockec2clientstub) CreateDhcpOptions(ctx internal.Context, input *ec2.CreateDhcpOptionsInput) (_result_0 *ec2.CreateDhcpOptionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateDhcpOptionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateDhcpOptionsInput) *ec2.CreateDhcpOptionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDhcpOptionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateDhcpOptionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDhcpOptionsAsync provides a mock function.
func (_m *Mockec2clientstub) CreateDhcpOptionsAsync(ctx internal.Context, input *ec2.CreateDhcpOptionsInput) (_result_0 *ec2stub.CreateDhcpOptionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateDhcpOptionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateDhcpOptionsInput) *ec2stub.CreateDhcpOptionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateDhcpOptionsFuture)
		}
	}

	return r0
}

// CreateEgressOnlyInternetGateway provides a mock function.
func (_m *Mockec2clientstub) CreateEgressOnlyInternetGateway(ctx internal.Context, input *ec2.CreateEgressOnlyInternetGatewayInput) (_result_0 *ec2.CreateEgressOnlyInternetGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateEgressOnlyInternetGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateEgressOnlyInternetGatewayInput) *ec2.CreateEgressOnlyInternetGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateEgressOnlyInternetGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateEgressOnlyInternetGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEgressOnlyInternetGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) CreateEgressOnlyInternetGatewayAsync(ctx internal.Context, input *ec2.CreateEgressOnlyInternetGatewayInput) (_result_0 *ec2stub.CreateEgressOnlyInternetGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateEgressOnlyInternetGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateEgressOnlyInternetGatewayInput) *ec2stub.CreateEgressOnlyInternetGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateEgressOnlyInternetGatewayFuture)
		}
	}

	return r0
}

// CreateFleet provides a mock function.
func (_m *Mockec2clientstub) CreateFleet(ctx internal.Context, input *ec2.CreateFleetInput) (_result_0 *ec2.CreateFleetOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateFleetOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateFleetInput) *ec2.CreateFleetOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFleetOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateFleetInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFleetAsync provides a mock function.
func (_m *Mockec2clientstub) CreateFleetAsync(ctx internal.Context, input *ec2.CreateFleetInput) (_result_0 *ec2stub.CreateFleetFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateFleetFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateFleetInput) *ec2stub.CreateFleetFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateFleetFuture)
		}
	}

	return r0
}

// CreateFlowLogs provides a mock function.
func (_m *Mockec2clientstub) CreateFlowLogs(ctx internal.Context, input *ec2.CreateFlowLogsInput) (_result_0 *ec2.CreateFlowLogsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateFlowLogsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateFlowLogsInput) *ec2.CreateFlowLogsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFlowLogsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateFlowLogsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFlowLogsAsync provides a mock function.
func (_m *Mockec2clientstub) CreateFlowLogsAsync(ctx internal.Context, input *ec2.CreateFlowLogsInput) (_result_0 *ec2stub.CreateFlowLogsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateFlowLogsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateFlowLogsInput) *ec2stub.CreateFlowLogsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateFlowLogsFuture)
		}
	}

	return r0
}

// CreateFpgaImage provides a mock function.
func (_m *Mockec2clientstub) CreateFpgaImage(ctx internal.Context, input *ec2.CreateFpgaImageInput) (_result_0 *ec2.CreateFpgaImageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateFpgaImageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateFpgaImageInput) *ec2.CreateFpgaImageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFpgaImageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateFpgaImageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFpgaImageAsync provides a mock function.
func (_m *Mockec2clientstub) CreateFpgaImageAsync(ctx internal.Context, input *ec2.CreateFpgaImageInput) (_result_0 *ec2stub.CreateFpgaImageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateFpgaImageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateFpgaImageInput) *ec2stub.CreateFpgaImageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateFpgaImageFuture)
		}
	}

	return r0
}

// CreateImage provides a mock function.
func (_m *Mockec2clientstub) CreateImage(ctx internal.Context, input *ec2.CreateImageInput) (_result_0 *ec2.CreateImageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateImageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateImageInput) *ec2.CreateImageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateImageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateImageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateImageAsync provides a mock function.
func (_m *Mockec2clientstub) CreateImageAsync(ctx internal.Context, input *ec2.CreateImageInput) (_result_0 *ec2stub.CreateImageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateImageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateImageInput) *ec2stub.CreateImageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateImageFuture)
		}
	}

	return r0
}

// CreateInstanceExportTask provides a mock function.
func (_m *Mockec2clientstub) CreateInstanceExportTask(ctx internal.Context, input *ec2.CreateInstanceExportTaskInput) (_result_0 *ec2.CreateInstanceExportTaskOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateInstanceExportTaskOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateInstanceExportTaskInput) *ec2.CreateInstanceExportTaskOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInstanceExportTaskOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateInstanceExportTaskInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInstanceExportTaskAsync provides a mock function.
func (_m *Mockec2clientstub) CreateInstanceExportTaskAsync(ctx internal.Context, input *ec2.CreateInstanceExportTaskInput) (_result_0 *ec2stub.CreateInstanceExportTaskFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateInstanceExportTaskFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateInstanceExportTaskInput) *ec2stub.CreateInstanceExportTaskFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateInstanceExportTaskFuture)
		}
	}

	return r0
}

// CreateInternetGateway provides a mock function.
func (_m *Mockec2clientstub) CreateInternetGateway(ctx internal.Context, input *ec2.CreateInternetGatewayInput) (_result_0 *ec2.CreateInternetGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateInternetGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateInternetGatewayInput) *ec2.CreateInternetGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInternetGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateInternetGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInternetGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) CreateInternetGatewayAsync(ctx internal.Context, input *ec2.CreateInternetGatewayInput) (_result_0 *ec2stub.CreateInternetGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateInternetGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateInternetGatewayInput) *ec2stub.CreateInternetGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateInternetGatewayFuture)
		}
	}

	return r0
}

// CreateKeyPair provides a mock function.
func (_m *Mockec2clientstub) CreateKeyPair(ctx internal.Context, input *ec2.CreateKeyPairInput) (_result_0 *ec2.CreateKeyPairOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateKeyPairOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateKeyPairInput) *ec2.CreateKeyPairOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateKeyPairOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateKeyPairInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKeyPairAsync provides a mock function.
func (_m *Mockec2clientstub) CreateKeyPairAsync(ctx internal.Context, input *ec2.CreateKeyPairInput) (_result_0 *ec2stub.CreateKeyPairFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateKeyPairFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateKeyPairInput) *ec2stub.CreateKeyPairFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateKeyPairFuture)
		}
	}

	return r0
}

// CreateLaunchTemplate provides a mock function.
func (_m *Mockec2clientstub) CreateLaunchTemplate(ctx internal.Context, input *ec2.CreateLaunchTemplateInput) (_result_0 *ec2.CreateLaunchTemplateOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateLaunchTemplateOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateLaunchTemplateInput) *ec2.CreateLaunchTemplateOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLaunchTemplateOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateLaunchTemplateInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLaunchTemplateAsync provides a mock function.
func (_m *Mockec2clientstub) CreateLaunchTemplateAsync(ctx internal.Context, input *ec2.CreateLaunchTemplateInput) (_result_0 *ec2stub.CreateLaunchTemplateFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateLaunchTemplateFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateLaunchTemplateInput) *ec2stub.CreateLaunchTemplateFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateLaunchTemplateFuture)
		}
	}

	return r0
}

// CreateLaunchTemplateVersion provides a mock function.
func (_m *Mockec2clientstub) CreateLaunchTemplateVersion(ctx internal.Context, input *ec2.CreateLaunchTemplateVersionInput) (_result_0 *ec2.CreateLaunchTemplateVersionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateLaunchTemplateVersionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateLaunchTemplateVersionInput) *ec2.CreateLaunchTemplateVersionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLaunchTemplateVersionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateLaunchTemplateVersionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLaunchTemplateVersionAsync provides a mock function.
func (_m *Mockec2clientstub) CreateLaunchTemplateVersionAsync(ctx internal.Context, input *ec2.CreateLaunchTemplateVersionInput) (_result_0 *ec2stub.CreateLaunchTemplateVersionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateLaunchTemplateVersionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateLaunchTemplateVersionInput) *ec2stub.CreateLaunchTemplateVersionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateLaunchTemplateVersionFuture)
		}
	}

	return r0
}

// CreateLocalGatewayRoute provides a mock function.
func (_m *Mockec2clientstub) CreateLocalGatewayRoute(ctx internal.Context, input *ec2.CreateLocalGatewayRouteInput) (_result_0 *ec2.CreateLocalGatewayRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateLocalGatewayRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateLocalGatewayRouteInput) *ec2.CreateLocalGatewayRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateLocalGatewayRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayRouteAsync provides a mock function.
func (_m *Mockec2clientstub) CreateLocalGatewayRouteAsync(ctx internal.Context, input *ec2.CreateLocalGatewayRouteInput) (_result_0 *ec2stub.CreateLocalGatewayRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateLocalGatewayRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateLocalGatewayRouteInput) *ec2stub.CreateLocalGatewayRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateLocalGatewayRouteFuture)
		}
	}

	return r0
}

// CreateLocalGatewayRouteTableVpcAssociation provides a mock function.
func (_m *Mockec2clientstub) CreateLocalGatewayRouteTableVpcAssociation(ctx internal.Context, input *ec2.CreateLocalGatewayRouteTableVpcAssociationInput) (_result_0 *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput) *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayRouteTableVpcAssociationAsync provides a mock function.
func (_m *Mockec2clientstub) CreateLocalGatewayRouteTableVpcAssociationAsync(ctx internal.Context, input *ec2.CreateLocalGatewayRouteTableVpcAssociationInput) (_result_0 *ec2stub.CreateLocalGatewayRouteTableVpcAssociationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateLocalGatewayRouteTableVpcAssociationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput) *ec2stub.CreateLocalGatewayRouteTableVpcAssociationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateLocalGatewayRouteTableVpcAssociationFuture)
		}
	}

	return r0
}

// CreateManagedPrefixList provides a mock function.
func (_m *Mockec2clientstub) CreateManagedPrefixList(ctx internal.Context, input *ec2.CreateManagedPrefixListInput) (_result_0 *ec2.CreateManagedPrefixListOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateManagedPrefixListOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateManagedPrefixListInput) *ec2.CreateManagedPrefixListOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateManagedPrefixListOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateManagedPrefixListInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateManagedPrefixListAsync provides a mock function.
func (_m *Mockec2clientstub) CreateManagedPrefixListAsync(ctx internal.Context, input *ec2.CreateManagedPrefixListInput) (_result_0 *ec2stub.CreateManagedPrefixListFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateManagedPrefixListFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateManagedPrefixListInput) *ec2stub.CreateManagedPrefixListFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateManagedPrefixListFuture)
		}
	}

	return r0
}

// CreateNatGateway provides a mock function.
func (_m *Mockec2clientstub) CreateNatGateway(ctx internal.Context, input *ec2.CreateNatGatewayInput) (_result_0 *ec2.CreateNatGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateNatGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNatGatewayInput) *ec2.CreateNatGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNatGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateNatGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNatGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) CreateNatGatewayAsync(ctx internal.Context, input *ec2.CreateNatGatewayInput) (_result_0 *ec2stub.CreateNatGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateNatGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNatGatewayInput) *ec2stub.CreateNatGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateNatGatewayFuture)
		}
	}

	return r0
}

// CreateNetworkAcl provides a mock function.
func (_m *Mockec2clientstub) CreateNetworkAcl(ctx internal.Context, input *ec2.CreateNetworkAclInput) (_result_0 *ec2.CreateNetworkAclOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateNetworkAclOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNetworkAclInput) *ec2.CreateNetworkAclOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkAclOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateNetworkAclInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkAclAsync provides a mock function.
func (_m *Mockec2clientstub) CreateNetworkAclAsync(ctx internal.Context, input *ec2.CreateNetworkAclInput) (_result_0 *ec2stub.CreateNetworkAclFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateNetworkAclFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNetworkAclInput) *ec2stub.CreateNetworkAclFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateNetworkAclFuture)
		}
	}

	return r0
}

// CreateNetworkAclEntry provides a mock function.
func (_m *Mockec2clientstub) CreateNetworkAclEntry(ctx internal.Context, input *ec2.CreateNetworkAclEntryInput) (_result_0 *ec2.CreateNetworkAclEntryOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateNetworkAclEntryOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNetworkAclEntryInput) *ec2.CreateNetworkAclEntryOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkAclEntryOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateNetworkAclEntryInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkAclEntryAsync provides a mock function.
func (_m *Mockec2clientstub) CreateNetworkAclEntryAsync(ctx internal.Context, input *ec2.CreateNetworkAclEntryInput) (_result_0 *ec2stub.CreateNetworkAclEntryFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateNetworkAclEntryFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNetworkAclEntryInput) *ec2stub.CreateNetworkAclEntryFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateNetworkAclEntryFuture)
		}
	}

	return r0
}

// CreateNetworkInterface provides a mock function.
func (_m *Mockec2clientstub) CreateNetworkInterface(ctx internal.Context, input *ec2.CreateNetworkInterfaceInput) (_result_0 *ec2.CreateNetworkInterfaceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateNetworkInterfaceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNetworkInterfaceInput) *ec2.CreateNetworkInterfaceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInterfaceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateNetworkInterfaceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInterfaceAsync provides a mock function.
func (_m *Mockec2clientstub) CreateNetworkInterfaceAsync(ctx internal.Context, input *ec2.CreateNetworkInterfaceInput) (_result_0 *ec2stub.CreateNetworkInterfaceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateNetworkInterfaceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNetworkInterfaceInput) *ec2stub.CreateNetworkInterfaceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateNetworkInterfaceFuture)
		}
	}

	return r0
}

// CreateNetworkInterfacePermission provides a mock function.
func (_m *Mockec2clientstub) CreateNetworkInterfacePermission(ctx internal.Context, input *ec2.CreateNetworkInterfacePermissionInput) (_result_0 *ec2.CreateNetworkInterfacePermissionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateNetworkInterfacePermissionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNetworkInterfacePermissionInput) *ec2.CreateNetworkInterfacePermissionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInterfacePermissionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateNetworkInterfacePermissionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInterfacePermissionAsync provides a mock function.
func (_m *Mockec2clientstub) CreateNetworkInterfacePermissionAsync(ctx internal.Context, input *ec2.CreateNetworkInterfacePermissionInput) (_result_0 *ec2stub.CreateNetworkInterfacePermissionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateNetworkInterfacePermissionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateNetworkInterfacePermissionInput) *ec2stub.CreateNetworkInterfacePermissionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateNetworkInterfacePermissionFuture)
		}
	}

	return r0
}

// CreatePlacementGroup provides a mock function.
func (_m *Mockec2clientstub) CreatePlacementGroup(ctx internal.Context, input *ec2.CreatePlacementGroupInput) (_result_0 *ec2.CreatePlacementGroupOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreatePlacementGroupOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreatePlacementGroupInput) *ec2.CreatePlacementGroupOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreatePlacementGroupOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreatePlacementGroupInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePlacementGroupAsync provides a mock function.
func (_m *Mockec2clientstub) CreatePlacementGroupAsync(ctx internal.Context, input *ec2.CreatePlacementGroupInput) (_result_0 *ec2stub.CreatePlacementGroupFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreatePlacementGroupFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreatePlacementGroupInput) *ec2stub.CreatePlacementGroupFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreatePlacementGroupFuture)
		}
	}

	return r0
}

// CreateReservedInstancesListing provides a mock function.
func (_m *Mockec2clientstub) CreateReservedInstancesListing(ctx internal.Context, input *ec2.CreateReservedInstancesListingInput) (_result_0 *ec2.CreateReservedInstancesListingOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateReservedInstancesListingOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateReservedInstancesListingInput) *ec2.CreateReservedInstancesListingOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateReservedInstancesListingOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateReservedInstancesListingInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReservedInstancesListingAsync provides a mock function.
func (_m *Mockec2clientstub) CreateReservedInstancesListingAsync(ctx internal.Context, input *ec2.CreateReservedInstancesListingInput) (_result_0 *ec2stub.CreateReservedInstancesListingFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateReservedInstancesListingFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateReservedInstancesListingInput) *ec2stub.CreateReservedInstancesListingFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateReservedInstancesListingFuture)
		}
	}

	return r0
}

// CreateRoute provides a mock function.
func (_m *Mockec2clientstub) CreateRoute(ctx internal.Context, input *ec2.CreateRouteInput) (_result_0 *ec2.CreateRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateRouteInput) *ec2.CreateRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRouteAsync provides a mock function.
func (_m *Mockec2clientstub) CreateRouteAsync(ctx internal.Context, input *ec2.CreateRouteInput) (_result_0 *ec2stub.CreateRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateRouteInput) *ec2stub.CreateRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateRouteFuture)
		}
	}

	return r0
}

// CreateRouteTable provides a mock function.
func (_m *Mockec2clientstub) CreateRouteTable(ctx internal.Context, input *ec2.CreateRouteTableInput) (_result_0 *ec2.CreateRouteTableOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateRouteTableOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateRouteTableInput) *ec2.CreateRouteTableOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteTableOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateRouteTableInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRouteTableAsync provides a mock function.
func (_m *Mockec2clientstub) CreateRouteTableAsync(ctx internal.Context, input *ec2.CreateRouteTableInput) (_result_0 *ec2stub.CreateRouteTableFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateRouteTableFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateRouteTableInput) *ec2stub.CreateRouteTableFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateRouteTableFuture)
		}
	}

	return r0
}

// CreateSecurityGroup provides a mock function.
func (_m *Mockec2clientstub) CreateSecurityGroup(ctx internal.Context, input *ec2.CreateSecurityGroupInput) (_result_0 *ec2.CreateSecurityGroupOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateSecurityGroupOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSecurityGroupInput) *ec2.CreateSecurityGroupOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSecurityGroupOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateSecurityGroupInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSecurityGroupAsync provides a mock function.
func (_m *Mockec2clientstub) CreateSecurityGroupAsync(ctx internal.Context, input *ec2.CreateSecurityGroupInput) (_result_0 *ec2stub.CreateSecurityGroupFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateSecurityGroupFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSecurityGroupInput) *ec2stub.CreateSecurityGroupFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateSecurityGroupFuture)
		}
	}

	return r0
}

// CreateSnapshot provides a mock function.
func (_m *Mockec2clientstub) CreateSnapshot(ctx internal.Context, input *ec2.CreateSnapshotInput) (_result_0 *ec2.Snapshot, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.Snapshot
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSnapshotInput) *ec2.Snapshot); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.Snapshot)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateSnapshotInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshotAsync provides a mock function.
func (_m *Mockec2clientstub) CreateSnapshotAsync(ctx internal.Context, input *ec2.CreateSnapshotInput) (_result_0 *ec2stub.CreateSnapshotFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateSnapshotFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSnapshotInput) *ec2stub.CreateSnapshotFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateSnapshotFuture)
		}
	}

	return r0
}

// CreateSnapshots provides a mock function.
func (_m *Mockec2clientstub) CreateSnapshots(ctx internal.Context, input *ec2.CreateSnapshotsInput) (_result_0 *ec2.CreateSnapshotsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateSnapshotsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSnapshotsInput) *ec2.CreateSnapshotsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSnapshotsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateSnapshotsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshotsAsync provides a mock function.
func (_m *Mockec2clientstub) CreateSnapshotsAsync(ctx internal.Context, input *ec2.CreateSnapshotsInput) (_result_0 *ec2stub.CreateSnapshotsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateSnapshotsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSnapshotsInput) *ec2stub.CreateSnapshotsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateSnapshotsFuture)
		}
	}

	return r0
}

// CreateSpotDatafeedSubscription provides a mock function.
func (_m *Mockec2clientstub) CreateSpotDatafeedSubscription(ctx internal.Context, input *ec2.CreateSpotDatafeedSubscriptionInput) (_result_0 *ec2.CreateSpotDatafeedSubscriptionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateSpotDatafeedSubscriptionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSpotDatafeedSubscriptionInput) *ec2.CreateSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSpotDatafeedSubscriptionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateSpotDatafeedSubscriptionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSpotDatafeedSubscriptionAsync provides a mock function.
func (_m *Mockec2clientstub) CreateSpotDatafeedSubscriptionAsync(ctx internal.Context, input *ec2.CreateSpotDatafeedSubscriptionInput) (_result_0 *ec2stub.CreateSpotDatafeedSubscriptionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateSpotDatafeedSubscriptionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSpotDatafeedSubscriptionInput) *ec2stub.CreateSpotDatafeedSubscriptionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateSpotDatafeedSubscriptionFuture)
		}
	}

	return r0
}

// CreateSubnet provides a mock function.
func (_m *Mockec2clientstub) CreateSubnet(ctx internal.Context, input *ec2.CreateSubnetInput) (_result_0 *ec2.CreateSubnetOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateSubnetOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSubnetInput) *ec2.CreateSubnetOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSubnetOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateSubnetInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubnetAsync provides a mock function.
func (_m *Mockec2clientstub) CreateSubnetAsync(ctx internal.Context, input *ec2.CreateSubnetInput) (_result_0 *ec2stub.CreateSubnetFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateSubnetFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateSubnetInput) *ec2stub.CreateSubnetFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateSubnetFuture)
		}
	}

	return r0
}

// CreateTags provides a mock function.
func (_m *Mockec2clientstub) CreateTags(ctx internal.Context, input *ec2.CreateTagsInput) (_result_0 *ec2.CreateTagsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTagsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTagsInput) *ec2.CreateTagsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTagsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTagsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTagsAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTagsAsync(ctx internal.Context, input *ec2.CreateTagsInput) (_result_0 *ec2stub.CreateTagsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTagsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTagsInput) *ec2stub.CreateTagsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTagsFuture)
		}
	}

	return r0
}

// CreateTrafficMirrorFilter provides a mock function.
func (_m *Mockec2clientstub) CreateTrafficMirrorFilter(ctx internal.Context, input *ec2.CreateTrafficMirrorFilterInput) (_result_0 *ec2.CreateTrafficMirrorFilterOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTrafficMirrorFilterOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTrafficMirrorFilterInput) *ec2.CreateTrafficMirrorFilterOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorFilterOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTrafficMirrorFilterInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorFilterAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTrafficMirrorFilterAsync(ctx internal.Context, input *ec2.CreateTrafficMirrorFilterInput) (_result_0 *ec2stub.CreateTrafficMirrorFilterFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTrafficMirrorFilterFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTrafficMirrorFilterInput) *ec2stub.CreateTrafficMirrorFilterFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTrafficMirrorFilterFuture)
		}
	}

	return r0
}

// CreateTrafficMirrorFilterRule provides a mock function.
func (_m *Mockec2clientstub) CreateTrafficMirrorFilterRule(ctx internal.Context, input *ec2.CreateTrafficMirrorFilterRuleInput) (_result_0 *ec2.CreateTrafficMirrorFilterRuleOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTrafficMirrorFilterRuleOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTrafficMirrorFilterRuleInput) *ec2.CreateTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorFilterRuleOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTrafficMirrorFilterRuleInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorFilterRuleAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTrafficMirrorFilterRuleAsync(ctx internal.Context, input *ec2.CreateTrafficMirrorFilterRuleInput) (_result_0 *ec2stub.CreateTrafficMirrorFilterRuleFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTrafficMirrorFilterRuleFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTrafficMirrorFilterRuleInput) *ec2stub.CreateTrafficMirrorFilterRuleFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTrafficMirrorFilterRuleFuture)
		}
	}

	return r0
}

// CreateTrafficMirrorSession provides a mock function.
func (_m *Mockec2clientstub) CreateTrafficMirrorSession(ctx internal.Context, input *ec2.CreateTrafficMirrorSessionInput) (_result_0 *ec2.CreateTrafficMirrorSessionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTrafficMirrorSessionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTrafficMirrorSessionInput) *ec2.CreateTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorSessionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTrafficMirrorSessionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorSessionAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTrafficMirrorSessionAsync(ctx internal.Context, input *ec2.CreateTrafficMirrorSessionInput) (_result_0 *ec2stub.CreateTrafficMirrorSessionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTrafficMirrorSessionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTrafficMirrorSessionInput) *ec2stub.CreateTrafficMirrorSessionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTrafficMirrorSessionFuture)
		}
	}

	return r0
}

// CreateTrafficMirrorTarget provides a mock function.
func (_m *Mockec2clientstub) CreateTrafficMirrorTarget(ctx internal.Context, input *ec2.CreateTrafficMirrorTargetInput) (_result_0 *ec2.CreateTrafficMirrorTargetOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTrafficMirrorTargetOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTrafficMirrorTargetInput) *ec2.CreateTrafficMirrorTargetOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorTargetOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTrafficMirrorTargetInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorTargetAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTrafficMirrorTargetAsync(ctx internal.Context, input *ec2.CreateTrafficMirrorTargetInput) (_result_0 *ec2stub.CreateTrafficMirrorTargetFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTrafficMirrorTargetFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTrafficMirrorTargetInput) *ec2stub.CreateTrafficMirrorTargetFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTrafficMirrorTargetFuture)
		}
	}

	return r0
}

// CreateTransitGateway provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGateway(ctx internal.Context, input *ec2.CreateTransitGatewayInput) (_result_0 *ec2.CreateTransitGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTransitGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayInput) *ec2.CreateTransitGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTransitGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayAsync(ctx internal.Context, input *ec2.CreateTransitGatewayInput) (_result_0 *ec2stub.CreateTransitGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTransitGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayInput) *ec2stub.CreateTransitGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTransitGatewayFuture)
		}
	}

	return r0
}

// CreateTransitGatewayMulticastDomain provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayMulticastDomain(ctx internal.Context, input *ec2.CreateTransitGatewayMulticastDomainInput) (_result_0 *ec2.CreateTransitGatewayMulticastDomainOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTransitGatewayMulticastDomainOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayMulticastDomainInput) *ec2.CreateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayMulticastDomainOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTransitGatewayMulticastDomainInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayMulticastDomainAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayMulticastDomainAsync(ctx internal.Context, input *ec2.CreateTransitGatewayMulticastDomainInput) (_result_0 *ec2stub.CreateTransitGatewayMulticastDomainFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTransitGatewayMulticastDomainFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayMulticastDomainInput) *ec2stub.CreateTransitGatewayMulticastDomainFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTransitGatewayMulticastDomainFuture)
		}
	}

	return r0
}

// CreateTransitGatewayPeeringAttachment provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayPeeringAttachment(ctx internal.Context, input *ec2.CreateTransitGatewayPeeringAttachmentInput) (_result_0 *ec2.CreateTransitGatewayPeeringAttachmentOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTransitGatewayPeeringAttachmentOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput) *ec2.CreateTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayPeeringAttachmentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayPeeringAttachmentAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayPeeringAttachmentAsync(ctx internal.Context, input *ec2.CreateTransitGatewayPeeringAttachmentInput) (_result_0 *ec2stub.CreateTransitGatewayPeeringAttachmentFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTransitGatewayPeeringAttachmentFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput) *ec2stub.CreateTransitGatewayPeeringAttachmentFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTransitGatewayPeeringAttachmentFuture)
		}
	}

	return r0
}

// CreateTransitGatewayPrefixListReference provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayPrefixListReference(ctx internal.Context, input *ec2.CreateTransitGatewayPrefixListReferenceInput) (_result_0 *ec2.CreateTransitGatewayPrefixListReferenceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTransitGatewayPrefixListReferenceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput) *ec2.CreateTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayPrefixListReferenceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayPrefixListReferenceAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayPrefixListReferenceAsync(ctx internal.Context, input *ec2.CreateTransitGatewayPrefixListReferenceInput) (_result_0 *ec2stub.CreateTransitGatewayPrefixListReferenceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTransitGatewayPrefixListReferenceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput) *ec2stub.CreateTransitGatewayPrefixListReferenceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTransitGatewayPrefixListReferenceFuture)
		}
	}

	return r0
}

// CreateTransitGatewayRoute provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayRoute(ctx internal.Context, input *ec2.CreateTransitGatewayRouteInput) (_result_0 *ec2.CreateTransitGatewayRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTransitGatewayRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayRouteInput) *ec2.CreateTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTransitGatewayRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayRouteAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayRouteAsync(ctx internal.Context, input *ec2.CreateTransitGatewayRouteInput) (_result_0 *ec2stub.CreateTransitGatewayRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTransitGatewayRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayRouteInput) *ec2stub.CreateTransitGatewayRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTransitGatewayRouteFuture)
		}
	}

	return r0
}

// CreateTransitGatewayRouteTable provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayRouteTable(ctx internal.Context, input *ec2.CreateTransitGatewayRouteTableInput) (_result_0 *ec2.CreateTransitGatewayRouteTableOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTransitGatewayRouteTableOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayRouteTableInput) *ec2.CreateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayRouteTableOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTransitGatewayRouteTableInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayRouteTableAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayRouteTableAsync(ctx internal.Context, input *ec2.CreateTransitGatewayRouteTableInput) (_result_0 *ec2stub.CreateTransitGatewayRouteTableFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTransitGatewayRouteTableFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayRouteTableInput) *ec2stub.CreateTransitGatewayRouteTableFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTransitGatewayRouteTableFuture)
		}
	}

	return r0
}

// CreateTransitGatewayVpcAttachment provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayVpcAttachment(ctx internal.Context, input *ec2.CreateTransitGatewayVpcAttachmentInput) (_result_0 *ec2.CreateTransitGatewayVpcAttachmentOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateTransitGatewayVpcAttachmentOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayVpcAttachmentInput) *ec2.CreateTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayVpcAttachmentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateTransitGatewayVpcAttachmentInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayVpcAttachmentAsync provides a mock function.
func (_m *Mockec2clientstub) CreateTransitGatewayVpcAttachmentAsync(ctx internal.Context, input *ec2.CreateTransitGatewayVpcAttachmentInput) (_result_0 *ec2stub.CreateTransitGatewayVpcAttachmentFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateTransitGatewayVpcAttachmentFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateTransitGatewayVpcAttachmentInput) *ec2stub.CreateTransitGatewayVpcAttachmentFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateTransitGatewayVpcAttachmentFuture)
		}
	}

	return r0
}

// CreateVolume provides a mock function.
func (_m *Mockec2clientstub) CreateVolume(ctx internal.Context, input *ec2.CreateVolumeInput) (_result_0 *ec2.Volume, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.Volume
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVolumeInput) *ec2.Volume); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.Volume)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateVolumeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVolumeAsync provides a mock function.
func (_m *Mockec2clientstub) CreateVolumeAsync(ctx internal.Context, input *ec2.CreateVolumeInput) (_result_0 *ec2stub.CreateVolumeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateVolumeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVolumeInput) *ec2stub.CreateVolumeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateVolumeFuture)
		}
	}

	return r0
}

// CreateVpc provides a mock function.
func (_m *Mockec2clientstub) CreateVpc(ctx internal.Context, input *ec2.CreateVpcInput) (_result_0 *ec2.CreateVpcOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateVpcOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcInput) *ec2.CreateVpcOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateVpcInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcAsync provides a mock function.
func (_m *Mockec2clientstub) CreateVpcAsync(ctx internal.Context, input *ec2.CreateVpcInput) (_result_0 *ec2stub.CreateVpcFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateVpcFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcInput) *ec2stub.CreateVpcFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateVpcFuture)
		}
	}

	return r0
}

// CreateVpcEndpoint provides a mock function.
func (_m *Mockec2clientstub) CreateVpcEndpoint(ctx internal.Context, input *ec2.CreateVpcEndpointInput) (_result_0 *ec2.CreateVpcEndpointOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateVpcEndpointOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcEndpointInput) *ec2.CreateVpcEndpointOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateVpcEndpointInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpointAsync provides a mock function.
func (_m *Mockec2clientstub) CreateVpcEndpointAsync(ctx internal.Context, input *ec2.CreateVpcEndpointInput) (_result_0 *ec2stub.CreateVpcEndpointFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateVpcEndpointFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcEndpointInput) *ec2stub.CreateVpcEndpointFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateVpcEndpointFuture)
		}
	}

	return r0
}

// CreateVpcEndpointConnectionNotification provides a mock function.
func (_m *Mockec2clientstub) CreateVpcEndpointConnectionNotification(ctx internal.Context, input *ec2.CreateVpcEndpointConnectionNotificationInput) (_result_0 *ec2.CreateVpcEndpointConnectionNotificationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateVpcEndpointConnectionNotificationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcEndpointConnectionNotificationInput) *ec2.CreateVpcEndpointConnectionNotificationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointConnectionNotificationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateVpcEndpointConnectionNotificationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpointConnectionNotificationAsync provides a mock function.
func (_m *Mockec2clientstub) CreateVpcEndpointConnectionNotificationAsync(ctx internal.Context, input *ec2.CreateVpcEndpointConnectionNotificationInput) (_result_0 *ec2stub.CreateVpcEndpointConnectionNotificationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateVpcEndpointConnectionNotificationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcEndpointConnectionNotificationInput) *ec2stub.CreateVpcEndpointConnectionNotificationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateVpcEndpointConnectionNotificationFuture)
		}
	}

	return r0
}

// CreateVpcEndpointServiceConfiguration provides a mock function.
func (_m *Mockec2clientstub) CreateVpcEndpointServiceConfiguration(ctx internal.Context, input *ec2.CreateVpcEndpointServiceConfigurationInput) (_result_0 *ec2.CreateVpcEndpointServiceConfigurationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateVpcEndpointServiceConfigurationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcEndpointServiceConfigurationInput) *ec2.CreateVpcEndpointServiceConfigurationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointServiceConfigurationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateVpcEndpointServiceConfigurationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpointServiceConfigurationAsync provides a mock function.
func (_m *Mockec2clientstub) CreateVpcEndpointServiceConfigurationAsync(ctx internal.Context, input *ec2.CreateVpcEndpointServiceConfigurationInput) (_result_0 *ec2stub.CreateVpcEndpointServiceConfigurationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateVpcEndpointServiceConfigurationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcEndpointServiceConfigurationInput) *ec2stub.CreateVpcEndpointServiceConfigurationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateVpcEndpointServiceConfigurationFuture)
		}
	}

	return r0
}

// CreateVpcPeeringConnection provides a mock function.
func (_m *Mockec2clientstub) CreateVpcPeeringConnection(ctx internal.Context, input *ec2.CreateVpcPeeringConnectionInput) (_result_0 *ec2.CreateVpcPeeringConnectionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateVpcPeeringConnectionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcPeeringConnectionInput) *ec2.CreateVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcPeeringConnectionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateVpcPeeringConnectionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcPeeringConnectionAsync provides a mock function.
func (_m *Mockec2clientstub) CreateVpcPeeringConnectionAsync(ctx internal.Context, input *ec2.CreateVpcPeeringConnectionInput) (_result_0 *ec2stub.CreateVpcPeeringConnectionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateVpcPeeringConnectionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpcPeeringConnectionInput) *ec2stub.CreateVpcPeeringConnectionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateVpcPeeringConnectionFuture)
		}
	}

	return r0
}

// CreateVpnConnection provides a mock function.
func (_m *Mockec2clientstub) CreateVpnConnection(ctx internal.Context, input *ec2.CreateVpnConnectionInput) (_result_0 *ec2.CreateVpnConnectionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateVpnConnectionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpnConnectionInput) *ec2.CreateVpnConnectionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnConnectionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateVpnConnectionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnConnectionAsync provides a mock function.
func (_m *Mockec2clientstub) CreateVpnConnectionAsync(ctx internal.Context, input *ec2.CreateVpnConnectionInput) (_result_0 *ec2stub.CreateVpnConnectionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateVpnConnectionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpnConnectionInput) *ec2stub.CreateVpnConnectionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateVpnConnectionFuture)
		}
	}

	return r0
}

// CreateVpnConnectionRoute provides a mock function.
func (_m *Mockec2clientstub) CreateVpnConnectionRoute(ctx internal.Context, input *ec2.CreateVpnConnectionRouteInput) (_result_0 *ec2.CreateVpnConnectionRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateVpnConnectionRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpnConnectionRouteInput) *ec2.CreateVpnConnectionRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnConnectionRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateVpnConnectionRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnConnectionRouteAsync provides a mock function.
func (_m *Mockec2clientstub) CreateVpnConnectionRouteAsync(ctx internal.Context, input *ec2.CreateVpnConnectionRouteInput) (_result_0 *ec2stub.CreateVpnConnectionRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateVpnConnectionRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpnConnectionRouteInput) *ec2stub.CreateVpnConnectionRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateVpnConnectionRouteFuture)
		}
	}

	return r0
}

// CreateVpnGateway provides a mock function.
func (_m *Mockec2clientstub) CreateVpnGateway(ctx internal.Context, input *ec2.CreateVpnGatewayInput) (_result_0 *ec2.CreateVpnGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.CreateVpnGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpnGatewayInput) *ec2.CreateVpnGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.CreateVpnGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) CreateVpnGatewayAsync(ctx internal.Context, input *ec2.CreateVpnGatewayInput) (_result_0 *ec2stub.CreateVpnGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.CreateVpnGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.CreateVpnGatewayInput) *ec2stub.CreateVpnGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.CreateVpnGatewayFuture)
		}
	}

	return r0
}

// DeleteCarrierGateway provides a mock function.
func (_m *Mockec2clientstub) DeleteCarrierGateway(ctx internal.Context, input *ec2.DeleteCarrierGatewayInput) (_result_0 *ec2.DeleteCarrierGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteCarrierGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteCarrierGatewayInput) *ec2.DeleteCarrierGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCarrierGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteCarrierGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCarrierGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteCarrierGatewayAsync(ctx internal.Context, input *ec2.DeleteCarrierGatewayInput) (_result_0 *ec2stub.DeleteCarrierGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteCarrierGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteCarrierGatewayInput) *ec2stub.DeleteCarrierGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteCarrierGatewayFuture)
		}
	}

	return r0
}

// DeleteClientVpnEndpoint provides a mock function.
func (_m *Mockec2clientstub) DeleteClientVpnEndpoint(ctx internal.Context, input *ec2.DeleteClientVpnEndpointInput) (_result_0 *ec2.DeleteClientVpnEndpointOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteClientVpnEndpointOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteClientVpnEndpointInput) *ec2.DeleteClientVpnEndpointOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteClientVpnEndpointOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteClientVpnEndpointInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClientVpnEndpointAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteClientVpnEndpointAsync(ctx internal.Context, input *ec2.DeleteClientVpnEndpointInput) (_result_0 *ec2stub.DeleteClientVpnEndpointFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteClientVpnEndpointFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteClientVpnEndpointInput) *ec2stub.DeleteClientVpnEndpointFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteClientVpnEndpointFuture)
		}
	}

	return r0
}

// DeleteClientVpnRoute provides a mock function.
func (_m *Mockec2clientstub) DeleteClientVpnRoute(ctx internal.Context, input *ec2.DeleteClientVpnRouteInput) (_result_0 *ec2.DeleteClientVpnRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteClientVpnRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteClientVpnRouteInput) *ec2.DeleteClientVpnRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteClientVpnRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteClientVpnRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClientVpnRouteAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteClientVpnRouteAsync(ctx internal.Context, input *ec2.DeleteClientVpnRouteInput) (_result_0 *ec2stub.DeleteClientVpnRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteClientVpnRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteClientVpnRouteInput) *ec2stub.DeleteClientVpnRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteClientVpnRouteFuture)
		}
	}

	return r0
}

// DeleteCustomerGateway provides a mock function.
func (_m *Mockec2clientstub) DeleteCustomerGateway(ctx internal.Context, input *ec2.DeleteCustomerGatewayInput) (_result_0 *ec2.DeleteCustomerGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteCustomerGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteCustomerGatewayInput) *ec2.DeleteCustomerGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCustomerGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteCustomerGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomerGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteCustomerGatewayAsync(ctx internal.Context, input *ec2.DeleteCustomerGatewayInput) (_result_0 *ec2stub.DeleteCustomerGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteCustomerGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteCustomerGatewayInput) *ec2stub.DeleteCustomerGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteCustomerGatewayFuture)
		}
	}

	return r0
}

// DeleteDhcpOptions provides a mock function.
func (_m *Mockec2clientstub) DeleteDhcpOptions(ctx internal.Context, input *ec2.DeleteDhcpOptionsInput) (_result_0 *ec2.DeleteDhcpOptionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteDhcpOptionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteDhcpOptionsInput) *ec2.DeleteDhcpOptionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteDhcpOptionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteDhcpOptionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDhcpOptionsAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteDhcpOptionsAsync(ctx internal.Context, input *ec2.DeleteDhcpOptionsInput) (_result_0 *ec2stub.DeleteDhcpOptionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteDhcpOptionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteDhcpOptionsInput) *ec2stub.DeleteDhcpOptionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteDhcpOptionsFuture)
		}
	}

	return r0
}

// DeleteEgressOnlyInternetGateway provides a mock function.
func (_m *Mockec2clientstub) DeleteEgressOnlyInternetGateway(ctx internal.Context, input *ec2.DeleteEgressOnlyInternetGatewayInput) (_result_0 *ec2.DeleteEgressOnlyInternetGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteEgressOnlyInternetGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteEgressOnlyInternetGatewayInput) *ec2.DeleteEgressOnlyInternetGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteEgressOnlyInternetGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteEgressOnlyInternetGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEgressOnlyInternetGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteEgressOnlyInternetGatewayAsync(ctx internal.Context, input *ec2.DeleteEgressOnlyInternetGatewayInput) (_result_0 *ec2stub.DeleteEgressOnlyInternetGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteEgressOnlyInternetGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteEgressOnlyInternetGatewayInput) *ec2stub.DeleteEgressOnlyInternetGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteEgressOnlyInternetGatewayFuture)
		}
	}

	return r0
}

// DeleteFleets provides a mock function.
func (_m *Mockec2clientstub) DeleteFleets(ctx internal.Context, input *ec2.DeleteFleetsInput) (_result_0 *ec2.DeleteFleetsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteFleetsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteFleetsInput) *ec2.DeleteFleetsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFleetsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteFleetsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFleetsAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteFleetsAsync(ctx internal.Context, input *ec2.DeleteFleetsInput) (_result_0 *ec2stub.DeleteFleetsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteFleetsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteFleetsInput) *ec2stub.DeleteFleetsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteFleetsFuture)
		}
	}

	return r0
}

// DeleteFlowLogs provides a mock function.
func (_m *Mockec2clientstub) DeleteFlowLogs(ctx internal.Context, input *ec2.DeleteFlowLogsInput) (_result_0 *ec2.DeleteFlowLogsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteFlowLogsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteFlowLogsInput) *ec2.DeleteFlowLogsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFlowLogsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteFlowLogsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFlowLogsAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteFlowLogsAsync(ctx internal.Context, input *ec2.DeleteFlowLogsInput) (_result_0 *ec2stub.DeleteFlowLogsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteFlowLogsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteFlowLogsInput) *ec2stub.DeleteFlowLogsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteFlowLogsFuture)
		}
	}

	return r0
}

// DeleteFpgaImage provides a mock function.
func (_m *Mockec2clientstub) DeleteFpgaImage(ctx internal.Context, input *ec2.DeleteFpgaImageInput) (_result_0 *ec2.DeleteFpgaImageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteFpgaImageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteFpgaImageInput) *ec2.DeleteFpgaImageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFpgaImageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteFpgaImageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFpgaImageAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteFpgaImageAsync(ctx internal.Context, input *ec2.DeleteFpgaImageInput) (_result_0 *ec2stub.DeleteFpgaImageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteFpgaImageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteFpgaImageInput) *ec2stub.DeleteFpgaImageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteFpgaImageFuture)
		}
	}

	return r0
}

// DeleteInternetGateway provides a mock function.
func (_m *Mockec2clientstub) DeleteInternetGateway(ctx internal.Context, input *ec2.DeleteInternetGatewayInput) (_result_0 *ec2.DeleteInternetGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteInternetGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteInternetGatewayInput) *ec2.DeleteInternetGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteInternetGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteInternetGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInternetGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteInternetGatewayAsync(ctx internal.Context, input *ec2.DeleteInternetGatewayInput) (_result_0 *ec2stub.DeleteInternetGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteInternetGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteInternetGatewayInput) *ec2stub.DeleteInternetGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteInternetGatewayFuture)
		}
	}

	return r0
}

// DeleteKeyPair provides a mock function.
func (_m *Mockec2clientstub) DeleteKeyPair(ctx internal.Context, input *ec2.DeleteKeyPairInput) (_result_0 *ec2.DeleteKeyPairOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteKeyPairOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteKeyPairInput) *ec2.DeleteKeyPairOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteKeyPairOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteKeyPairInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKeyPairAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteKeyPairAsync(ctx internal.Context, input *ec2.DeleteKeyPairInput) (_result_0 *ec2stub.DeleteKeyPairFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteKeyPairFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteKeyPairInput) *ec2stub.DeleteKeyPairFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteKeyPairFuture)
		}
	}

	return r0
}

// DeleteLaunchTemplate provides a mock function.
func (_m *Mockec2clientstub) DeleteLaunchTemplate(ctx internal.Context, input *ec2.DeleteLaunchTemplateInput) (_result_0 *ec2.DeleteLaunchTemplateOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteLaunchTemplateOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteLaunchTemplateInput) *ec2.DeleteLaunchTemplateOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLaunchTemplateOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteLaunchTemplateInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLaunchTemplateAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteLaunchTemplateAsync(ctx internal.Context, input *ec2.DeleteLaunchTemplateInput) (_result_0 *ec2stub.DeleteLaunchTemplateFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteLaunchTemplateFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteLaunchTemplateInput) *ec2stub.DeleteLaunchTemplateFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteLaunchTemplateFuture)
		}
	}

	return r0
}

// DeleteLaunchTemplateVersions provides a mock function.
func (_m *Mockec2clientstub) DeleteLaunchTemplateVersions(ctx internal.Context, input *ec2.DeleteLaunchTemplateVersionsInput) (_result_0 *ec2.DeleteLaunchTemplateVersionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteLaunchTemplateVersionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteLaunchTemplateVersionsInput) *ec2.DeleteLaunchTemplateVersionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLaunchTemplateVersionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteLaunchTemplateVersionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLaunchTemplateVersionsAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteLaunchTemplateVersionsAsync(ctx internal.Context, input *ec2.DeleteLaunchTemplateVersionsInput) (_result_0 *ec2stub.DeleteLaunchTemplateVersionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteLaunchTemplateVersionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteLaunchTemplateVersionsInput) *ec2stub.DeleteLaunchTemplateVersionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteLaunchTemplateVersionsFuture)
		}
	}

	return r0
}

// DeleteLocalGatewayRoute provides a mock function.
func (_m *Mockec2clientstub) DeleteLocalGatewayRoute(ctx internal.Context, input *ec2.DeleteLocalGatewayRouteInput) (_result_0 *ec2.DeleteLocalGatewayRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteLocalGatewayRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteLocalGatewayRouteInput) *ec2.DeleteLocalGatewayRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteLocalGatewayRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayRouteAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteLocalGatewayRouteAsync(ctx internal.Context, input *ec2.DeleteLocalGatewayRouteInput) (_result_0 *ec2stub.DeleteLocalGatewayRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteLocalGatewayRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteLocalGatewayRouteInput) *ec2stub.DeleteLocalGatewayRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteLocalGatewayRouteFuture)
		}
	}

	return r0
}

// DeleteLocalGatewayRouteTableVpcAssociation provides a mock function.
func (_m *Mockec2clientstub) DeleteLocalGatewayRouteTableVpcAssociation(ctx internal.Context, input *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput) (_result_0 *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput) *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayRouteTableVpcAssociationAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteLocalGatewayRouteTableVpcAssociationAsync(ctx internal.Context, input *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput) (_result_0 *ec2stub.DeleteLocalGatewayRouteTableVpcAssociationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteLocalGatewayRouteTableVpcAssociationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput) *ec2stub.DeleteLocalGatewayRouteTableVpcAssociationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteLocalGatewayRouteTableVpcAssociationFuture)
		}
	}

	return r0
}

// DeleteManagedPrefixList provides a mock function.
func (_m *Mockec2clientstub) DeleteManagedPrefixList(ctx internal.Context, input *ec2.DeleteManagedPrefixListInput) (_result_0 *ec2.DeleteManagedPrefixListOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteManagedPrefixListOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteManagedPrefixListInput) *ec2.DeleteManagedPrefixListOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteManagedPrefixListOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteManagedPrefixListInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteManagedPrefixListAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteManagedPrefixListAsync(ctx internal.Context, input *ec2.DeleteManagedPrefixListInput) (_result_0 *ec2stub.DeleteManagedPrefixListFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteManagedPrefixListFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteManagedPrefixListInput) *ec2stub.DeleteManagedPrefixListFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteManagedPrefixListFuture)
		}
	}

	return r0
}

// DeleteNatGateway provides a mock function.
func (_m *Mockec2clientstub) DeleteNatGateway(ctx internal.Context, input *ec2.DeleteNatGatewayInput) (_result_0 *ec2.DeleteNatGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteNatGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNatGatewayInput) *ec2.DeleteNatGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNatGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteNatGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNatGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteNatGatewayAsync(ctx internal.Context, input *ec2.DeleteNatGatewayInput) (_result_0 *ec2stub.DeleteNatGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteNatGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNatGatewayInput) *ec2stub.DeleteNatGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteNatGatewayFuture)
		}
	}

	return r0
}

// DeleteNetworkAcl provides a mock function.
func (_m *Mockec2clientstub) DeleteNetworkAcl(ctx internal.Context, input *ec2.DeleteNetworkAclInput) (_result_0 *ec2.DeleteNetworkAclOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteNetworkAclOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNetworkAclInput) *ec2.DeleteNetworkAclOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkAclOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteNetworkAclInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkAclAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteNetworkAclAsync(ctx internal.Context, input *ec2.DeleteNetworkAclInput) (_result_0 *ec2stub.DeleteNetworkAclFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteNetworkAclFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNetworkAclInput) *ec2stub.DeleteNetworkAclFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteNetworkAclFuture)
		}
	}

	return r0
}

// DeleteNetworkAclEntry provides a mock function.
func (_m *Mockec2clientstub) DeleteNetworkAclEntry(ctx internal.Context, input *ec2.DeleteNetworkAclEntryInput) (_result_0 *ec2.DeleteNetworkAclEntryOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteNetworkAclEntryOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNetworkAclEntryInput) *ec2.DeleteNetworkAclEntryOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkAclEntryOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteNetworkAclEntryInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkAclEntryAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteNetworkAclEntryAsync(ctx internal.Context, input *ec2.DeleteNetworkAclEntryInput) (_result_0 *ec2stub.DeleteNetworkAclEntryFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteNetworkAclEntryFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNetworkAclEntryInput) *ec2stub.DeleteNetworkAclEntryFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteNetworkAclEntryFuture)
		}
	}

	return r0
}

// DeleteNetworkInterface provides a mock function.
func (_m *Mockec2clientstub) DeleteNetworkInterface(ctx internal.Context, input *ec2.DeleteNetworkInterfaceInput) (_result_0 *ec2.DeleteNetworkInterfaceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteNetworkInterfaceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNetworkInterfaceInput) *ec2.DeleteNetworkInterfaceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInterfaceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteNetworkInterfaceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInterfaceAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteNetworkInterfaceAsync(ctx internal.Context, input *ec2.DeleteNetworkInterfaceInput) (_result_0 *ec2stub.DeleteNetworkInterfaceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteNetworkInterfaceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNetworkInterfaceInput) *ec2stub.DeleteNetworkInterfaceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteNetworkInterfaceFuture)
		}
	}

	return r0
}

// DeleteNetworkInterfacePermission provides a mock function.
func (_m *Mockec2clientstub) DeleteNetworkInterfacePermission(ctx internal.Context, input *ec2.DeleteNetworkInterfacePermissionInput) (_result_0 *ec2.DeleteNetworkInterfacePermissionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteNetworkInterfacePermissionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNetworkInterfacePermissionInput) *ec2.DeleteNetworkInterfacePermissionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInterfacePermissionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteNetworkInterfacePermissionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInterfacePermissionAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteNetworkInterfacePermissionAsync(ctx internal.Context, input *ec2.DeleteNetworkInterfacePermissionInput) (_result_0 *ec2stub.DeleteNetworkInterfacePermissionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteNetworkInterfacePermissionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteNetworkInterfacePermissionInput) *ec2stub.DeleteNetworkInterfacePermissionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteNetworkInterfacePermissionFuture)
		}
	}

	return r0
}

// DeletePlacementGroup provides a mock function.
func (_m *Mockec2clientstub) DeletePlacementGroup(ctx internal.Context, input *ec2.DeletePlacementGroupInput) (_result_0 *ec2.DeletePlacementGroupOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeletePlacementGroupOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeletePlacementGroupInput) *ec2.DeletePlacementGroupOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeletePlacementGroupOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeletePlacementGroupInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePlacementGroupAsync provides a mock function.
func (_m *Mockec2clientstub) DeletePlacementGroupAsync(ctx internal.Context, input *ec2.DeletePlacementGroupInput) (_result_0 *ec2stub.DeletePlacementGroupFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeletePlacementGroupFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeletePlacementGroupInput) *ec2stub.DeletePlacementGroupFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeletePlacementGroupFuture)
		}
	}

	return r0
}

// DeleteQueuedReservedInstances provides a mock function.
func (_m *Mockec2clientstub) DeleteQueuedReservedInstances(ctx internal.Context, input *ec2.DeleteQueuedReservedInstancesInput) (_result_0 *ec2.DeleteQueuedReservedInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteQueuedReservedInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteQueuedReservedInstancesInput) *ec2.DeleteQueuedReservedInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteQueuedReservedInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteQueuedReservedInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteQueuedReservedInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteQueuedReservedInstancesAsync(ctx internal.Context, input *ec2.DeleteQueuedReservedInstancesInput) (_result_0 *ec2stub.DeleteQueuedReservedInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteQueuedReservedInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteQueuedReservedInstancesInput) *ec2stub.DeleteQueuedReservedInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteQueuedReservedInstancesFuture)
		}
	}

	return r0
}

// DeleteRoute provides a mock function.
func (_m *Mockec2clientstub) DeleteRoute(ctx internal.Context, input *ec2.DeleteRouteInput) (_result_0 *ec2.DeleteRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteRouteInput) *ec2.DeleteRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRouteAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteRouteAsync(ctx internal.Context, input *ec2.DeleteRouteInput) (_result_0 *ec2stub.DeleteRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteRouteInput) *ec2stub.DeleteRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteRouteFuture)
		}
	}

	return r0
}

// DeleteRouteTable provides a mock function.
func (_m *Mockec2clientstub) DeleteRouteTable(ctx internal.Context, input *ec2.DeleteRouteTableInput) (_result_0 *ec2.DeleteRouteTableOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteRouteTableOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteRouteTableInput) *ec2.DeleteRouteTableOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteTableOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteRouteTableInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRouteTableAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteRouteTableAsync(ctx internal.Context, input *ec2.DeleteRouteTableInput) (_result_0 *ec2stub.DeleteRouteTableFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteRouteTableFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteRouteTableInput) *ec2stub.DeleteRouteTableFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteRouteTableFuture)
		}
	}

	return r0
}

// DeleteSecurityGroup provides a mock function.
func (_m *Mockec2clientstub) DeleteSecurityGroup(ctx internal.Context, input *ec2.DeleteSecurityGroupInput) (_result_0 *ec2.DeleteSecurityGroupOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteSecurityGroupOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteSecurityGroupInput) *ec2.DeleteSecurityGroupOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSecurityGroupOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteSecurityGroupInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSecurityGroupAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteSecurityGroupAsync(ctx internal.Context, input *ec2.DeleteSecurityGroupInput) (_result_0 *ec2stub.DeleteSecurityGroupFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteSecurityGroupFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteSecurityGroupInput) *ec2stub.DeleteSecurityGroupFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteSecurityGroupFuture)
		}
	}

	return r0
}

// DeleteSnapshot provides a mock function.
func (_m *Mockec2clientstub) DeleteSnapshot(ctx internal.Context, input *ec2.DeleteSnapshotInput) (_result_0 *ec2.DeleteSnapshotOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteSnapshotOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteSnapshotInput) *ec2.DeleteSnapshotOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSnapshotOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteSnapshotInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshotAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteSnapshotAsync(ctx internal.Context, input *ec2.DeleteSnapshotInput) (_result_0 *ec2stub.DeleteSnapshotFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteSnapshotFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteSnapshotInput) *ec2stub.DeleteSnapshotFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteSnapshotFuture)
		}
	}

	return r0
}

// DeleteSpotDatafeedSubscription provides a mock function.
func (_m *Mockec2clientstub) DeleteSpotDatafeedSubscription(ctx internal.Context, input *ec2.DeleteSpotDatafeedSubscriptionInput) (_result_0 *ec2.DeleteSpotDatafeedSubscriptionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteSpotDatafeedSubscriptionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteSpotDatafeedSubscriptionInput) *ec2.DeleteSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSpotDatafeedSubscriptionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteSpotDatafeedSubscriptionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSpotDatafeedSubscriptionAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteSpotDatafeedSubscriptionAsync(ctx internal.Context, input *ec2.DeleteSpotDatafeedSubscriptionInput) (_result_0 *ec2stub.DeleteSpotDatafeedSubscriptionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteSpotDatafeedSubscriptionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteSpotDatafeedSubscriptionInput) *ec2stub.DeleteSpotDatafeedSubscriptionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteSpotDatafeedSubscriptionFuture)
		}
	}

	return r0
}

// DeleteSubnet provides a mock function.
func (_m *Mockec2clientstub) DeleteSubnet(ctx internal.Context, input *ec2.DeleteSubnetInput) (_result_0 *ec2.DeleteSubnetOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteSubnetOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteSubnetInput) *ec2.DeleteSubnetOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSubnetOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteSubnetInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnetAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteSubnetAsync(ctx internal.Context, input *ec2.DeleteSubnetInput) (_result_0 *ec2stub.DeleteSubnetFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteSubnetFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteSubnetInput) *ec2stub.DeleteSubnetFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteSubnetFuture)
		}
	}

	return r0
}

// DeleteTags provides a mock function.
func (_m *Mockec2clientstub) DeleteTags(ctx internal.Context, input *ec2.DeleteTagsInput) (_result_0 *ec2.DeleteTagsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTagsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTagsInput) *ec2.DeleteTagsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTagsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTagsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTagsAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTagsAsync(ctx internal.Context, input *ec2.DeleteTagsInput) (_result_0 *ec2stub.DeleteTagsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTagsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTagsInput) *ec2stub.DeleteTagsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTagsFuture)
		}
	}

	return r0
}

// DeleteTrafficMirrorFilter provides a mock function.
func (_m *Mockec2clientstub) DeleteTrafficMirrorFilter(ctx internal.Context, input *ec2.DeleteTrafficMirrorFilterInput) (_result_0 *ec2.DeleteTrafficMirrorFilterOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTrafficMirrorFilterOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTrafficMirrorFilterInput) *ec2.DeleteTrafficMirrorFilterOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorFilterOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTrafficMirrorFilterInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorFilterAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTrafficMirrorFilterAsync(ctx internal.Context, input *ec2.DeleteTrafficMirrorFilterInput) (_result_0 *ec2stub.DeleteTrafficMirrorFilterFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTrafficMirrorFilterFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTrafficMirrorFilterInput) *ec2stub.DeleteTrafficMirrorFilterFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTrafficMirrorFilterFuture)
		}
	}

	return r0
}

// DeleteTrafficMirrorFilterRule provides a mock function.
func (_m *Mockec2clientstub) DeleteTrafficMirrorFilterRule(ctx internal.Context, input *ec2.DeleteTrafficMirrorFilterRuleInput) (_result_0 *ec2.DeleteTrafficMirrorFilterRuleOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTrafficMirrorFilterRuleOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTrafficMirrorFilterRuleInput) *ec2.DeleteTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorFilterRuleOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTrafficMirrorFilterRuleInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorFilterRuleAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTrafficMirrorFilterRuleAsync(ctx internal.Context, input *ec2.DeleteTrafficMirrorFilterRuleInput) (_result_0 *ec2stub.DeleteTrafficMirrorFilterRuleFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTrafficMirrorFilterRuleFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTrafficMirrorFilterRuleInput) *ec2stub.DeleteTrafficMirrorFilterRuleFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTrafficMirrorFilterRuleFuture)
		}
	}

	return r0
}

// DeleteTrafficMirrorSession provides a mock function.
func (_m *Mockec2clientstub) DeleteTrafficMirrorSession(ctx internal.Context, input *ec2.DeleteTrafficMirrorSessionInput) (_result_0 *ec2.DeleteTrafficMirrorSessionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTrafficMirrorSessionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTrafficMirrorSessionInput) *ec2.DeleteTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorSessionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTrafficMirrorSessionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorSessionAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTrafficMirrorSessionAsync(ctx internal.Context, input *ec2.DeleteTrafficMirrorSessionInput) (_result_0 *ec2stub.DeleteTrafficMirrorSessionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTrafficMirrorSessionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTrafficMirrorSessionInput) *ec2stub.DeleteTrafficMirrorSessionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTrafficMirrorSessionFuture)
		}
	}

	return r0
}

// DeleteTrafficMirrorTarget provides a mock function.
func (_m *Mockec2clientstub) DeleteTrafficMirrorTarget(ctx internal.Context, input *ec2.DeleteTrafficMirrorTargetInput) (_result_0 *ec2.DeleteTrafficMirrorTargetOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTrafficMirrorTargetOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTrafficMirrorTargetInput) *ec2.DeleteTrafficMirrorTargetOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorTargetOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTrafficMirrorTargetInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorTargetAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTrafficMirrorTargetAsync(ctx internal.Context, input *ec2.DeleteTrafficMirrorTargetInput) (_result_0 *ec2stub.DeleteTrafficMirrorTargetFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTrafficMirrorTargetFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTrafficMirrorTargetInput) *ec2stub.DeleteTrafficMirrorTargetFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTrafficMirrorTargetFuture)
		}
	}

	return r0
}

// DeleteTransitGateway provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGateway(ctx internal.Context, input *ec2.DeleteTransitGatewayInput) (_result_0 *ec2.DeleteTransitGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTransitGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayInput) *ec2.DeleteTransitGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTransitGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayAsync(ctx internal.Context, input *ec2.DeleteTransitGatewayInput) (_result_0 *ec2stub.DeleteTransitGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTransitGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayInput) *ec2stub.DeleteTransitGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTransitGatewayFuture)
		}
	}

	return r0
}

// DeleteTransitGatewayMulticastDomain provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayMulticastDomain(ctx internal.Context, input *ec2.DeleteTransitGatewayMulticastDomainInput) (_result_0 *ec2.DeleteTransitGatewayMulticastDomainOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTransitGatewayMulticastDomainOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayMulticastDomainInput) *ec2.DeleteTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayMulticastDomainOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTransitGatewayMulticastDomainInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayMulticastDomainAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayMulticastDomainAsync(ctx internal.Context, input *ec2.DeleteTransitGatewayMulticastDomainInput) (_result_0 *ec2stub.DeleteTransitGatewayMulticastDomainFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTransitGatewayMulticastDomainFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayMulticastDomainInput) *ec2stub.DeleteTransitGatewayMulticastDomainFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTransitGatewayMulticastDomainFuture)
		}
	}

	return r0
}

// DeleteTransitGatewayPeeringAttachment provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayPeeringAttachment(ctx internal.Context, input *ec2.DeleteTransitGatewayPeeringAttachmentInput) (_result_0 *ec2.DeleteTransitGatewayPeeringAttachmentOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTransitGatewayPeeringAttachmentOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput) *ec2.DeleteTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayPeeringAttachmentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayPeeringAttachmentAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayPeeringAttachmentAsync(ctx internal.Context, input *ec2.DeleteTransitGatewayPeeringAttachmentInput) (_result_0 *ec2stub.DeleteTransitGatewayPeeringAttachmentFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTransitGatewayPeeringAttachmentFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput) *ec2stub.DeleteTransitGatewayPeeringAttachmentFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTransitGatewayPeeringAttachmentFuture)
		}
	}

	return r0
}

// DeleteTransitGatewayPrefixListReference provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayPrefixListReference(ctx internal.Context, input *ec2.DeleteTransitGatewayPrefixListReferenceInput) (_result_0 *ec2.DeleteTransitGatewayPrefixListReferenceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTransitGatewayPrefixListReferenceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput) *ec2.DeleteTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayPrefixListReferenceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayPrefixListReferenceAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayPrefixListReferenceAsync(ctx internal.Context, input *ec2.DeleteTransitGatewayPrefixListReferenceInput) (_result_0 *ec2stub.DeleteTransitGatewayPrefixListReferenceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTransitGatewayPrefixListReferenceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput) *ec2stub.DeleteTransitGatewayPrefixListReferenceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTransitGatewayPrefixListReferenceFuture)
		}
	}

	return r0
}

// DeleteTransitGatewayRoute provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayRoute(ctx internal.Context, input *ec2.DeleteTransitGatewayRouteInput) (_result_0 *ec2.DeleteTransitGatewayRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTransitGatewayRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayRouteInput) *ec2.DeleteTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTransitGatewayRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayRouteAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayRouteAsync(ctx internal.Context, input *ec2.DeleteTransitGatewayRouteInput) (_result_0 *ec2stub.DeleteTransitGatewayRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTransitGatewayRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayRouteInput) *ec2stub.DeleteTransitGatewayRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTransitGatewayRouteFuture)
		}
	}

	return r0
}

// DeleteTransitGatewayRouteTable provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayRouteTable(ctx internal.Context, input *ec2.DeleteTransitGatewayRouteTableInput) (_result_0 *ec2.DeleteTransitGatewayRouteTableOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTransitGatewayRouteTableOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayRouteTableInput) *ec2.DeleteTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayRouteTableOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTransitGatewayRouteTableInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayRouteTableAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayRouteTableAsync(ctx internal.Context, input *ec2.DeleteTransitGatewayRouteTableInput) (_result_0 *ec2stub.DeleteTransitGatewayRouteTableFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTransitGatewayRouteTableFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayRouteTableInput) *ec2stub.DeleteTransitGatewayRouteTableFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTransitGatewayRouteTableFuture)
		}
	}

	return r0
}

// DeleteTransitGatewayVpcAttachment provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayVpcAttachment(ctx internal.Context, input *ec2.DeleteTransitGatewayVpcAttachmentInput) (_result_0 *ec2.DeleteTransitGatewayVpcAttachmentOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteTransitGatewayVpcAttachmentOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput) *ec2.DeleteTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayVpcAttachmentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayVpcAttachmentAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteTransitGatewayVpcAttachmentAsync(ctx internal.Context, input *ec2.DeleteTransitGatewayVpcAttachmentInput) (_result_0 *ec2stub.DeleteTransitGatewayVpcAttachmentFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteTransitGatewayVpcAttachmentFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput) *ec2stub.DeleteTransitGatewayVpcAttachmentFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteTransitGatewayVpcAttachmentFuture)
		}
	}

	return r0
}

// DeleteVolume provides a mock function.
func (_m *Mockec2clientstub) DeleteVolume(ctx internal.Context, input *ec2.DeleteVolumeInput) (_result_0 *ec2.DeleteVolumeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteVolumeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVolumeInput) *ec2.DeleteVolumeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVolumeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteVolumeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVolumeAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteVolumeAsync(ctx internal.Context, input *ec2.DeleteVolumeInput) (_result_0 *ec2stub.DeleteVolumeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteVolumeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVolumeInput) *ec2stub.DeleteVolumeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteVolumeFuture)
		}
	}

	return r0
}

// DeleteVpc provides a mock function.
func (_m *Mockec2clientstub) DeleteVpc(ctx internal.Context, input *ec2.DeleteVpcInput) (_result_0 *ec2.DeleteVpcOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteVpcOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcInput) *ec2.DeleteVpcOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteVpcInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteVpcAsync(ctx internal.Context, input *ec2.DeleteVpcInput) (_result_0 *ec2stub.DeleteVpcFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteVpcFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcInput) *ec2stub.DeleteVpcFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteVpcFuture)
		}
	}

	return r0
}

// DeleteVpcEndpointConnectionNotifications provides a mock function.
func (_m *Mockec2clientstub) DeleteVpcEndpointConnectionNotifications(ctx internal.Context, input *ec2.DeleteVpcEndpointConnectionNotificationsInput) (_result_0 *ec2.DeleteVpcEndpointConnectionNotificationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteVpcEndpointConnectionNotificationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput) *ec2.DeleteVpcEndpointConnectionNotificationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointConnectionNotificationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpointConnectionNotificationsAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteVpcEndpointConnectionNotificationsAsync(ctx internal.Context, input *ec2.DeleteVpcEndpointConnectionNotificationsInput) (_result_0 *ec2stub.DeleteVpcEndpointConnectionNotificationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteVpcEndpointConnectionNotificationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput) *ec2stub.DeleteVpcEndpointConnectionNotificationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteVpcEndpointConnectionNotificationsFuture)
		}
	}

	return r0
}

// DeleteVpcEndpointServiceConfigurations provides a mock function.
func (_m *Mockec2clientstub) DeleteVpcEndpointServiceConfigurations(ctx internal.Context, input *ec2.DeleteVpcEndpointServiceConfigurationsInput) (_result_0 *ec2.DeleteVpcEndpointServiceConfigurationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteVpcEndpointServiceConfigurationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput) *ec2.DeleteVpcEndpointServiceConfigurationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointServiceConfigurationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpointServiceConfigurationsAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteVpcEndpointServiceConfigurationsAsync(ctx internal.Context, input *ec2.DeleteVpcEndpointServiceConfigurationsInput) (_result_0 *ec2stub.DeleteVpcEndpointServiceConfigurationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteVpcEndpointServiceConfigurationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput) *ec2stub.DeleteVpcEndpointServiceConfigurationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteVpcEndpointServiceConfigurationsFuture)
		}
	}

	return r0
}

// DeleteVpcEndpoints provides a mock function.
func (_m *Mockec2clientstub) DeleteVpcEndpoints(ctx internal.Context, input *ec2.DeleteVpcEndpointsInput) (_result_0 *ec2.DeleteVpcEndpointsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteVpcEndpointsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcEndpointsInput) *ec2.DeleteVpcEndpointsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteVpcEndpointsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpointsAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteVpcEndpointsAsync(ctx internal.Context, input *ec2.DeleteVpcEndpointsInput) (_result_0 *ec2stub.DeleteVpcEndpointsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteVpcEndpointsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcEndpointsInput) *ec2stub.DeleteVpcEndpointsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteVpcEndpointsFuture)
		}
	}

	return r0
}

// DeleteVpcPeeringConnection provides a mock function.
func (_m *Mockec2clientstub) DeleteVpcPeeringConnection(ctx internal.Context, input *ec2.DeleteVpcPeeringConnectionInput) (_result_0 *ec2.DeleteVpcPeeringConnectionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteVpcPeeringConnectionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcPeeringConnectionInput) *ec2.DeleteVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcPeeringConnectionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteVpcPeeringConnectionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcPeeringConnectionAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteVpcPeeringConnectionAsync(ctx internal.Context, input *ec2.DeleteVpcPeeringConnectionInput) (_result_0 *ec2stub.DeleteVpcPeeringConnectionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteVpcPeeringConnectionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpcPeeringConnectionInput) *ec2stub.DeleteVpcPeeringConnectionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteVpcPeeringConnectionFuture)
		}
	}

	return r0
}

// DeleteVpnConnection provides a mock function.
func (_m *Mockec2clientstub) DeleteVpnConnection(ctx internal.Context, input *ec2.DeleteVpnConnectionInput) (_result_0 *ec2.DeleteVpnConnectionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteVpnConnectionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpnConnectionInput) *ec2.DeleteVpnConnectionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnConnectionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteVpnConnectionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnConnectionAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteVpnConnectionAsync(ctx internal.Context, input *ec2.DeleteVpnConnectionInput) (_result_0 *ec2stub.DeleteVpnConnectionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteVpnConnectionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpnConnectionInput) *ec2stub.DeleteVpnConnectionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteVpnConnectionFuture)
		}
	}

	return r0
}

// DeleteVpnConnectionRoute provides a mock function.
func (_m *Mockec2clientstub) DeleteVpnConnectionRoute(ctx internal.Context, input *ec2.DeleteVpnConnectionRouteInput) (_result_0 *ec2.DeleteVpnConnectionRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteVpnConnectionRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpnConnectionRouteInput) *ec2.DeleteVpnConnectionRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnConnectionRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteVpnConnectionRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnConnectionRouteAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteVpnConnectionRouteAsync(ctx internal.Context, input *ec2.DeleteVpnConnectionRouteInput) (_result_0 *ec2stub.DeleteVpnConnectionRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteVpnConnectionRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpnConnectionRouteInput) *ec2stub.DeleteVpnConnectionRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteVpnConnectionRouteFuture)
		}
	}

	return r0
}

// DeleteVpnGateway provides a mock function.
func (_m *Mockec2clientstub) DeleteVpnGateway(ctx internal.Context, input *ec2.DeleteVpnGatewayInput) (_result_0 *ec2.DeleteVpnGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeleteVpnGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpnGatewayInput) *ec2.DeleteVpnGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeleteVpnGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) DeleteVpnGatewayAsync(ctx internal.Context, input *ec2.DeleteVpnGatewayInput) (_result_0 *ec2stub.DeleteVpnGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeleteVpnGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeleteVpnGatewayInput) *ec2stub.DeleteVpnGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeleteVpnGatewayFuture)
		}
	}

	return r0
}

// DeprovisionByoipCidr provides a mock function.
func (_m *Mockec2clientstub) DeprovisionByoipCidr(ctx internal.Context, input *ec2.DeprovisionByoipCidrInput) (_result_0 *ec2.DeprovisionByoipCidrOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeprovisionByoipCidrOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeprovisionByoipCidrInput) *ec2.DeprovisionByoipCidrOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionByoipCidrOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeprovisionByoipCidrInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprovisionByoipCidrAsync provides a mock function.
func (_m *Mockec2clientstub) DeprovisionByoipCidrAsync(ctx internal.Context, input *ec2.DeprovisionByoipCidrInput) (_result_0 *ec2stub.DeprovisionByoipCidrFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeprovisionByoipCidrFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeprovisionByoipCidrInput) *ec2stub.DeprovisionByoipCidrFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeprovisionByoipCidrFuture)
		}
	}

	return r0
}

// DeregisterImage provides a mock function.
func (_m *Mockec2clientstub) DeregisterImage(ctx internal.Context, input *ec2.DeregisterImageInput) (_result_0 *ec2.DeregisterImageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeregisterImageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeregisterImageInput) *ec2.DeregisterImageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterImageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeregisterImageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterImageAsync provides a mock function.
func (_m *Mockec2clientstub) DeregisterImageAsync(ctx internal.Context, input *ec2.DeregisterImageInput) (_result_0 *ec2stub.DeregisterImageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeregisterImageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeregisterImageInput) *ec2stub.DeregisterImageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeregisterImageFuture)
		}
	}

	return r0
}

// DeregisterInstanceEventNotificationAttributes provides a mock function.
func (_m *Mockec2clientstub) DeregisterInstanceEventNotificationAttributes(ctx internal.Context, input *ec2.DeregisterInstanceEventNotificationAttributesInput) (_result_0 *ec2.DeregisterInstanceEventNotificationAttributesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeregisterInstanceEventNotificationAttributesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput) *ec2.DeregisterInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterInstanceEventNotificationAttributesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterInstanceEventNotificationAttributesAsync provides a mock function.
func (_m *Mockec2clientstub) DeregisterInstanceEventNotificationAttributesAsync(ctx internal.Context, input *ec2.DeregisterInstanceEventNotificationAttributesInput) (_result_0 *ec2stub.DeregisterInstanceEventNotificationAttributesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeregisterInstanceEventNotificationAttributesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput) *ec2stub.DeregisterInstanceEventNotificationAttributesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeregisterInstanceEventNotificationAttributesFuture)
		}
	}

	return r0
}

// DeregisterTransitGatewayMulticastGroupMembers provides a mock function.
func (_m *Mockec2clientstub) DeregisterTransitGatewayMulticastGroupMembers(ctx internal.Context, input *ec2.DeregisterTransitGatewayMulticastGroupMembersInput) (_result_0 *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput) *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterTransitGatewayMulticastGroupMembersAsync provides a mock function.
func (_m *Mockec2clientstub) DeregisterTransitGatewayMulticastGroupMembersAsync(ctx internal.Context, input *ec2.DeregisterTransitGatewayMulticastGroupMembersInput) (_result_0 *ec2stub.DeregisterTransitGatewayMulticastGroupMembersFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeregisterTransitGatewayMulticastGroupMembersFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput) *ec2stub.DeregisterTransitGatewayMulticastGroupMembersFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeregisterTransitGatewayMulticastGroupMembersFuture)
		}
	}

	return r0
}

// DeregisterTransitGatewayMulticastGroupSources provides a mock function.
func (_m *Mockec2clientstub) DeregisterTransitGatewayMulticastGroupSources(ctx internal.Context, input *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput) (_result_0 *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput) *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterTransitGatewayMulticastGroupSourcesAsync provides a mock function.
func (_m *Mockec2clientstub) DeregisterTransitGatewayMulticastGroupSourcesAsync(ctx internal.Context, input *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput) (_result_0 *ec2stub.DeregisterTransitGatewayMulticastGroupSourcesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DeregisterTransitGatewayMulticastGroupSourcesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput) *ec2stub.DeregisterTransitGatewayMulticastGroupSourcesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DeregisterTransitGatewayMulticastGroupSourcesFuture)
		}
	}

	return r0
}

// DescribeAccountAttributes provides a mock function.
func (_m *Mockec2clientstub) DescribeAccountAttributes(ctx internal.Context, input *ec2.DescribeAccountAttributesInput) (_result_0 *ec2.DescribeAccountAttributesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeAccountAttributesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeAccountAttributesInput) *ec2.DescribeAccountAttributesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAccountAttributesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeAccountAttributesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccountAttributesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeAccountAttributesAsync(ctx internal.Context, input *ec2.DescribeAccountAttributesInput) (_result_0 *ec2stub.DescribeAccountAttributesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeAccountAttributesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeAccountAttributesInput) *ec2stub.DescribeAccountAttributesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeAccountAttributesFuture)
		}
	}

	return r0
}

// DescribeAddresses provides a mock function.
func (_m *Mockec2clientstub) DescribeAddresses(ctx internal.Context, input *ec2.DescribeAddressesInput) (_result_0 *ec2.DescribeAddressesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeAddressesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeAddressesInput) *ec2.DescribeAddressesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAddressesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeAddressesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddressesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeAddressesAsync(ctx internal.Context, input *ec2.DescribeAddressesInput) (_result_0 *ec2stub.DescribeAddressesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeAddressesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeAddressesInput) *ec2stub.DescribeAddressesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeAddressesFuture)
		}
	}

	return r0
}

// DescribeAggregateIdFormat provides a mock function.
func (_m *Mockec2clientstub) DescribeAggregateIdFormat(ctx internal.Context, input *ec2.DescribeAggregateIdFormatInput) (_result_0 *ec2.DescribeAggregateIdFormatOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeAggregateIdFormatOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeAggregateIdFormatInput) *ec2.DescribeAggregateIdFormatOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAggregateIdFormatOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeAggregateIdFormatInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAggregateIdFormatAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeAggregateIdFormatAsync(ctx internal.Context, input *ec2.DescribeAggregateIdFormatInput) (_result_0 *ec2stub.DescribeAggregateIdFormatFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeAggregateIdFormatFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeAggregateIdFormatInput) *ec2stub.DescribeAggregateIdFormatFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeAggregateIdFormatFuture)
		}
	}

	return r0
}

// DescribeAvailabilityZones provides a mock function.
func (_m *Mockec2clientstub) DescribeAvailabilityZones(ctx internal.Context, input *ec2.DescribeAvailabilityZonesInput) (_result_0 *ec2.DescribeAvailabilityZonesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeAvailabilityZonesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeAvailabilityZonesInput) *ec2.DescribeAvailabilityZonesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAvailabilityZonesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeAvailabilityZonesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAvailabilityZonesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeAvailabilityZonesAsync(ctx internal.Context, input *ec2.DescribeAvailabilityZonesInput) (_result_0 *ec2stub.DescribeAvailabilityZonesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeAvailabilityZonesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeAvailabilityZonesInput) *ec2stub.DescribeAvailabilityZonesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeAvailabilityZonesFuture)
		}
	}

	return r0
}

// DescribeBundleTasks provides a mock function.
func (_m *Mockec2clientstub) DescribeBundleTasks(ctx internal.Context, input *ec2.DescribeBundleTasksInput) (_result_0 *ec2.DescribeBundleTasksOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeBundleTasksOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeBundleTasksInput) *ec2.DescribeBundleTasksOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeBundleTasksOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeBundleTasksInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBundleTasksAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeBundleTasksAsync(ctx internal.Context, input *ec2.DescribeBundleTasksInput) (_result_0 *ec2stub.DescribeBundleTasksFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeBundleTasksFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeBundleTasksInput) *ec2stub.DescribeBundleTasksFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeBundleTasksFuture)
		}
	}

	return r0
}

// DescribeByoipCidrs provides a mock function.
func (_m *Mockec2clientstub) DescribeByoipCidrs(ctx internal.Context, input *ec2.DescribeByoipCidrsInput) (_result_0 *ec2.DescribeByoipCidrsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeByoipCidrsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeByoipCidrsInput) *ec2.DescribeByoipCidrsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeByoipCidrsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeByoipCidrsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeByoipCidrsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeByoipCidrsAsync(ctx internal.Context, input *ec2.DescribeByoipCidrsInput) (_result_0 *ec2stub.DescribeByoipCidrsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeByoipCidrsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeByoipCidrsInput) *ec2stub.DescribeByoipCidrsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeByoipCidrsFuture)
		}
	}

	return r0
}

// DescribeCapacityReservations provides a mock function.
func (_m *Mockec2clientstub) DescribeCapacityReservations(ctx internal.Context, input *ec2.DescribeCapacityReservationsInput) (_result_0 *ec2.DescribeCapacityReservationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeCapacityReservationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCapacityReservationsInput) *ec2.DescribeCapacityReservationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityReservationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeCapacityReservationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityReservationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeCapacityReservationsAsync(ctx internal.Context, input *ec2.DescribeCapacityReservationsInput) (_result_0 *ec2stub.DescribeCapacityReservationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeCapacityReservationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCapacityReservationsInput) *ec2stub.DescribeCapacityReservationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeCapacityReservationsFuture)
		}
	}

	return r0
}

// DescribeCarrierGateways provides a mock function.
func (_m *Mockec2clientstub) DescribeCarrierGateways(ctx internal.Context, input *ec2.DescribeCarrierGatewaysInput) (_result_0 *ec2.DescribeCarrierGatewaysOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeCarrierGatewaysOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCarrierGatewaysInput) *ec2.DescribeCarrierGatewaysOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCarrierGatewaysOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeCarrierGatewaysInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCarrierGatewaysAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeCarrierGatewaysAsync(ctx internal.Context, input *ec2.DescribeCarrierGatewaysInput) (_result_0 *ec2stub.DescribeCarrierGatewaysFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeCarrierGatewaysFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCarrierGatewaysInput) *ec2stub.DescribeCarrierGatewaysFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeCarrierGatewaysFuture)
		}
	}

	return r0
}

// DescribeClassicLinkInstances provides a mock function.
func (_m *Mockec2clientstub) DescribeClassicLinkInstances(ctx internal.Context, input *ec2.DescribeClassicLinkInstancesInput) (_result_0 *ec2.DescribeClassicLinkInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeClassicLinkInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClassicLinkInstancesInput) *ec2.DescribeClassicLinkInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClassicLinkInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeClassicLinkInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClassicLinkInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeClassicLinkInstancesAsync(ctx internal.Context, input *ec2.DescribeClassicLinkInstancesInput) (_result_0 *ec2stub.DescribeClassicLinkInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeClassicLinkInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClassicLinkInstancesInput) *ec2stub.DescribeClassicLinkInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeClassicLinkInstancesFuture)
		}
	}

	return r0
}

// DescribeClientVpnAuthorizationRules provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnAuthorizationRules(ctx internal.Context, input *ec2.DescribeClientVpnAuthorizationRulesInput) (_result_0 *ec2.DescribeClientVpnAuthorizationRulesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeClientVpnAuthorizationRulesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnAuthorizationRulesInput) *ec2.DescribeClientVpnAuthorizationRulesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnAuthorizationRulesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeClientVpnAuthorizationRulesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnAuthorizationRulesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnAuthorizationRulesAsync(ctx internal.Context, input *ec2.DescribeClientVpnAuthorizationRulesInput) (_result_0 *ec2stub.DescribeClientVpnAuthorizationRulesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeClientVpnAuthorizationRulesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnAuthorizationRulesInput) *ec2stub.DescribeClientVpnAuthorizationRulesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeClientVpnAuthorizationRulesFuture)
		}
	}

	return r0
}

// DescribeClientVpnConnections provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnConnections(ctx internal.Context, input *ec2.DescribeClientVpnConnectionsInput) (_result_0 *ec2.DescribeClientVpnConnectionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeClientVpnConnectionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnConnectionsInput) *ec2.DescribeClientVpnConnectionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnConnectionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeClientVpnConnectionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnConnectionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnConnectionsAsync(ctx internal.Context, input *ec2.DescribeClientVpnConnectionsInput) (_result_0 *ec2stub.DescribeClientVpnConnectionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeClientVpnConnectionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnConnectionsInput) *ec2stub.DescribeClientVpnConnectionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeClientVpnConnectionsFuture)
		}
	}

	return r0
}

// DescribeClientVpnEndpoints provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnEndpoints(ctx internal.Context, input *ec2.DescribeClientVpnEndpointsInput) (_result_0 *ec2.DescribeClientVpnEndpointsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeClientVpnEndpointsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnEndpointsInput) *ec2.DescribeClientVpnEndpointsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnEndpointsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeClientVpnEndpointsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnEndpointsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnEndpointsAsync(ctx internal.Context, input *ec2.DescribeClientVpnEndpointsInput) (_result_0 *ec2stub.DescribeClientVpnEndpointsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeClientVpnEndpointsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnEndpointsInput) *ec2stub.DescribeClientVpnEndpointsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeClientVpnEndpointsFuture)
		}
	}

	return r0
}

// DescribeClientVpnRoutes provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnRoutes(ctx internal.Context, input *ec2.DescribeClientVpnRoutesInput) (_result_0 *ec2.DescribeClientVpnRoutesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeClientVpnRoutesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnRoutesInput) *ec2.DescribeClientVpnRoutesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnRoutesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeClientVpnRoutesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnRoutesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnRoutesAsync(ctx internal.Context, input *ec2.DescribeClientVpnRoutesInput) (_result_0 *ec2stub.DescribeClientVpnRoutesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeClientVpnRoutesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnRoutesInput) *ec2stub.DescribeClientVpnRoutesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeClientVpnRoutesFuture)
		}
	}

	return r0
}

// DescribeClientVpnTargetNetworks provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnTargetNetworks(ctx internal.Context, input *ec2.DescribeClientVpnTargetNetworksInput) (_result_0 *ec2.DescribeClientVpnTargetNetworksOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeClientVpnTargetNetworksOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnTargetNetworksInput) *ec2.DescribeClientVpnTargetNetworksOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnTargetNetworksOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeClientVpnTargetNetworksInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnTargetNetworksAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeClientVpnTargetNetworksAsync(ctx internal.Context, input *ec2.DescribeClientVpnTargetNetworksInput) (_result_0 *ec2stub.DescribeClientVpnTargetNetworksFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeClientVpnTargetNetworksFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeClientVpnTargetNetworksInput) *ec2stub.DescribeClientVpnTargetNetworksFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeClientVpnTargetNetworksFuture)
		}
	}

	return r0
}

// DescribeCoipPools provides a mock function.
func (_m *Mockec2clientstub) DescribeCoipPools(ctx internal.Context, input *ec2.DescribeCoipPoolsInput) (_result_0 *ec2.DescribeCoipPoolsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeCoipPoolsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCoipPoolsInput) *ec2.DescribeCoipPoolsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCoipPoolsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeCoipPoolsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCoipPoolsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeCoipPoolsAsync(ctx internal.Context, input *ec2.DescribeCoipPoolsInput) (_result_0 *ec2stub.DescribeCoipPoolsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeCoipPoolsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCoipPoolsInput) *ec2stub.DescribeCoipPoolsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeCoipPoolsFuture)
		}
	}

	return r0
}

// DescribeConversionTasks provides a mock function.
func (_m *Mockec2clientstub) DescribeConversionTasks(ctx internal.Context, input *ec2.DescribeConversionTasksInput) (_result_0 *ec2.DescribeConversionTasksOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeConversionTasksOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeConversionTasksInput) *ec2.DescribeConversionTasksOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeConversionTasksOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeConversionTasksInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConversionTasksAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeConversionTasksAsync(ctx internal.Context, input *ec2.DescribeConversionTasksInput) (_result_0 *ec2stub.DescribeConversionTasksFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeConversionTasksFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeConversionTasksInput) *ec2stub.DescribeConversionTasksFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeConversionTasksFuture)
		}
	}

	return r0
}

// DescribeCustomerGateways provides a mock function.
func (_m *Mockec2clientstub) DescribeCustomerGateways(ctx internal.Context, input *ec2.DescribeCustomerGatewaysInput) (_result_0 *ec2.DescribeCustomerGatewaysOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeCustomerGatewaysOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCustomerGatewaysInput) *ec2.DescribeCustomerGatewaysOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCustomerGatewaysOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeCustomerGatewaysInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomerGatewaysAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeCustomerGatewaysAsync(ctx internal.Context, input *ec2.DescribeCustomerGatewaysInput) (_result_0 *ec2stub.DescribeCustomerGatewaysFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeCustomerGatewaysFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCustomerGatewaysInput) *ec2stub.DescribeCustomerGatewaysFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeCustomerGatewaysFuture)
		}
	}

	return r0
}

// DescribeDhcpOptions provides a mock function.
func (_m *Mockec2clientstub) DescribeDhcpOptions(ctx internal.Context, input *ec2.DescribeDhcpOptionsInput) (_result_0 *ec2.DescribeDhcpOptionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeDhcpOptionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeDhcpOptionsInput) *ec2.DescribeDhcpOptionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeDhcpOptionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeDhcpOptionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDhcpOptionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeDhcpOptionsAsync(ctx internal.Context, input *ec2.DescribeDhcpOptionsInput) (_result_0 *ec2stub.DescribeDhcpOptionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeDhcpOptionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeDhcpOptionsInput) *ec2stub.DescribeDhcpOptionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeDhcpOptionsFuture)
		}
	}

	return r0
}

// DescribeEgressOnlyInternetGateways provides a mock function.
func (_m *Mockec2clientstub) DescribeEgressOnlyInternetGateways(ctx internal.Context, input *ec2.DescribeEgressOnlyInternetGatewaysInput) (_result_0 *ec2.DescribeEgressOnlyInternetGatewaysOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeEgressOnlyInternetGatewaysOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput) *ec2.DescribeEgressOnlyInternetGatewaysOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeEgressOnlyInternetGatewaysOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEgressOnlyInternetGatewaysAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeEgressOnlyInternetGatewaysAsync(ctx internal.Context, input *ec2.DescribeEgressOnlyInternetGatewaysInput) (_result_0 *ec2stub.DescribeEgressOnlyInternetGatewaysFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeEgressOnlyInternetGatewaysFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput) *ec2stub.DescribeEgressOnlyInternetGatewaysFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeEgressOnlyInternetGatewaysFuture)
		}
	}

	return r0
}

// DescribeElasticGpus provides a mock function.
func (_m *Mockec2clientstub) DescribeElasticGpus(ctx internal.Context, input *ec2.DescribeElasticGpusInput) (_result_0 *ec2.DescribeElasticGpusOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeElasticGpusOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeElasticGpusInput) *ec2.DescribeElasticGpusOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeElasticGpusOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeElasticGpusInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeElasticGpusAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeElasticGpusAsync(ctx internal.Context, input *ec2.DescribeElasticGpusInput) (_result_0 *ec2stub.DescribeElasticGpusFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeElasticGpusFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeElasticGpusInput) *ec2stub.DescribeElasticGpusFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeElasticGpusFuture)
		}
	}

	return r0
}

// DescribeExportImageTasks provides a mock function.
func (_m *Mockec2clientstub) DescribeExportImageTasks(ctx internal.Context, input *ec2.DescribeExportImageTasksInput) (_result_0 *ec2.DescribeExportImageTasksOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeExportImageTasksOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeExportImageTasksInput) *ec2.DescribeExportImageTasksOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeExportImageTasksOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeExportImageTasksInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExportImageTasksAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeExportImageTasksAsync(ctx internal.Context, input *ec2.DescribeExportImageTasksInput) (_result_0 *ec2stub.DescribeExportImageTasksFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeExportImageTasksFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeExportImageTasksInput) *ec2stub.DescribeExportImageTasksFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeExportImageTasksFuture)
		}
	}

	return r0
}

// DescribeExportTasks provides a mock function.
func (_m *Mockec2clientstub) DescribeExportTasks(ctx internal.Context, input *ec2.DescribeExportTasksInput) (_result_0 *ec2.DescribeExportTasksOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeExportTasksOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeExportTasksInput) *ec2.DescribeExportTasksOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeExportTasksOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeExportTasksInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExportTasksAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeExportTasksAsync(ctx internal.Context, input *ec2.DescribeExportTasksInput) (_result_0 *ec2stub.DescribeExportTasksFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeExportTasksFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeExportTasksInput) *ec2stub.DescribeExportTasksFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeExportTasksFuture)
		}
	}

	return r0
}

// DescribeFastSnapshotRestores provides a mock function.
func (_m *Mockec2clientstub) DescribeFastSnapshotRestores(ctx internal.Context, input *ec2.DescribeFastSnapshotRestoresInput) (_result_0 *ec2.DescribeFastSnapshotRestoresOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeFastSnapshotRestoresOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFastSnapshotRestoresInput) *ec2.DescribeFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFastSnapshotRestoresOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeFastSnapshotRestoresInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFastSnapshotRestoresAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeFastSnapshotRestoresAsync(ctx internal.Context, input *ec2.DescribeFastSnapshotRestoresInput) (_result_0 *ec2stub.DescribeFastSnapshotRestoresFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeFastSnapshotRestoresFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFastSnapshotRestoresInput) *ec2stub.DescribeFastSnapshotRestoresFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeFastSnapshotRestoresFuture)
		}
	}

	return r0
}

// DescribeFleetHistory provides a mock function.
func (_m *Mockec2clientstub) DescribeFleetHistory(ctx internal.Context, input *ec2.DescribeFleetHistoryInput) (_result_0 *ec2.DescribeFleetHistoryOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeFleetHistoryOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFleetHistoryInput) *ec2.DescribeFleetHistoryOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetHistoryOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeFleetHistoryInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetHistoryAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeFleetHistoryAsync(ctx internal.Context, input *ec2.DescribeFleetHistoryInput) (_result_0 *ec2stub.DescribeFleetHistoryFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeFleetHistoryFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFleetHistoryInput) *ec2stub.DescribeFleetHistoryFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeFleetHistoryFuture)
		}
	}

	return r0
}

// DescribeFleetInstances provides a mock function.
func (_m *Mockec2clientstub) DescribeFleetInstances(ctx internal.Context, input *ec2.DescribeFleetInstancesInput) (_result_0 *ec2.DescribeFleetInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeFleetInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFleetInstancesInput) *ec2.DescribeFleetInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeFleetInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeFleetInstancesAsync(ctx internal.Context, input *ec2.DescribeFleetInstancesInput) (_result_0 *ec2stub.DescribeFleetInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeFleetInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFleetInstancesInput) *ec2stub.DescribeFleetInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeFleetInstancesFuture)
		}
	}

	return r0
}

// DescribeFleets provides a mock function.
func (_m *Mockec2clientstub) DescribeFleets(ctx internal.Context, input *ec2.DescribeFleetsInput) (_result_0 *ec2.DescribeFleetsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeFleetsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFleetsInput) *ec2.DescribeFleetsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeFleetsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeFleetsAsync(ctx internal.Context, input *ec2.DescribeFleetsInput) (_result_0 *ec2stub.DescribeFleetsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeFleetsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFleetsInput) *ec2stub.DescribeFleetsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeFleetsFuture)
		}
	}

	return r0
}

// DescribeFlowLogs provides a mock function.
func (_m *Mockec2clientstub) DescribeFlowLogs(ctx internal.Context, input *ec2.DescribeFlowLogsInput) (_result_0 *ec2.DescribeFlowLogsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeFlowLogsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFlowLogsInput) *ec2.DescribeFlowLogsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFlowLogsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeFlowLogsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFlowLogsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeFlowLogsAsync(ctx internal.Context, input *ec2.DescribeFlowLogsInput) (_result_0 *ec2stub.DescribeFlowLogsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeFlowLogsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFlowLogsInput) *ec2stub.DescribeFlowLogsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeFlowLogsFuture)
		}
	}

	return r0
}

// DescribeFpgaImageAttribute provides a mock function.
func (_m *Mockec2clientstub) DescribeFpgaImageAttribute(ctx internal.Context, input *ec2.DescribeFpgaImageAttributeInput) (_result_0 *ec2.DescribeFpgaImageAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeFpgaImageAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFpgaImageAttributeInput) *ec2.DescribeFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFpgaImageAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeFpgaImageAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFpgaImageAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeFpgaImageAttributeAsync(ctx internal.Context, input *ec2.DescribeFpgaImageAttributeInput) (_result_0 *ec2stub.DescribeFpgaImageAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeFpgaImageAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFpgaImageAttributeInput) *ec2stub.DescribeFpgaImageAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeFpgaImageAttributeFuture)
		}
	}

	return r0
}

// DescribeFpgaImages provides a mock function.
func (_m *Mockec2clientstub) DescribeFpgaImages(ctx internal.Context, input *ec2.DescribeFpgaImagesInput) (_result_0 *ec2.DescribeFpgaImagesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeFpgaImagesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFpgaImagesInput) *ec2.DescribeFpgaImagesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFpgaImagesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeFpgaImagesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFpgaImagesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeFpgaImagesAsync(ctx internal.Context, input *ec2.DescribeFpgaImagesInput) (_result_0 *ec2stub.DescribeFpgaImagesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeFpgaImagesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeFpgaImagesInput) *ec2stub.DescribeFpgaImagesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeFpgaImagesFuture)
		}
	}

	return r0
}

// DescribeHostReservationOfferings provides a mock function.
func (_m *Mockec2clientstub) DescribeHostReservationOfferings(ctx internal.Context, input *ec2.DescribeHostReservationOfferingsInput) (_result_0 *ec2.DescribeHostReservationOfferingsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeHostReservationOfferingsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeHostReservationOfferingsInput) *ec2.DescribeHostReservationOfferingsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostReservationOfferingsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeHostReservationOfferingsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHostReservationOfferingsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeHostReservationOfferingsAsync(ctx internal.Context, input *ec2.DescribeHostReservationOfferingsInput) (_result_0 *ec2stub.DescribeHostReservationOfferingsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeHostReservationOfferingsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeHostReservationOfferingsInput) *ec2stub.DescribeHostReservationOfferingsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeHostReservationOfferingsFuture)
		}
	}

	return r0
}

// DescribeHostReservations provides a mock function.
func (_m *Mockec2clientstub) DescribeHostReservations(ctx internal.Context, input *ec2.DescribeHostReservationsInput) (_result_0 *ec2.DescribeHostReservationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeHostReservationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeHostReservationsInput) *ec2.DescribeHostReservationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostReservationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeHostReservationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHostReservationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeHostReservationsAsync(ctx internal.Context, input *ec2.DescribeHostReservationsInput) (_result_0 *ec2stub.DescribeHostReservationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeHostReservationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeHostReservationsInput) *ec2stub.DescribeHostReservationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeHostReservationsFuture)
		}
	}

	return r0
}

// DescribeHosts provides a mock function.
func (_m *Mockec2clientstub) DescribeHosts(ctx internal.Context, input *ec2.DescribeHostsInput) (_result_0 *ec2.DescribeHostsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeHostsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeHostsInput) *ec2.DescribeHostsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeHostsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHostsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeHostsAsync(ctx internal.Context, input *ec2.DescribeHostsInput) (_result_0 *ec2stub.DescribeHostsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeHostsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeHostsInput) *ec2stub.DescribeHostsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeHostsFuture)
		}
	}

	return r0
}

// DescribeIamInstanceProfileAssociations provides a mock function.
func (_m *Mockec2clientstub) DescribeIamInstanceProfileAssociations(ctx internal.Context, input *ec2.DescribeIamInstanceProfileAssociationsInput) (_result_0 *ec2.DescribeIamInstanceProfileAssociationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeIamInstanceProfileAssociationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeIamInstanceProfileAssociationsInput) *ec2.DescribeIamInstanceProfileAssociationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIamInstanceProfileAssociationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeIamInstanceProfileAssociationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIamInstanceProfileAssociationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeIamInstanceProfileAssociationsAsync(ctx internal.Context, input *ec2.DescribeIamInstanceProfileAssociationsInput) (_result_0 *ec2stub.DescribeIamInstanceProfileAssociationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeIamInstanceProfileAssociationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeIamInstanceProfileAssociationsInput) *ec2stub.DescribeIamInstanceProfileAssociationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeIamInstanceProfileAssociationsFuture)
		}
	}

	return r0
}

// DescribeIdFormat provides a mock function.
func (_m *Mockec2clientstub) DescribeIdFormat(ctx internal.Context, input *ec2.DescribeIdFormatInput) (_result_0 *ec2.DescribeIdFormatOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeIdFormatOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeIdFormatInput) *ec2.DescribeIdFormatOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIdFormatOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeIdFormatInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIdFormatAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeIdFormatAsync(ctx internal.Context, input *ec2.DescribeIdFormatInput) (_result_0 *ec2stub.DescribeIdFormatFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeIdFormatFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeIdFormatInput) *ec2stub.DescribeIdFormatFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeIdFormatFuture)
		}
	}

	return r0
}

// DescribeIdentityIdFormat provides a mock function.
func (_m *Mockec2clientstub) DescribeIdentityIdFormat(ctx internal.Context, input *ec2.DescribeIdentityIdFormatInput) (_result_0 *ec2.DescribeIdentityIdFormatOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeIdentityIdFormatOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeIdentityIdFormatInput) *ec2.DescribeIdentityIdFormatOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIdentityIdFormatOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeIdentityIdFormatInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIdentityIdFormatAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeIdentityIdFormatAsync(ctx internal.Context, input *ec2.DescribeIdentityIdFormatInput) (_result_0 *ec2stub.DescribeIdentityIdFormatFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeIdentityIdFormatFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeIdentityIdFormatInput) *ec2stub.DescribeIdentityIdFormatFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeIdentityIdFormatFuture)
		}
	}

	return r0
}

// DescribeImageAttribute provides a mock function.
func (_m *Mockec2clientstub) DescribeImageAttribute(ctx internal.Context, input *ec2.DescribeImageAttributeInput) (_result_0 *ec2.DescribeImageAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeImageAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImageAttributeInput) *ec2.DescribeImageAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImageAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeImageAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImageAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeImageAttributeAsync(ctx internal.Context, input *ec2.DescribeImageAttributeInput) (_result_0 *ec2stub.DescribeImageAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeImageAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImageAttributeInput) *ec2stub.DescribeImageAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeImageAttributeFuture)
		}
	}

	return r0
}

// DescribeImages provides a mock function.
func (_m *Mockec2clientstub) DescribeImages(ctx internal.Context, input *ec2.DescribeImagesInput) (_result_0 *ec2.DescribeImagesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeImagesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImagesInput) *ec2.DescribeImagesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImagesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeImagesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImagesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeImagesAsync(ctx internal.Context, input *ec2.DescribeImagesInput) (_result_0 *ec2stub.DescribeImagesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeImagesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImagesInput) *ec2stub.DescribeImagesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeImagesFuture)
		}
	}

	return r0
}

// DescribeImportImageTasks provides a mock function.
func (_m *Mockec2clientstub) DescribeImportImageTasks(ctx internal.Context, input *ec2.DescribeImportImageTasksInput) (_result_0 *ec2.DescribeImportImageTasksOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeImportImageTasksOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImportImageTasksInput) *ec2.DescribeImportImageTasksOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImportImageTasksOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeImportImageTasksInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImportImageTasksAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeImportImageTasksAsync(ctx internal.Context, input *ec2.DescribeImportImageTasksInput) (_result_0 *ec2stub.DescribeImportImageTasksFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeImportImageTasksFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImportImageTasksInput) *ec2stub.DescribeImportImageTasksFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeImportImageTasksFuture)
		}
	}

	return r0
}

// DescribeImportSnapshotTasks provides a mock function.
func (_m *Mockec2clientstub) DescribeImportSnapshotTasks(ctx internal.Context, input *ec2.DescribeImportSnapshotTasksInput) (_result_0 *ec2.DescribeImportSnapshotTasksOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeImportSnapshotTasksOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImportSnapshotTasksInput) *ec2.DescribeImportSnapshotTasksOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImportSnapshotTasksOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeImportSnapshotTasksInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImportSnapshotTasksAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeImportSnapshotTasksAsync(ctx internal.Context, input *ec2.DescribeImportSnapshotTasksInput) (_result_0 *ec2stub.DescribeImportSnapshotTasksFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeImportSnapshotTasksFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImportSnapshotTasksInput) *ec2stub.DescribeImportSnapshotTasksFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeImportSnapshotTasksFuture)
		}
	}

	return r0
}

// DescribeInstanceAttribute provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceAttribute(ctx internal.Context, input *ec2.DescribeInstanceAttributeInput) (_result_0 *ec2.DescribeInstanceAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeInstanceAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceAttributeInput) *ec2.DescribeInstanceAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeInstanceAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceAttributeAsync(ctx internal.Context, input *ec2.DescribeInstanceAttributeInput) (_result_0 *ec2stub.DescribeInstanceAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeInstanceAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceAttributeInput) *ec2stub.DescribeInstanceAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeInstanceAttributeFuture)
		}
	}

	return r0
}

// DescribeInstanceCreditSpecifications provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceCreditSpecifications(ctx internal.Context, input *ec2.DescribeInstanceCreditSpecificationsInput) (_result_0 *ec2.DescribeInstanceCreditSpecificationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeInstanceCreditSpecificationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceCreditSpecificationsInput) *ec2.DescribeInstanceCreditSpecificationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceCreditSpecificationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeInstanceCreditSpecificationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceCreditSpecificationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceCreditSpecificationsAsync(ctx internal.Context, input *ec2.DescribeInstanceCreditSpecificationsInput) (_result_0 *ec2stub.DescribeInstanceCreditSpecificationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeInstanceCreditSpecificationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceCreditSpecificationsInput) *ec2stub.DescribeInstanceCreditSpecificationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeInstanceCreditSpecificationsFuture)
		}
	}

	return r0
}

// DescribeInstanceEventNotificationAttributes provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceEventNotificationAttributes(ctx internal.Context, input *ec2.DescribeInstanceEventNotificationAttributesInput) (_result_0 *ec2.DescribeInstanceEventNotificationAttributesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeInstanceEventNotificationAttributesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceEventNotificationAttributesInput) *ec2.DescribeInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceEventNotificationAttributesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeInstanceEventNotificationAttributesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceEventNotificationAttributesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceEventNotificationAttributesAsync(ctx internal.Context, input *ec2.DescribeInstanceEventNotificationAttributesInput) (_result_0 *ec2stub.DescribeInstanceEventNotificationAttributesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeInstanceEventNotificationAttributesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceEventNotificationAttributesInput) *ec2stub.DescribeInstanceEventNotificationAttributesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeInstanceEventNotificationAttributesFuture)
		}
	}

	return r0
}

// DescribeInstanceStatus provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceStatus(ctx internal.Context, input *ec2.DescribeInstanceStatusInput) (_result_0 *ec2.DescribeInstanceStatusOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeInstanceStatusOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceStatusInput) *ec2.DescribeInstanceStatusOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceStatusOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeInstanceStatusInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceStatusAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceStatusAsync(ctx internal.Context, input *ec2.DescribeInstanceStatusInput) (_result_0 *ec2stub.DescribeInstanceStatusFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeInstanceStatusFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceStatusInput) *ec2stub.DescribeInstanceStatusFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeInstanceStatusFuture)
		}
	}

	return r0
}

// DescribeInstanceTypeOfferings provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceTypeOfferings(ctx internal.Context, input *ec2.DescribeInstanceTypeOfferingsInput) (_result_0 *ec2.DescribeInstanceTypeOfferingsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeInstanceTypeOfferingsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceTypeOfferingsInput) *ec2.DescribeInstanceTypeOfferingsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTypeOfferingsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeInstanceTypeOfferingsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceTypeOfferingsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceTypeOfferingsAsync(ctx internal.Context, input *ec2.DescribeInstanceTypeOfferingsInput) (_result_0 *ec2stub.DescribeInstanceTypeOfferingsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeInstanceTypeOfferingsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceTypeOfferingsInput) *ec2stub.DescribeInstanceTypeOfferingsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeInstanceTypeOfferingsFuture)
		}
	}

	return r0
}

// DescribeInstanceTypes provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceTypes(ctx internal.Context, input *ec2.DescribeInstanceTypesInput) (_result_0 *ec2.DescribeInstanceTypesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeInstanceTypesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceTypesInput) *ec2.DescribeInstanceTypesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTypesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeInstanceTypesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceTypesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeInstanceTypesAsync(ctx internal.Context, input *ec2.DescribeInstanceTypesInput) (_result_0 *ec2stub.DescribeInstanceTypesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeInstanceTypesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceTypesInput) *ec2stub.DescribeInstanceTypesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeInstanceTypesFuture)
		}
	}

	return r0
}

// DescribeInstances provides a mock function.
func (_m *Mockec2clientstub) DescribeInstances(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 *ec2.DescribeInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) *ec2.DescribeInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeInstancesAsync(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 *ec2stub.DescribeInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) *ec2stub.DescribeInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeInstancesFuture)
		}
	}

	return r0
}

// DescribeInternetGateways provides a mock function.
func (_m *Mockec2clientstub) DescribeInternetGateways(ctx internal.Context, input *ec2.DescribeInternetGatewaysInput) (_result_0 *ec2.DescribeInternetGatewaysOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeInternetGatewaysOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInternetGatewaysInput) *ec2.DescribeInternetGatewaysOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInternetGatewaysOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeInternetGatewaysInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInternetGatewaysAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeInternetGatewaysAsync(ctx internal.Context, input *ec2.DescribeInternetGatewaysInput) (_result_0 *ec2stub.DescribeInternetGatewaysFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeInternetGatewaysFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInternetGatewaysInput) *ec2stub.DescribeInternetGatewaysFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeInternetGatewaysFuture)
		}
	}

	return r0
}

// DescribeIpv6Pools provides a mock function.
func (_m *Mockec2clientstub) DescribeIpv6Pools(ctx internal.Context, input *ec2.DescribeIpv6PoolsInput) (_result_0 *ec2.DescribeIpv6PoolsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeIpv6PoolsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeIpv6PoolsInput) *ec2.DescribeIpv6PoolsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpv6PoolsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeIpv6PoolsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpv6PoolsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeIpv6PoolsAsync(ctx internal.Context, input *ec2.DescribeIpv6PoolsInput) (_result_0 *ec2stub.DescribeIpv6PoolsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeIpv6PoolsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeIpv6PoolsInput) *ec2stub.DescribeIpv6PoolsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeIpv6PoolsFuture)
		}
	}

	return r0
}

// DescribeKeyPairs provides a mock function.
func (_m *Mockec2clientstub) DescribeKeyPairs(ctx internal.Context, input *ec2.DescribeKeyPairsInput) (_result_0 *ec2.DescribeKeyPairsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeKeyPairsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeKeyPairsInput) *ec2.DescribeKeyPairsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeKeyPairsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeKeyPairsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeKeyPairsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeKeyPairsAsync(ctx internal.Context, input *ec2.DescribeKeyPairsInput) (_result_0 *ec2stub.DescribeKeyPairsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeKeyPairsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeKeyPairsInput) *ec2stub.DescribeKeyPairsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeKeyPairsFuture)
		}
	}

	return r0
}

// DescribeLaunchTemplateVersions provides a mock function.
func (_m *Mockec2clientstub) DescribeLaunchTemplateVersions(ctx internal.Context, input *ec2.DescribeLaunchTemplateVersionsInput) (_result_0 *ec2.DescribeLaunchTemplateVersionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeLaunchTemplateVersionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLaunchTemplateVersionsInput) *ec2.DescribeLaunchTemplateVersionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLaunchTemplateVersionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeLaunchTemplateVersionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLaunchTemplateVersionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeLaunchTemplateVersionsAsync(ctx internal.Context, input *ec2.DescribeLaunchTemplateVersionsInput) (_result_0 *ec2stub.DescribeLaunchTemplateVersionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeLaunchTemplateVersionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLaunchTemplateVersionsInput) *ec2stub.DescribeLaunchTemplateVersionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeLaunchTemplateVersionsFuture)
		}
	}

	return r0
}

// DescribeLaunchTemplates provides a mock function.
func (_m *Mockec2clientstub) DescribeLaunchTemplates(ctx internal.Context, input *ec2.DescribeLaunchTemplatesInput) (_result_0 *ec2.DescribeLaunchTemplatesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeLaunchTemplatesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLaunchTemplatesInput) *ec2.DescribeLaunchTemplatesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLaunchTemplatesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeLaunchTemplatesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLaunchTemplatesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeLaunchTemplatesAsync(ctx internal.Context, input *ec2.DescribeLaunchTemplatesInput) (_result_0 *ec2stub.DescribeLaunchTemplatesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeLaunchTemplatesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLaunchTemplatesInput) *ec2stub.DescribeLaunchTemplatesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeLaunchTemplatesFuture)
		}
	}

	return r0
}

// DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(ctx internal.Context, input *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput) (_result_0 *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput) *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsAsync(ctx internal.Context, input *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput) (_result_0 *ec2stub.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput) *ec2stub.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsFuture)
		}
	}

	return r0
}

// DescribeLocalGatewayRouteTableVpcAssociations provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayRouteTableVpcAssociations(ctx internal.Context, input *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput) (_result_0 *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput) *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayRouteTableVpcAssociationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayRouteTableVpcAssociationsAsync(ctx internal.Context, input *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput) (_result_0 *ec2stub.DescribeLocalGatewayRouteTableVpcAssociationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeLocalGatewayRouteTableVpcAssociationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput) *ec2stub.DescribeLocalGatewayRouteTableVpcAssociationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeLocalGatewayRouteTableVpcAssociationsFuture)
		}
	}

	return r0
}

// DescribeLocalGatewayRouteTables provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayRouteTables(ctx internal.Context, input *ec2.DescribeLocalGatewayRouteTablesInput) (_result_0 *ec2.DescribeLocalGatewayRouteTablesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeLocalGatewayRouteTablesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayRouteTablesInput) *ec2.DescribeLocalGatewayRouteTablesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTablesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeLocalGatewayRouteTablesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayRouteTablesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayRouteTablesAsync(ctx internal.Context, input *ec2.DescribeLocalGatewayRouteTablesInput) (_result_0 *ec2stub.DescribeLocalGatewayRouteTablesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeLocalGatewayRouteTablesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayRouteTablesInput) *ec2stub.DescribeLocalGatewayRouteTablesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeLocalGatewayRouteTablesFuture)
		}
	}

	return r0
}

// DescribeLocalGatewayVirtualInterfaceGroups provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayVirtualInterfaceGroups(ctx internal.Context, input *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput) (_result_0 *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput) *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayVirtualInterfaceGroupsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayVirtualInterfaceGroupsAsync(ctx internal.Context, input *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput) (_result_0 *ec2stub.DescribeLocalGatewayVirtualInterfaceGroupsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeLocalGatewayVirtualInterfaceGroupsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput) *ec2stub.DescribeLocalGatewayVirtualInterfaceGroupsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeLocalGatewayVirtualInterfaceGroupsFuture)
		}
	}

	return r0
}

// DescribeLocalGatewayVirtualInterfaces provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayVirtualInterfaces(ctx internal.Context, input *ec2.DescribeLocalGatewayVirtualInterfacesInput) (_result_0 *ec2.DescribeLocalGatewayVirtualInterfacesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeLocalGatewayVirtualInterfacesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput) *ec2.DescribeLocalGatewayVirtualInterfacesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayVirtualInterfacesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayVirtualInterfacesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewayVirtualInterfacesAsync(ctx internal.Context, input *ec2.DescribeLocalGatewayVirtualInterfacesInput) (_result_0 *ec2stub.DescribeLocalGatewayVirtualInterfacesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeLocalGatewayVirtualInterfacesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput) *ec2stub.DescribeLocalGatewayVirtualInterfacesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeLocalGatewayVirtualInterfacesFuture)
		}
	}

	return r0
}

// DescribeLocalGateways provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGateways(ctx internal.Context, input *ec2.DescribeLocalGatewaysInput) (_result_0 *ec2.DescribeLocalGatewaysOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeLocalGatewaysOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewaysInput) *ec2.DescribeLocalGatewaysOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewaysOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeLocalGatewaysInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewaysAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeLocalGatewaysAsync(ctx internal.Context, input *ec2.DescribeLocalGatewaysInput) (_result_0 *ec2stub.DescribeLocalGatewaysFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeLocalGatewaysFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeLocalGatewaysInput) *ec2stub.DescribeLocalGatewaysFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeLocalGatewaysFuture)
		}
	}

	return r0
}

// DescribeManagedPrefixLists provides a mock function.
func (_m *Mockec2clientstub) DescribeManagedPrefixLists(ctx internal.Context, input *ec2.DescribeManagedPrefixListsInput) (_result_0 *ec2.DescribeManagedPrefixListsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeManagedPrefixListsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeManagedPrefixListsInput) *ec2.DescribeManagedPrefixListsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeManagedPrefixListsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeManagedPrefixListsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeManagedPrefixListsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeManagedPrefixListsAsync(ctx internal.Context, input *ec2.DescribeManagedPrefixListsInput) (_result_0 *ec2stub.DescribeManagedPrefixListsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeManagedPrefixListsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeManagedPrefixListsInput) *ec2stub.DescribeManagedPrefixListsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeManagedPrefixListsFuture)
		}
	}

	return r0
}

// DescribeMovingAddresses provides a mock function.
func (_m *Mockec2clientstub) DescribeMovingAddresses(ctx internal.Context, input *ec2.DescribeMovingAddressesInput) (_result_0 *ec2.DescribeMovingAddressesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeMovingAddressesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeMovingAddressesInput) *ec2.DescribeMovingAddressesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeMovingAddressesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeMovingAddressesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMovingAddressesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeMovingAddressesAsync(ctx internal.Context, input *ec2.DescribeMovingAddressesInput) (_result_0 *ec2stub.DescribeMovingAddressesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeMovingAddressesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeMovingAddressesInput) *ec2stub.DescribeMovingAddressesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeMovingAddressesFuture)
		}
	}

	return r0
}

// DescribeNatGateways provides a mock function.
func (_m *Mockec2clientstub) DescribeNatGateways(ctx internal.Context, input *ec2.DescribeNatGatewaysInput) (_result_0 *ec2.DescribeNatGatewaysOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeNatGatewaysOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNatGatewaysInput) *ec2.DescribeNatGatewaysOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNatGatewaysOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeNatGatewaysInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNatGatewaysAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeNatGatewaysAsync(ctx internal.Context, input *ec2.DescribeNatGatewaysInput) (_result_0 *ec2stub.DescribeNatGatewaysFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeNatGatewaysFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNatGatewaysInput) *ec2stub.DescribeNatGatewaysFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeNatGatewaysFuture)
		}
	}

	return r0
}

// DescribeNetworkAcls provides a mock function.
func (_m *Mockec2clientstub) DescribeNetworkAcls(ctx internal.Context, input *ec2.DescribeNetworkAclsInput) (_result_0 *ec2.DescribeNetworkAclsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeNetworkAclsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkAclsInput) *ec2.DescribeNetworkAclsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkAclsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeNetworkAclsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkAclsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeNetworkAclsAsync(ctx internal.Context, input *ec2.DescribeNetworkAclsInput) (_result_0 *ec2stub.DescribeNetworkAclsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeNetworkAclsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkAclsInput) *ec2stub.DescribeNetworkAclsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeNetworkAclsFuture)
		}
	}

	return r0
}

// DescribeNetworkInterfaceAttribute provides a mock function.
func (_m *Mockec2clientstub) DescribeNetworkInterfaceAttribute(ctx internal.Context, input *ec2.DescribeNetworkInterfaceAttributeInput) (_result_0 *ec2.DescribeNetworkInterfaceAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeNetworkInterfaceAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkInterfaceAttributeInput) *ec2.DescribeNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfaceAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeNetworkInterfaceAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInterfaceAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeNetworkInterfaceAttributeAsync(ctx internal.Context, input *ec2.DescribeNetworkInterfaceAttributeInput) (_result_0 *ec2stub.DescribeNetworkInterfaceAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeNetworkInterfaceAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkInterfaceAttributeInput) *ec2stub.DescribeNetworkInterfaceAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeNetworkInterfaceAttributeFuture)
		}
	}

	return r0
}

// DescribeNetworkInterfacePermissions provides a mock function.
func (_m *Mockec2clientstub) DescribeNetworkInterfacePermissions(ctx internal.Context, input *ec2.DescribeNetworkInterfacePermissionsInput) (_result_0 *ec2.DescribeNetworkInterfacePermissionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeNetworkInterfacePermissionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkInterfacePermissionsInput) *ec2.DescribeNetworkInterfacePermissionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfacePermissionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeNetworkInterfacePermissionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInterfacePermissionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeNetworkInterfacePermissionsAsync(ctx internal.Context, input *ec2.DescribeNetworkInterfacePermissionsInput) (_result_0 *ec2stub.DescribeNetworkInterfacePermissionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeNetworkInterfacePermissionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkInterfacePermissionsInput) *ec2stub.DescribeNetworkInterfacePermissionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeNetworkInterfacePermissionsFuture)
		}
	}

	return r0
}

// DescribeNetworkInterfaces provides a mock function.
func (_m *Mockec2clientstub) DescribeNetworkInterfaces(ctx internal.Context, input *ec2.DescribeNetworkInterfacesInput) (_result_0 *ec2.DescribeNetworkInterfacesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeNetworkInterfacesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkInterfacesInput) *ec2.DescribeNetworkInterfacesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfacesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeNetworkInterfacesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInterfacesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeNetworkInterfacesAsync(ctx internal.Context, input *ec2.DescribeNetworkInterfacesInput) (_result_0 *ec2stub.DescribeNetworkInterfacesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeNetworkInterfacesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkInterfacesInput) *ec2stub.DescribeNetworkInterfacesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeNetworkInterfacesFuture)
		}
	}

	return r0
}

// DescribePlacementGroups provides a mock function.
func (_m *Mockec2clientstub) DescribePlacementGroups(ctx internal.Context, input *ec2.DescribePlacementGroupsInput) (_result_0 *ec2.DescribePlacementGroupsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribePlacementGroupsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribePlacementGroupsInput) *ec2.DescribePlacementGroupsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePlacementGroupsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribePlacementGroupsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePlacementGroupsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribePlacementGroupsAsync(ctx internal.Context, input *ec2.DescribePlacementGroupsInput) (_result_0 *ec2stub.DescribePlacementGroupsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribePlacementGroupsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribePlacementGroupsInput) *ec2stub.DescribePlacementGroupsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribePlacementGroupsFuture)
		}
	}

	return r0
}

// DescribePrefixLists provides a mock function.
func (_m *Mockec2clientstub) DescribePrefixLists(ctx internal.Context, input *ec2.DescribePrefixListsInput) (_result_0 *ec2.DescribePrefixListsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribePrefixListsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribePrefixListsInput) *ec2.DescribePrefixListsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePrefixListsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribePrefixListsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePrefixListsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribePrefixListsAsync(ctx internal.Context, input *ec2.DescribePrefixListsInput) (_result_0 *ec2stub.DescribePrefixListsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribePrefixListsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribePrefixListsInput) *ec2stub.DescribePrefixListsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribePrefixListsFuture)
		}
	}

	return r0
}

// DescribePrincipalIdFormat provides a mock function.
func (_m *Mockec2clientstub) DescribePrincipalIdFormat(ctx internal.Context, input *ec2.DescribePrincipalIdFormatInput) (_result_0 *ec2.DescribePrincipalIdFormatOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribePrincipalIdFormatOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribePrincipalIdFormatInput) *ec2.DescribePrincipalIdFormatOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePrincipalIdFormatOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribePrincipalIdFormatInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePrincipalIdFormatAsync provides a mock function.
func (_m *Mockec2clientstub) DescribePrincipalIdFormatAsync(ctx internal.Context, input *ec2.DescribePrincipalIdFormatInput) (_result_0 *ec2stub.DescribePrincipalIdFormatFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribePrincipalIdFormatFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribePrincipalIdFormatInput) *ec2stub.DescribePrincipalIdFormatFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribePrincipalIdFormatFuture)
		}
	}

	return r0
}

// DescribePublicIpv4Pools provides a mock function.
func (_m *Mockec2clientstub) DescribePublicIpv4Pools(ctx internal.Context, input *ec2.DescribePublicIpv4PoolsInput) (_result_0 *ec2.DescribePublicIpv4PoolsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribePublicIpv4PoolsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribePublicIpv4PoolsInput) *ec2.DescribePublicIpv4PoolsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePublicIpv4PoolsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribePublicIpv4PoolsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePublicIpv4PoolsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribePublicIpv4PoolsAsync(ctx internal.Context, input *ec2.DescribePublicIpv4PoolsInput) (_result_0 *ec2stub.DescribePublicIpv4PoolsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribePublicIpv4PoolsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribePublicIpv4PoolsInput) *ec2stub.DescribePublicIpv4PoolsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribePublicIpv4PoolsFuture)
		}
	}

	return r0
}

// DescribeRegions provides a mock function.
func (_m *Mockec2clientstub) DescribeRegions(ctx internal.Context, input *ec2.DescribeRegionsInput) (_result_0 *ec2.DescribeRegionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeRegionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeRegionsInput) *ec2.DescribeRegionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRegionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeRegionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRegionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeRegionsAsync(ctx internal.Context, input *ec2.DescribeRegionsInput) (_result_0 *ec2stub.DescribeRegionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeRegionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeRegionsInput) *ec2stub.DescribeRegionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeRegionsFuture)
		}
	}

	return r0
}

// DescribeReservedInstances provides a mock function.
func (_m *Mockec2clientstub) DescribeReservedInstances(ctx internal.Context, input *ec2.DescribeReservedInstancesInput) (_result_0 *ec2.DescribeReservedInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeReservedInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeReservedInstancesInput) *ec2.DescribeReservedInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeReservedInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeReservedInstancesAsync(ctx internal.Context, input *ec2.DescribeReservedInstancesInput) (_result_0 *ec2stub.DescribeReservedInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeReservedInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeReservedInstancesInput) *ec2stub.DescribeReservedInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeReservedInstancesFuture)
		}
	}

	return r0
}

// DescribeReservedInstancesListings provides a mock function.
func (_m *Mockec2clientstub) DescribeReservedInstancesListings(ctx internal.Context, input *ec2.DescribeReservedInstancesListingsInput) (_result_0 *ec2.DescribeReservedInstancesListingsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeReservedInstancesListingsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeReservedInstancesListingsInput) *ec2.DescribeReservedInstancesListingsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesListingsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeReservedInstancesListingsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesListingsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeReservedInstancesListingsAsync(ctx internal.Context, input *ec2.DescribeReservedInstancesListingsInput) (_result_0 *ec2stub.DescribeReservedInstancesListingsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeReservedInstancesListingsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeReservedInstancesListingsInput) *ec2stub.DescribeReservedInstancesListingsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeReservedInstancesListingsFuture)
		}
	}

	return r0
}

// DescribeReservedInstancesModifications provides a mock function.
func (_m *Mockec2clientstub) DescribeReservedInstancesModifications(ctx internal.Context, input *ec2.DescribeReservedInstancesModificationsInput) (_result_0 *ec2.DescribeReservedInstancesModificationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeReservedInstancesModificationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeReservedInstancesModificationsInput) *ec2.DescribeReservedInstancesModificationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesModificationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeReservedInstancesModificationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesModificationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeReservedInstancesModificationsAsync(ctx internal.Context, input *ec2.DescribeReservedInstancesModificationsInput) (_result_0 *ec2stub.DescribeReservedInstancesModificationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeReservedInstancesModificationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeReservedInstancesModificationsInput) *ec2stub.DescribeReservedInstancesModificationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeReservedInstancesModificationsFuture)
		}
	}

	return r0
}

// DescribeReservedInstancesOfferings provides a mock function.
func (_m *Mockec2clientstub) DescribeReservedInstancesOfferings(ctx internal.Context, input *ec2.DescribeReservedInstancesOfferingsInput) (_result_0 *ec2.DescribeReservedInstancesOfferingsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeReservedInstancesOfferingsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeReservedInstancesOfferingsInput) *ec2.DescribeReservedInstancesOfferingsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesOfferingsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeReservedInstancesOfferingsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesOfferingsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeReservedInstancesOfferingsAsync(ctx internal.Context, input *ec2.DescribeReservedInstancesOfferingsInput) (_result_0 *ec2stub.DescribeReservedInstancesOfferingsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeReservedInstancesOfferingsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeReservedInstancesOfferingsInput) *ec2stub.DescribeReservedInstancesOfferingsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeReservedInstancesOfferingsFuture)
		}
	}

	return r0
}

// DescribeRouteTables provides a mock function.
func (_m *Mockec2clientstub) DescribeRouteTables(ctx internal.Context, input *ec2.DescribeRouteTablesInput) (_result_0 *ec2.DescribeRouteTablesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeRouteTablesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeRouteTablesInput) *ec2.DescribeRouteTablesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRouteTablesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeRouteTablesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRouteTablesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeRouteTablesAsync(ctx internal.Context, input *ec2.DescribeRouteTablesInput) (_result_0 *ec2stub.DescribeRouteTablesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeRouteTablesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeRouteTablesInput) *ec2stub.DescribeRouteTablesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeRouteTablesFuture)
		}
	}

	return r0
}

// DescribeScheduledInstanceAvailability provides a mock function.
func (_m *Mockec2clientstub) DescribeScheduledInstanceAvailability(ctx internal.Context, input *ec2.DescribeScheduledInstanceAvailabilityInput) (_result_0 *ec2.DescribeScheduledInstanceAvailabilityOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeScheduledInstanceAvailabilityOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeScheduledInstanceAvailabilityInput) *ec2.DescribeScheduledInstanceAvailabilityOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeScheduledInstanceAvailabilityOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeScheduledInstanceAvailabilityInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScheduledInstanceAvailabilityAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeScheduledInstanceAvailabilityAsync(ctx internal.Context, input *ec2.DescribeScheduledInstanceAvailabilityInput) (_result_0 *ec2stub.DescribeScheduledInstanceAvailabilityFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeScheduledInstanceAvailabilityFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeScheduledInstanceAvailabilityInput) *ec2stub.DescribeScheduledInstanceAvailabilityFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeScheduledInstanceAvailabilityFuture)
		}
	}

	return r0
}

// DescribeScheduledInstances provides a mock function.
func (_m *Mockec2clientstub) DescribeScheduledInstances(ctx internal.Context, input *ec2.DescribeScheduledInstancesInput) (_result_0 *ec2.DescribeScheduledInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeScheduledInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeScheduledInstancesInput) *ec2.DescribeScheduledInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeScheduledInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeScheduledInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScheduledInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeScheduledInstancesAsync(ctx internal.Context, input *ec2.DescribeScheduledInstancesInput) (_result_0 *ec2stub.DescribeScheduledInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeScheduledInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeScheduledInstancesInput) *ec2stub.DescribeScheduledInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeScheduledInstancesFuture)
		}
	}

	return r0
}

// DescribeSecurityGroupReferences provides a mock function.
func (_m *Mockec2clientstub) DescribeSecurityGroupReferences(ctx internal.Context, input *ec2.DescribeSecurityGroupReferencesInput) (_result_0 *ec2.DescribeSecurityGroupReferencesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSecurityGroupReferencesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSecurityGroupReferencesInput) *ec2.DescribeSecurityGroupReferencesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupReferencesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSecurityGroupReferencesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityGroupReferencesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSecurityGroupReferencesAsync(ctx internal.Context, input *ec2.DescribeSecurityGroupReferencesInput) (_result_0 *ec2stub.DescribeSecurityGroupReferencesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSecurityGroupReferencesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSecurityGroupReferencesInput) *ec2stub.DescribeSecurityGroupReferencesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSecurityGroupReferencesFuture)
		}
	}

	return r0
}

// DescribeSecurityGroups provides a mock function.
func (_m *Mockec2clientstub) DescribeSecurityGroups(ctx internal.Context, input *ec2.DescribeSecurityGroupsInput) (_result_0 *ec2.DescribeSecurityGroupsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSecurityGroupsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSecurityGroupsInput) *ec2.DescribeSecurityGroupsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSecurityGroupsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityGroupsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSecurityGroupsAsync(ctx internal.Context, input *ec2.DescribeSecurityGroupsInput) (_result_0 *ec2stub.DescribeSecurityGroupsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSecurityGroupsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSecurityGroupsInput) *ec2stub.DescribeSecurityGroupsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSecurityGroupsFuture)
		}
	}

	return r0
}

// DescribeSnapshotAttribute provides a mock function.
func (_m *Mockec2clientstub) DescribeSnapshotAttribute(ctx internal.Context, input *ec2.DescribeSnapshotAttributeInput) (_result_0 *ec2.DescribeSnapshotAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSnapshotAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSnapshotAttributeInput) *ec2.DescribeSnapshotAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSnapshotAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshotAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSnapshotAttributeAsync(ctx internal.Context, input *ec2.DescribeSnapshotAttributeInput) (_result_0 *ec2stub.DescribeSnapshotAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSnapshotAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSnapshotAttributeInput) *ec2stub.DescribeSnapshotAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSnapshotAttributeFuture)
		}
	}

	return r0
}

// DescribeSnapshots provides a mock function.
func (_m *Mockec2clientstub) DescribeSnapshots(ctx internal.Context, input *ec2.DescribeSnapshotsInput) (_result_0 *ec2.DescribeSnapshotsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSnapshotsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSnapshotsInput) *ec2.DescribeSnapshotsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSnapshotsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshotsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSnapshotsAsync(ctx internal.Context, input *ec2.DescribeSnapshotsInput) (_result_0 *ec2stub.DescribeSnapshotsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSnapshotsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSnapshotsInput) *ec2stub.DescribeSnapshotsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSnapshotsFuture)
		}
	}

	return r0
}

// DescribeSpotDatafeedSubscription provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotDatafeedSubscription(ctx internal.Context, input *ec2.DescribeSpotDatafeedSubscriptionInput) (_result_0 *ec2.DescribeSpotDatafeedSubscriptionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSpotDatafeedSubscriptionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotDatafeedSubscriptionInput) *ec2.DescribeSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotDatafeedSubscriptionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSpotDatafeedSubscriptionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotDatafeedSubscriptionAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotDatafeedSubscriptionAsync(ctx internal.Context, input *ec2.DescribeSpotDatafeedSubscriptionInput) (_result_0 *ec2stub.DescribeSpotDatafeedSubscriptionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSpotDatafeedSubscriptionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotDatafeedSubscriptionInput) *ec2stub.DescribeSpotDatafeedSubscriptionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSpotDatafeedSubscriptionFuture)
		}
	}

	return r0
}

// DescribeSpotFleetInstances provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotFleetInstances(ctx internal.Context, input *ec2.DescribeSpotFleetInstancesInput) (_result_0 *ec2.DescribeSpotFleetInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSpotFleetInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotFleetInstancesInput) *ec2.DescribeSpotFleetInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSpotFleetInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotFleetInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotFleetInstancesAsync(ctx internal.Context, input *ec2.DescribeSpotFleetInstancesInput) (_result_0 *ec2stub.DescribeSpotFleetInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSpotFleetInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotFleetInstancesInput) *ec2stub.DescribeSpotFleetInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSpotFleetInstancesFuture)
		}
	}

	return r0
}

// DescribeSpotFleetRequestHistory provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotFleetRequestHistory(ctx internal.Context, input *ec2.DescribeSpotFleetRequestHistoryInput) (_result_0 *ec2.DescribeSpotFleetRequestHistoryOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSpotFleetRequestHistoryOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotFleetRequestHistoryInput) *ec2.DescribeSpotFleetRequestHistoryOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetRequestHistoryOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSpotFleetRequestHistoryInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotFleetRequestHistoryAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotFleetRequestHistoryAsync(ctx internal.Context, input *ec2.DescribeSpotFleetRequestHistoryInput) (_result_0 *ec2stub.DescribeSpotFleetRequestHistoryFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSpotFleetRequestHistoryFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotFleetRequestHistoryInput) *ec2stub.DescribeSpotFleetRequestHistoryFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSpotFleetRequestHistoryFuture)
		}
	}

	return r0
}

// DescribeSpotFleetRequests provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotFleetRequests(ctx internal.Context, input *ec2.DescribeSpotFleetRequestsInput) (_result_0 *ec2.DescribeSpotFleetRequestsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSpotFleetRequestsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotFleetRequestsInput) *ec2.DescribeSpotFleetRequestsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetRequestsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSpotFleetRequestsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotFleetRequestsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotFleetRequestsAsync(ctx internal.Context, input *ec2.DescribeSpotFleetRequestsInput) (_result_0 *ec2stub.DescribeSpotFleetRequestsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSpotFleetRequestsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotFleetRequestsInput) *ec2stub.DescribeSpotFleetRequestsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSpotFleetRequestsFuture)
		}
	}

	return r0
}

// DescribeSpotInstanceRequests provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotInstanceRequests(ctx internal.Context, input *ec2.DescribeSpotInstanceRequestsInput) (_result_0 *ec2.DescribeSpotInstanceRequestsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSpotInstanceRequestsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotInstanceRequestsInput) *ec2.DescribeSpotInstanceRequestsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotInstanceRequestsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSpotInstanceRequestsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotInstanceRequestsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotInstanceRequestsAsync(ctx internal.Context, input *ec2.DescribeSpotInstanceRequestsInput) (_result_0 *ec2stub.DescribeSpotInstanceRequestsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSpotInstanceRequestsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotInstanceRequestsInput) *ec2stub.DescribeSpotInstanceRequestsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSpotInstanceRequestsFuture)
		}
	}

	return r0
}

// DescribeSpotPriceHistory provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotPriceHistory(ctx internal.Context, input *ec2.DescribeSpotPriceHistoryInput) (_result_0 *ec2.DescribeSpotPriceHistoryOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSpotPriceHistoryOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotPriceHistoryInput) *ec2.DescribeSpotPriceHistoryOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotPriceHistoryOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSpotPriceHistoryInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotPriceHistoryAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSpotPriceHistoryAsync(ctx internal.Context, input *ec2.DescribeSpotPriceHistoryInput) (_result_0 *ec2stub.DescribeSpotPriceHistoryFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSpotPriceHistoryFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotPriceHistoryInput) *ec2stub.DescribeSpotPriceHistoryFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSpotPriceHistoryFuture)
		}
	}

	return r0
}

// DescribeStaleSecurityGroups provides a mock function.
func (_m *Mockec2clientstub) DescribeStaleSecurityGroups(ctx internal.Context, input *ec2.DescribeStaleSecurityGroupsInput) (_result_0 *ec2.DescribeStaleSecurityGroupsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeStaleSecurityGroupsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeStaleSecurityGroupsInput) *ec2.DescribeStaleSecurityGroupsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeStaleSecurityGroupsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeStaleSecurityGroupsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStaleSecurityGroupsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeStaleSecurityGroupsAsync(ctx internal.Context, input *ec2.DescribeStaleSecurityGroupsInput) (_result_0 *ec2stub.DescribeStaleSecurityGroupsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeStaleSecurityGroupsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeStaleSecurityGroupsInput) *ec2stub.DescribeStaleSecurityGroupsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeStaleSecurityGroupsFuture)
		}
	}

	return r0
}

// DescribeSubnets provides a mock function.
func (_m *Mockec2clientstub) DescribeSubnets(ctx internal.Context, input *ec2.DescribeSubnetsInput) (_result_0 *ec2.DescribeSubnetsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeSubnetsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSubnetsInput) *ec2.DescribeSubnetsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSubnetsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeSubnetsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSubnetsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeSubnetsAsync(ctx internal.Context, input *ec2.DescribeSubnetsInput) (_result_0 *ec2stub.DescribeSubnetsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeSubnetsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSubnetsInput) *ec2stub.DescribeSubnetsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeSubnetsFuture)
		}
	}

	return r0
}

// DescribeTags provides a mock function.
func (_m *Mockec2clientstub) DescribeTags(ctx internal.Context, input *ec2.DescribeTagsInput) (_result_0 *ec2.DescribeTagsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTagsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTagsInput) *ec2.DescribeTagsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTagsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTagsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTagsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTagsAsync(ctx internal.Context, input *ec2.DescribeTagsInput) (_result_0 *ec2stub.DescribeTagsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTagsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTagsInput) *ec2stub.DescribeTagsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTagsFuture)
		}
	}

	return r0
}

// DescribeTrafficMirrorFilters provides a mock function.
func (_m *Mockec2clientstub) DescribeTrafficMirrorFilters(ctx internal.Context, input *ec2.DescribeTrafficMirrorFiltersInput) (_result_0 *ec2.DescribeTrafficMirrorFiltersOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTrafficMirrorFiltersOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTrafficMirrorFiltersInput) *ec2.DescribeTrafficMirrorFiltersOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorFiltersOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTrafficMirrorFiltersInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorFiltersAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTrafficMirrorFiltersAsync(ctx internal.Context, input *ec2.DescribeTrafficMirrorFiltersInput) (_result_0 *ec2stub.DescribeTrafficMirrorFiltersFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTrafficMirrorFiltersFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTrafficMirrorFiltersInput) *ec2stub.DescribeTrafficMirrorFiltersFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTrafficMirrorFiltersFuture)
		}
	}

	return r0
}

// DescribeTrafficMirrorSessions provides a mock function.
func (_m *Mockec2clientstub) DescribeTrafficMirrorSessions(ctx internal.Context, input *ec2.DescribeTrafficMirrorSessionsInput) (_result_0 *ec2.DescribeTrafficMirrorSessionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTrafficMirrorSessionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTrafficMirrorSessionsInput) *ec2.DescribeTrafficMirrorSessionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorSessionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTrafficMirrorSessionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorSessionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTrafficMirrorSessionsAsync(ctx internal.Context, input *ec2.DescribeTrafficMirrorSessionsInput) (_result_0 *ec2stub.DescribeTrafficMirrorSessionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTrafficMirrorSessionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTrafficMirrorSessionsInput) *ec2stub.DescribeTrafficMirrorSessionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTrafficMirrorSessionsFuture)
		}
	}

	return r0
}

// DescribeTrafficMirrorTargets provides a mock function.
func (_m *Mockec2clientstub) DescribeTrafficMirrorTargets(ctx internal.Context, input *ec2.DescribeTrafficMirrorTargetsInput) (_result_0 *ec2.DescribeTrafficMirrorTargetsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTrafficMirrorTargetsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTrafficMirrorTargetsInput) *ec2.DescribeTrafficMirrorTargetsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorTargetsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTrafficMirrorTargetsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorTargetsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTrafficMirrorTargetsAsync(ctx internal.Context, input *ec2.DescribeTrafficMirrorTargetsInput) (_result_0 *ec2stub.DescribeTrafficMirrorTargetsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTrafficMirrorTargetsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTrafficMirrorTargetsInput) *ec2stub.DescribeTrafficMirrorTargetsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTrafficMirrorTargetsFuture)
		}
	}

	return r0
}

// DescribeTransitGatewayAttachments provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayAttachments(ctx internal.Context, input *ec2.DescribeTransitGatewayAttachmentsInput) (_result_0 *ec2.DescribeTransitGatewayAttachmentsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTransitGatewayAttachmentsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayAttachmentsInput) *ec2.DescribeTransitGatewayAttachmentsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayAttachmentsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTransitGatewayAttachmentsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayAttachmentsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayAttachmentsAsync(ctx internal.Context, input *ec2.DescribeTransitGatewayAttachmentsInput) (_result_0 *ec2stub.DescribeTransitGatewayAttachmentsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTransitGatewayAttachmentsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayAttachmentsInput) *ec2stub.DescribeTransitGatewayAttachmentsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTransitGatewayAttachmentsFuture)
		}
	}

	return r0
}

// DescribeTransitGatewayMulticastDomains provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayMulticastDomains(ctx internal.Context, input *ec2.DescribeTransitGatewayMulticastDomainsInput) (_result_0 *ec2.DescribeTransitGatewayMulticastDomainsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTransitGatewayMulticastDomainsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput) *ec2.DescribeTransitGatewayMulticastDomainsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayMulticastDomainsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayMulticastDomainsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayMulticastDomainsAsync(ctx internal.Context, input *ec2.DescribeTransitGatewayMulticastDomainsInput) (_result_0 *ec2stub.DescribeTransitGatewayMulticastDomainsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTransitGatewayMulticastDomainsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput) *ec2stub.DescribeTransitGatewayMulticastDomainsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTransitGatewayMulticastDomainsFuture)
		}
	}

	return r0
}

// DescribeTransitGatewayPeeringAttachments provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayPeeringAttachments(ctx internal.Context, input *ec2.DescribeTransitGatewayPeeringAttachmentsInput) (_result_0 *ec2.DescribeTransitGatewayPeeringAttachmentsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTransitGatewayPeeringAttachmentsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput) *ec2.DescribeTransitGatewayPeeringAttachmentsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayPeeringAttachmentsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayPeeringAttachmentsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayPeeringAttachmentsAsync(ctx internal.Context, input *ec2.DescribeTransitGatewayPeeringAttachmentsInput) (_result_0 *ec2stub.DescribeTransitGatewayPeeringAttachmentsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTransitGatewayPeeringAttachmentsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput) *ec2stub.DescribeTransitGatewayPeeringAttachmentsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTransitGatewayPeeringAttachmentsFuture)
		}
	}

	return r0
}

// DescribeTransitGatewayRouteTables provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayRouteTables(ctx internal.Context, input *ec2.DescribeTransitGatewayRouteTablesInput) (_result_0 *ec2.DescribeTransitGatewayRouteTablesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTransitGatewayRouteTablesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayRouteTablesInput) *ec2.DescribeTransitGatewayRouteTablesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayRouteTablesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTransitGatewayRouteTablesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayRouteTablesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayRouteTablesAsync(ctx internal.Context, input *ec2.DescribeTransitGatewayRouteTablesInput) (_result_0 *ec2stub.DescribeTransitGatewayRouteTablesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTransitGatewayRouteTablesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayRouteTablesInput) *ec2stub.DescribeTransitGatewayRouteTablesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTransitGatewayRouteTablesFuture)
		}
	}

	return r0
}

// DescribeTransitGatewayVpcAttachments provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayVpcAttachments(ctx internal.Context, input *ec2.DescribeTransitGatewayVpcAttachmentsInput) (_result_0 *ec2.DescribeTransitGatewayVpcAttachmentsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTransitGatewayVpcAttachmentsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput) *ec2.DescribeTransitGatewayVpcAttachmentsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayVpcAttachmentsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayVpcAttachmentsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewayVpcAttachmentsAsync(ctx internal.Context, input *ec2.DescribeTransitGatewayVpcAttachmentsInput) (_result_0 *ec2stub.DescribeTransitGatewayVpcAttachmentsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTransitGatewayVpcAttachmentsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput) *ec2stub.DescribeTransitGatewayVpcAttachmentsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTransitGatewayVpcAttachmentsFuture)
		}
	}

	return r0
}

// DescribeTransitGateways provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGateways(ctx internal.Context, input *ec2.DescribeTransitGatewaysInput) (_result_0 *ec2.DescribeTransitGatewaysOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeTransitGatewaysOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewaysInput) *ec2.DescribeTransitGatewaysOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewaysOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeTransitGatewaysInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewaysAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeTransitGatewaysAsync(ctx internal.Context, input *ec2.DescribeTransitGatewaysInput) (_result_0 *ec2stub.DescribeTransitGatewaysFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeTransitGatewaysFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeTransitGatewaysInput) *ec2stub.DescribeTransitGatewaysFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeTransitGatewaysFuture)
		}
	}

	return r0
}

// DescribeVolumeAttribute provides a mock function.
func (_m *Mockec2clientstub) DescribeVolumeAttribute(ctx internal.Context, input *ec2.DescribeVolumeAttributeInput) (_result_0 *ec2.DescribeVolumeAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVolumeAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumeAttributeInput) *ec2.DescribeVolumeAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumeAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVolumeAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumeAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVolumeAttributeAsync(ctx internal.Context, input *ec2.DescribeVolumeAttributeInput) (_result_0 *ec2stub.DescribeVolumeAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVolumeAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumeAttributeInput) *ec2stub.DescribeVolumeAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVolumeAttributeFuture)
		}
	}

	return r0
}

// DescribeVolumeStatus provides a mock function.
func (_m *Mockec2clientstub) DescribeVolumeStatus(ctx internal.Context, input *ec2.DescribeVolumeStatusInput) (_result_0 *ec2.DescribeVolumeStatusOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVolumeStatusOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumeStatusInput) *ec2.DescribeVolumeStatusOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumeStatusOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVolumeStatusInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumeStatusAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVolumeStatusAsync(ctx internal.Context, input *ec2.DescribeVolumeStatusInput) (_result_0 *ec2stub.DescribeVolumeStatusFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVolumeStatusFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumeStatusInput) *ec2stub.DescribeVolumeStatusFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVolumeStatusFuture)
		}
	}

	return r0
}

// DescribeVolumes provides a mock function.
func (_m *Mockec2clientstub) DescribeVolumes(ctx internal.Context, input *ec2.DescribeVolumesInput) (_result_0 *ec2.DescribeVolumesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVolumesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesInput) *ec2.DescribeVolumesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVolumesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVolumesAsync(ctx internal.Context, input *ec2.DescribeVolumesInput) (_result_0 *ec2stub.DescribeVolumesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVolumesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesInput) *ec2stub.DescribeVolumesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVolumesFuture)
		}
	}

	return r0
}

// DescribeVolumesModifications provides a mock function.
func (_m *Mockec2clientstub) DescribeVolumesModifications(ctx internal.Context, input *ec2.DescribeVolumesModificationsInput) (_result_0 *ec2.DescribeVolumesModificationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVolumesModificationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesModificationsInput) *ec2.DescribeVolumesModificationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumesModificationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVolumesModificationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumesModificationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVolumesModificationsAsync(ctx internal.Context, input *ec2.DescribeVolumesModificationsInput) (_result_0 *ec2stub.DescribeVolumesModificationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVolumesModificationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesModificationsInput) *ec2stub.DescribeVolumesModificationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVolumesModificationsFuture)
		}
	}

	return r0
}

// DescribeVpcAttribute provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcAttribute(ctx internal.Context, input *ec2.DescribeVpcAttributeInput) (_result_0 *ec2.DescribeVpcAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcAttributeInput) *ec2.DescribeVpcAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcAttributeAsync(ctx internal.Context, input *ec2.DescribeVpcAttributeInput) (_result_0 *ec2stub.DescribeVpcAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcAttributeInput) *ec2stub.DescribeVpcAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcAttributeFuture)
		}
	}

	return r0
}

// DescribeVpcClassicLink provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcClassicLink(ctx internal.Context, input *ec2.DescribeVpcClassicLinkInput) (_result_0 *ec2.DescribeVpcClassicLinkOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcClassicLinkOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcClassicLinkInput) *ec2.DescribeVpcClassicLinkOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcClassicLinkOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcClassicLinkInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcClassicLinkAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcClassicLinkAsync(ctx internal.Context, input *ec2.DescribeVpcClassicLinkInput) (_result_0 *ec2stub.DescribeVpcClassicLinkFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcClassicLinkFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcClassicLinkInput) *ec2stub.DescribeVpcClassicLinkFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcClassicLinkFuture)
		}
	}

	return r0
}

// DescribeVpcClassicLinkDnsSupport provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcClassicLinkDnsSupport(ctx internal.Context, input *ec2.DescribeVpcClassicLinkDnsSupportInput) (_result_0 *ec2.DescribeVpcClassicLinkDnsSupportOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcClassicLinkDnsSupportOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput) *ec2.DescribeVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcClassicLinkDnsSupportOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcClassicLinkDnsSupportAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcClassicLinkDnsSupportAsync(ctx internal.Context, input *ec2.DescribeVpcClassicLinkDnsSupportInput) (_result_0 *ec2stub.DescribeVpcClassicLinkDnsSupportFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcClassicLinkDnsSupportFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput) *ec2stub.DescribeVpcClassicLinkDnsSupportFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcClassicLinkDnsSupportFuture)
		}
	}

	return r0
}

// DescribeVpcEndpointConnectionNotifications provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointConnectionNotifications(ctx internal.Context, input *ec2.DescribeVpcEndpointConnectionNotificationsInput) (_result_0 *ec2.DescribeVpcEndpointConnectionNotificationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcEndpointConnectionNotificationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput) *ec2.DescribeVpcEndpointConnectionNotificationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointConnectionNotificationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointConnectionNotificationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointConnectionNotificationsAsync(ctx internal.Context, input *ec2.DescribeVpcEndpointConnectionNotificationsInput) (_result_0 *ec2stub.DescribeVpcEndpointConnectionNotificationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcEndpointConnectionNotificationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput) *ec2stub.DescribeVpcEndpointConnectionNotificationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcEndpointConnectionNotificationsFuture)
		}
	}

	return r0
}

// DescribeVpcEndpointConnections provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointConnections(ctx internal.Context, input *ec2.DescribeVpcEndpointConnectionsInput) (_result_0 *ec2.DescribeVpcEndpointConnectionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcEndpointConnectionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointConnectionsInput) *ec2.DescribeVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointConnectionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcEndpointConnectionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointConnectionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointConnectionsAsync(ctx internal.Context, input *ec2.DescribeVpcEndpointConnectionsInput) (_result_0 *ec2stub.DescribeVpcEndpointConnectionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcEndpointConnectionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointConnectionsInput) *ec2stub.DescribeVpcEndpointConnectionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcEndpointConnectionsFuture)
		}
	}

	return r0
}

// DescribeVpcEndpointServiceConfigurations provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointServiceConfigurations(ctx internal.Context, input *ec2.DescribeVpcEndpointServiceConfigurationsInput) (_result_0 *ec2.DescribeVpcEndpointServiceConfigurationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcEndpointServiceConfigurationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput) *ec2.DescribeVpcEndpointServiceConfigurationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServiceConfigurationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointServiceConfigurationsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointServiceConfigurationsAsync(ctx internal.Context, input *ec2.DescribeVpcEndpointServiceConfigurationsInput) (_result_0 *ec2stub.DescribeVpcEndpointServiceConfigurationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcEndpointServiceConfigurationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput) *ec2stub.DescribeVpcEndpointServiceConfigurationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcEndpointServiceConfigurationsFuture)
		}
	}

	return r0
}

// DescribeVpcEndpointServicePermissions provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointServicePermissions(ctx internal.Context, input *ec2.DescribeVpcEndpointServicePermissionsInput) (_result_0 *ec2.DescribeVpcEndpointServicePermissionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcEndpointServicePermissionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointServicePermissionsInput) *ec2.DescribeVpcEndpointServicePermissionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServicePermissionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcEndpointServicePermissionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointServicePermissionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointServicePermissionsAsync(ctx internal.Context, input *ec2.DescribeVpcEndpointServicePermissionsInput) (_result_0 *ec2stub.DescribeVpcEndpointServicePermissionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcEndpointServicePermissionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointServicePermissionsInput) *ec2stub.DescribeVpcEndpointServicePermissionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcEndpointServicePermissionsFuture)
		}
	}

	return r0
}

// DescribeVpcEndpointServices provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointServices(ctx internal.Context, input *ec2.DescribeVpcEndpointServicesInput) (_result_0 *ec2.DescribeVpcEndpointServicesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcEndpointServicesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointServicesInput) *ec2.DescribeVpcEndpointServicesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServicesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcEndpointServicesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointServicesAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointServicesAsync(ctx internal.Context, input *ec2.DescribeVpcEndpointServicesInput) (_result_0 *ec2stub.DescribeVpcEndpointServicesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcEndpointServicesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointServicesInput) *ec2stub.DescribeVpcEndpointServicesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcEndpointServicesFuture)
		}
	}

	return r0
}

// DescribeVpcEndpoints provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpoints(ctx internal.Context, input *ec2.DescribeVpcEndpointsInput) (_result_0 *ec2.DescribeVpcEndpointsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcEndpointsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointsInput) *ec2.DescribeVpcEndpointsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcEndpointsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcEndpointsAsync(ctx internal.Context, input *ec2.DescribeVpcEndpointsInput) (_result_0 *ec2stub.DescribeVpcEndpointsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcEndpointsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcEndpointsInput) *ec2stub.DescribeVpcEndpointsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcEndpointsFuture)
		}
	}

	return r0
}

// DescribeVpcPeeringConnections provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcPeeringConnections(ctx internal.Context, input *ec2.DescribeVpcPeeringConnectionsInput) (_result_0 *ec2.DescribeVpcPeeringConnectionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcPeeringConnectionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcPeeringConnectionsInput) *ec2.DescribeVpcPeeringConnectionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcPeeringConnectionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcPeeringConnectionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcPeeringConnectionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcPeeringConnectionsAsync(ctx internal.Context, input *ec2.DescribeVpcPeeringConnectionsInput) (_result_0 *ec2stub.DescribeVpcPeeringConnectionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcPeeringConnectionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcPeeringConnectionsInput) *ec2stub.DescribeVpcPeeringConnectionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcPeeringConnectionsFuture)
		}
	}

	return r0
}

// DescribeVpcs provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcs(ctx internal.Context, input *ec2.DescribeVpcsInput) (_result_0 *ec2.DescribeVpcsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpcsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcsInput) *ec2.DescribeVpcsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpcsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpcsAsync(ctx internal.Context, input *ec2.DescribeVpcsInput) (_result_0 *ec2stub.DescribeVpcsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpcsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcsInput) *ec2stub.DescribeVpcsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpcsFuture)
		}
	}

	return r0
}

// DescribeVpnConnections provides a mock function.
func (_m *Mockec2clientstub) DescribeVpnConnections(ctx internal.Context, input *ec2.DescribeVpnConnectionsInput) (_result_0 *ec2.DescribeVpnConnectionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpnConnectionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpnConnectionsInput) *ec2.DescribeVpnConnectionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpnConnectionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpnConnectionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpnConnectionsAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpnConnectionsAsync(ctx internal.Context, input *ec2.DescribeVpnConnectionsInput) (_result_0 *ec2stub.DescribeVpnConnectionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpnConnectionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpnConnectionsInput) *ec2stub.DescribeVpnConnectionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpnConnectionsFuture)
		}
	}

	return r0
}

// DescribeVpnGateways provides a mock function.
func (_m *Mockec2clientstub) DescribeVpnGateways(ctx internal.Context, input *ec2.DescribeVpnGatewaysInput) (_result_0 *ec2.DescribeVpnGatewaysOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DescribeVpnGatewaysOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpnGatewaysInput) *ec2.DescribeVpnGatewaysOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpnGatewaysOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DescribeVpnGatewaysInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpnGatewaysAsync provides a mock function.
func (_m *Mockec2clientstub) DescribeVpnGatewaysAsync(ctx internal.Context, input *ec2.DescribeVpnGatewaysInput) (_result_0 *ec2stub.DescribeVpnGatewaysFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DescribeVpnGatewaysFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpnGatewaysInput) *ec2stub.DescribeVpnGatewaysFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DescribeVpnGatewaysFuture)
		}
	}

	return r0
}

// DetachClassicLinkVpc provides a mock function.
func (_m *Mockec2clientstub) DetachClassicLinkVpc(ctx internal.Context, input *ec2.DetachClassicLinkVpcInput) (_result_0 *ec2.DetachClassicLinkVpcOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DetachClassicLinkVpcOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachClassicLinkVpcInput) *ec2.DetachClassicLinkVpcOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachClassicLinkVpcOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DetachClassicLinkVpcInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachClassicLinkVpcAsync provides a mock function.
func (_m *Mockec2clientstub) DetachClassicLinkVpcAsync(ctx internal.Context, input *ec2.DetachClassicLinkVpcInput) (_result_0 *ec2stub.DetachClassicLinkVpcFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DetachClassicLinkVpcFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachClassicLinkVpcInput) *ec2stub.DetachClassicLinkVpcFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DetachClassicLinkVpcFuture)
		}
	}

	return r0
}

// DetachInternetGateway provides a mock function.
func (_m *Mockec2clientstub) DetachInternetGateway(ctx internal.Context, input *ec2.DetachInternetGatewayInput) (_result_0 *ec2.DetachInternetGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DetachInternetGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachInternetGatewayInput) *ec2.DetachInternetGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachInternetGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DetachInternetGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachInternetGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) DetachInternetGatewayAsync(ctx internal.Context, input *ec2.DetachInternetGatewayInput) (_result_0 *ec2stub.DetachInternetGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DetachInternetGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachInternetGatewayInput) *ec2stub.DetachInternetGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DetachInternetGatewayFuture)
		}
	}

	return r0
}

// DetachNetworkInterface provides a mock function.
func (_m *Mockec2clientstub) DetachNetworkInterface(ctx internal.Context, input *ec2.DetachNetworkInterfaceInput) (_result_0 *ec2.DetachNetworkInterfaceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DetachNetworkInterfaceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachNetworkInterfaceInput) *ec2.DetachNetworkInterfaceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachNetworkInterfaceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DetachNetworkInterfaceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachNetworkInterfaceAsync provides a mock function.
func (_m *Mockec2clientstub) DetachNetworkInterfaceAsync(ctx internal.Context, input *ec2.DetachNetworkInterfaceInput) (_result_0 *ec2stub.DetachNetworkInterfaceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DetachNetworkInterfaceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachNetworkInterfaceInput) *ec2stub.DetachNetworkInterfaceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DetachNetworkInterfaceFuture)
		}
	}

	return r0
}

// DetachVolume provides a mock function.
func (_m *Mockec2clientstub) DetachVolume(ctx internal.Context, input *ec2.DetachVolumeInput) (_result_0 *ec2.VolumeAttachment, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.VolumeAttachment
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachVolumeInput) *ec2.VolumeAttachment); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.VolumeAttachment)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DetachVolumeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachVolumeAsync provides a mock function.
func (_m *Mockec2clientstub) DetachVolumeAsync(ctx internal.Context, input *ec2.DetachVolumeInput) (_result_0 *ec2stub.DetachVolumeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DetachVolumeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachVolumeInput) *ec2stub.DetachVolumeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DetachVolumeFuture)
		}
	}

	return r0
}

// DetachVpnGateway provides a mock function.
func (_m *Mockec2clientstub) DetachVpnGateway(ctx internal.Context, input *ec2.DetachVpnGatewayInput) (_result_0 *ec2.DetachVpnGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DetachVpnGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachVpnGatewayInput) *ec2.DetachVpnGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachVpnGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DetachVpnGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachVpnGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) DetachVpnGatewayAsync(ctx internal.Context, input *ec2.DetachVpnGatewayInput) (_result_0 *ec2stub.DetachVpnGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DetachVpnGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DetachVpnGatewayInput) *ec2stub.DetachVpnGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DetachVpnGatewayFuture)
		}
	}

	return r0
}

// DisableEbsEncryptionByDefault provides a mock function.
func (_m *Mockec2clientstub) DisableEbsEncryptionByDefault(ctx internal.Context, input *ec2.DisableEbsEncryptionByDefaultInput) (_result_0 *ec2.DisableEbsEncryptionByDefaultOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisableEbsEncryptionByDefaultOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableEbsEncryptionByDefaultInput) *ec2.DisableEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableEbsEncryptionByDefaultOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisableEbsEncryptionByDefaultInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableEbsEncryptionByDefaultAsync provides a mock function.
func (_m *Mockec2clientstub) DisableEbsEncryptionByDefaultAsync(ctx internal.Context, input *ec2.DisableEbsEncryptionByDefaultInput) (_result_0 *ec2stub.DisableEbsEncryptionByDefaultFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisableEbsEncryptionByDefaultFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableEbsEncryptionByDefaultInput) *ec2stub.DisableEbsEncryptionByDefaultFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisableEbsEncryptionByDefaultFuture)
		}
	}

	return r0
}

// DisableFastSnapshotRestores provides a mock function.
func (_m *Mockec2clientstub) DisableFastSnapshotRestores(ctx internal.Context, input *ec2.DisableFastSnapshotRestoresInput) (_result_0 *ec2.DisableFastSnapshotRestoresOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisableFastSnapshotRestoresOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableFastSnapshotRestoresInput) *ec2.DisableFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableFastSnapshotRestoresOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisableFastSnapshotRestoresInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableFastSnapshotRestoresAsync provides a mock function.
func (_m *Mockec2clientstub) DisableFastSnapshotRestoresAsync(ctx internal.Context, input *ec2.DisableFastSnapshotRestoresInput) (_result_0 *ec2stub.DisableFastSnapshotRestoresFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisableFastSnapshotRestoresFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableFastSnapshotRestoresInput) *ec2stub.DisableFastSnapshotRestoresFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisableFastSnapshotRestoresFuture)
		}
	}

	return r0
}

// DisableTransitGatewayRouteTablePropagation provides a mock function.
func (_m *Mockec2clientstub) DisableTransitGatewayRouteTablePropagation(ctx internal.Context, input *ec2.DisableTransitGatewayRouteTablePropagationInput) (_result_0 *ec2.DisableTransitGatewayRouteTablePropagationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisableTransitGatewayRouteTablePropagationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput) *ec2.DisableTransitGatewayRouteTablePropagationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableTransitGatewayRouteTablePropagationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableTransitGatewayRouteTablePropagationAsync provides a mock function.
func (_m *Mockec2clientstub) DisableTransitGatewayRouteTablePropagationAsync(ctx internal.Context, input *ec2.DisableTransitGatewayRouteTablePropagationInput) (_result_0 *ec2stub.DisableTransitGatewayRouteTablePropagationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisableTransitGatewayRouteTablePropagationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput) *ec2stub.DisableTransitGatewayRouteTablePropagationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisableTransitGatewayRouteTablePropagationFuture)
		}
	}

	return r0
}

// DisableVgwRoutePropagation provides a mock function.
func (_m *Mockec2clientstub) DisableVgwRoutePropagation(ctx internal.Context, input *ec2.DisableVgwRoutePropagationInput) (_result_0 *ec2.DisableVgwRoutePropagationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisableVgwRoutePropagationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableVgwRoutePropagationInput) *ec2.DisableVgwRoutePropagationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVgwRoutePropagationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisableVgwRoutePropagationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableVgwRoutePropagationAsync provides a mock function.
func (_m *Mockec2clientstub) DisableVgwRoutePropagationAsync(ctx internal.Context, input *ec2.DisableVgwRoutePropagationInput) (_result_0 *ec2stub.DisableVgwRoutePropagationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisableVgwRoutePropagationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableVgwRoutePropagationInput) *ec2stub.DisableVgwRoutePropagationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisableVgwRoutePropagationFuture)
		}
	}

	return r0
}

// DisableVpcClassicLink provides a mock function.
func (_m *Mockec2clientstub) DisableVpcClassicLink(ctx internal.Context, input *ec2.DisableVpcClassicLinkInput) (_result_0 *ec2.DisableVpcClassicLinkOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisableVpcClassicLinkOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableVpcClassicLinkInput) *ec2.DisableVpcClassicLinkOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVpcClassicLinkOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisableVpcClassicLinkInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableVpcClassicLinkAsync provides a mock function.
func (_m *Mockec2clientstub) DisableVpcClassicLinkAsync(ctx internal.Context, input *ec2.DisableVpcClassicLinkInput) (_result_0 *ec2stub.DisableVpcClassicLinkFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisableVpcClassicLinkFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableVpcClassicLinkInput) *ec2stub.DisableVpcClassicLinkFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisableVpcClassicLinkFuture)
		}
	}

	return r0
}

// DisableVpcClassicLinkDnsSupport provides a mock function.
func (_m *Mockec2clientstub) DisableVpcClassicLinkDnsSupport(ctx internal.Context, input *ec2.DisableVpcClassicLinkDnsSupportInput) (_result_0 *ec2.DisableVpcClassicLinkDnsSupportOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisableVpcClassicLinkDnsSupportOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableVpcClassicLinkDnsSupportInput) *ec2.DisableVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVpcClassicLinkDnsSupportOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisableVpcClassicLinkDnsSupportInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableVpcClassicLinkDnsSupportAsync provides a mock function.
func (_m *Mockec2clientstub) DisableVpcClassicLinkDnsSupportAsync(ctx internal.Context, input *ec2.DisableVpcClassicLinkDnsSupportInput) (_result_0 *ec2stub.DisableVpcClassicLinkDnsSupportFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisableVpcClassicLinkDnsSupportFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisableVpcClassicLinkDnsSupportInput) *ec2stub.DisableVpcClassicLinkDnsSupportFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisableVpcClassicLinkDnsSupportFuture)
		}
	}

	return r0
}

// DisassociateAddress provides a mock function.
func (_m *Mockec2clientstub) DisassociateAddress(ctx internal.Context, input *ec2.DisassociateAddressInput) (_result_0 *ec2.DisassociateAddressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisassociateAddressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateAddressInput) *ec2.DisassociateAddressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateAddressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisassociateAddressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateAddressAsync provides a mock function.
func (_m *Mockec2clientstub) DisassociateAddressAsync(ctx internal.Context, input *ec2.DisassociateAddressInput) (_result_0 *ec2stub.DisassociateAddressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisassociateAddressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateAddressInput) *ec2stub.DisassociateAddressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisassociateAddressFuture)
		}
	}

	return r0
}

// DisassociateClientVpnTargetNetwork provides a mock function.
func (_m *Mockec2clientstub) DisassociateClientVpnTargetNetwork(ctx internal.Context, input *ec2.DisassociateClientVpnTargetNetworkInput) (_result_0 *ec2.DisassociateClientVpnTargetNetworkOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisassociateClientVpnTargetNetworkOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateClientVpnTargetNetworkInput) *ec2.DisassociateClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateClientVpnTargetNetworkOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisassociateClientVpnTargetNetworkInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateClientVpnTargetNetworkAsync provides a mock function.
func (_m *Mockec2clientstub) DisassociateClientVpnTargetNetworkAsync(ctx internal.Context, input *ec2.DisassociateClientVpnTargetNetworkInput) (_result_0 *ec2stub.DisassociateClientVpnTargetNetworkFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisassociateClientVpnTargetNetworkFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateClientVpnTargetNetworkInput) *ec2stub.DisassociateClientVpnTargetNetworkFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisassociateClientVpnTargetNetworkFuture)
		}
	}

	return r0
}

// DisassociateEnclaveCertificateIamRole provides a mock function.
func (_m *Mockec2clientstub) DisassociateEnclaveCertificateIamRole(ctx internal.Context, input *ec2.DisassociateEnclaveCertificateIamRoleInput) (_result_0 *ec2.DisassociateEnclaveCertificateIamRoleOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisassociateEnclaveCertificateIamRoleOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput) *ec2.DisassociateEnclaveCertificateIamRoleOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateEnclaveCertificateIamRoleOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateEnclaveCertificateIamRoleAsync provides a mock function.
func (_m *Mockec2clientstub) DisassociateEnclaveCertificateIamRoleAsync(ctx internal.Context, input *ec2.DisassociateEnclaveCertificateIamRoleInput) (_result_0 *ec2stub.DisassociateEnclaveCertificateIamRoleFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisassociateEnclaveCertificateIamRoleFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput) *ec2stub.DisassociateEnclaveCertificateIamRoleFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisassociateEnclaveCertificateIamRoleFuture)
		}
	}

	return r0
}

// DisassociateIamInstanceProfile provides a mock function.
func (_m *Mockec2clientstub) DisassociateIamInstanceProfile(ctx internal.Context, input *ec2.DisassociateIamInstanceProfileInput) (_result_0 *ec2.DisassociateIamInstanceProfileOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisassociateIamInstanceProfileOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateIamInstanceProfileInput) *ec2.DisassociateIamInstanceProfileOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateIamInstanceProfileOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisassociateIamInstanceProfileInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateIamInstanceProfileAsync provides a mock function.
func (_m *Mockec2clientstub) DisassociateIamInstanceProfileAsync(ctx internal.Context, input *ec2.DisassociateIamInstanceProfileInput) (_result_0 *ec2stub.DisassociateIamInstanceProfileFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisassociateIamInstanceProfileFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateIamInstanceProfileInput) *ec2stub.DisassociateIamInstanceProfileFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisassociateIamInstanceProfileFuture)
		}
	}

	return r0
}

// DisassociateRouteTable provides a mock function.
func (_m *Mockec2clientstub) DisassociateRouteTable(ctx internal.Context, input *ec2.DisassociateRouteTableInput) (_result_0 *ec2.DisassociateRouteTableOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisassociateRouteTableOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateRouteTableInput) *ec2.DisassociateRouteTableOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateRouteTableOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisassociateRouteTableInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateRouteTableAsync provides a mock function.
func (_m *Mockec2clientstub) DisassociateRouteTableAsync(ctx internal.Context, input *ec2.DisassociateRouteTableInput) (_result_0 *ec2stub.DisassociateRouteTableFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisassociateRouteTableFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateRouteTableInput) *ec2stub.DisassociateRouteTableFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisassociateRouteTableFuture)
		}
	}

	return r0
}

// DisassociateSubnetCidrBlock provides a mock function.
func (_m *Mockec2clientstub) DisassociateSubnetCidrBlock(ctx internal.Context, input *ec2.DisassociateSubnetCidrBlockInput) (_result_0 *ec2.DisassociateSubnetCidrBlockOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisassociateSubnetCidrBlockOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateSubnetCidrBlockInput) *ec2.DisassociateSubnetCidrBlockOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateSubnetCidrBlockOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisassociateSubnetCidrBlockInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateSubnetCidrBlockAsync provides a mock function.
func (_m *Mockec2clientstub) DisassociateSubnetCidrBlockAsync(ctx internal.Context, input *ec2.DisassociateSubnetCidrBlockInput) (_result_0 *ec2stub.DisassociateSubnetCidrBlockFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisassociateSubnetCidrBlockFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateSubnetCidrBlockInput) *ec2stub.DisassociateSubnetCidrBlockFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisassociateSubnetCidrBlockFuture)
		}
	}

	return r0
}

// DisassociateTransitGatewayMulticastDomain provides a mock function.
func (_m *Mockec2clientstub) DisassociateTransitGatewayMulticastDomain(ctx internal.Context, input *ec2.DisassociateTransitGatewayMulticastDomainInput) (_result_0 *ec2.DisassociateTransitGatewayMulticastDomainOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisassociateTransitGatewayMulticastDomainOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput) *ec2.DisassociateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTransitGatewayMulticastDomainOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTransitGatewayMulticastDomainAsync provides a mock function.
func (_m *Mockec2clientstub) DisassociateTransitGatewayMulticastDomainAsync(ctx internal.Context, input *ec2.DisassociateTransitGatewayMulticastDomainInput) (_result_0 *ec2stub.DisassociateTransitGatewayMulticastDomainFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisassociateTransitGatewayMulticastDomainFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput) *ec2stub.DisassociateTransitGatewayMulticastDomainFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisassociateTransitGatewayMulticastDomainFuture)
		}
	}

	return r0
}

// DisassociateTransitGatewayRouteTable provides a mock function.
func (_m *Mockec2clientstub) DisassociateTransitGatewayRouteTable(ctx internal.Context, input *ec2.DisassociateTransitGatewayRouteTableInput) (_result_0 *ec2.DisassociateTransitGatewayRouteTableOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisassociateTransitGatewayRouteTableOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateTransitGatewayRouteTableInput) *ec2.DisassociateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTransitGatewayRouteTableOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisassociateTransitGatewayRouteTableInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTransitGatewayRouteTableAsync provides a mock function.
func (_m *Mockec2clientstub) DisassociateTransitGatewayRouteTableAsync(ctx internal.Context, input *ec2.DisassociateTransitGatewayRouteTableInput) (_result_0 *ec2stub.DisassociateTransitGatewayRouteTableFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisassociateTransitGatewayRouteTableFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateTransitGatewayRouteTableInput) *ec2stub.DisassociateTransitGatewayRouteTableFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisassociateTransitGatewayRouteTableFuture)
		}
	}

	return r0
}

// DisassociateVpcCidrBlock provides a mock function.
func (_m *Mockec2clientstub) DisassociateVpcCidrBlock(ctx internal.Context, input *ec2.DisassociateVpcCidrBlockInput) (_result_0 *ec2.DisassociateVpcCidrBlockOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.DisassociateVpcCidrBlockOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateVpcCidrBlockInput) *ec2.DisassociateVpcCidrBlockOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateVpcCidrBlockOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.DisassociateVpcCidrBlockInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateVpcCidrBlockAsync provides a mock function.
func (_m *Mockec2clientstub) DisassociateVpcCidrBlockAsync(ctx internal.Context, input *ec2.DisassociateVpcCidrBlockInput) (_result_0 *ec2stub.DisassociateVpcCidrBlockFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.DisassociateVpcCidrBlockFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DisassociateVpcCidrBlockInput) *ec2stub.DisassociateVpcCidrBlockFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.DisassociateVpcCidrBlockFuture)
		}
	}

	return r0
}

// EnableEbsEncryptionByDefault provides a mock function.
func (_m *Mockec2clientstub) EnableEbsEncryptionByDefault(ctx internal.Context, input *ec2.EnableEbsEncryptionByDefaultInput) (_result_0 *ec2.EnableEbsEncryptionByDefaultOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.EnableEbsEncryptionByDefaultOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableEbsEncryptionByDefaultInput) *ec2.EnableEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableEbsEncryptionByDefaultOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.EnableEbsEncryptionByDefaultInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableEbsEncryptionByDefaultAsync provides a mock function.
func (_m *Mockec2clientstub) EnableEbsEncryptionByDefaultAsync(ctx internal.Context, input *ec2.EnableEbsEncryptionByDefaultInput) (_result_0 *ec2stub.EnableEbsEncryptionByDefaultFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.EnableEbsEncryptionByDefaultFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableEbsEncryptionByDefaultInput) *ec2stub.EnableEbsEncryptionByDefaultFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.EnableEbsEncryptionByDefaultFuture)
		}
	}

	return r0
}

// EnableFastSnapshotRestores provides a mock function.
func (_m *Mockec2clientstub) EnableFastSnapshotRestores(ctx internal.Context, input *ec2.EnableFastSnapshotRestoresInput) (_result_0 *ec2.EnableFastSnapshotRestoresOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.EnableFastSnapshotRestoresOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableFastSnapshotRestoresInput) *ec2.EnableFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableFastSnapshotRestoresOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.EnableFastSnapshotRestoresInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableFastSnapshotRestoresAsync provides a mock function.
func (_m *Mockec2clientstub) EnableFastSnapshotRestoresAsync(ctx internal.Context, input *ec2.EnableFastSnapshotRestoresInput) (_result_0 *ec2stub.EnableFastSnapshotRestoresFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.EnableFastSnapshotRestoresFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableFastSnapshotRestoresInput) *ec2stub.EnableFastSnapshotRestoresFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.EnableFastSnapshotRestoresFuture)
		}
	}

	return r0
}

// EnableTransitGatewayRouteTablePropagation provides a mock function.
func (_m *Mockec2clientstub) EnableTransitGatewayRouteTablePropagation(ctx internal.Context, input *ec2.EnableTransitGatewayRouteTablePropagationInput) (_result_0 *ec2.EnableTransitGatewayRouteTablePropagationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.EnableTransitGatewayRouteTablePropagationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput) *ec2.EnableTransitGatewayRouteTablePropagationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableTransitGatewayRouteTablePropagationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableTransitGatewayRouteTablePropagationAsync provides a mock function.
func (_m *Mockec2clientstub) EnableTransitGatewayRouteTablePropagationAsync(ctx internal.Context, input *ec2.EnableTransitGatewayRouteTablePropagationInput) (_result_0 *ec2stub.EnableTransitGatewayRouteTablePropagationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.EnableTransitGatewayRouteTablePropagationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput) *ec2stub.EnableTransitGatewayRouteTablePropagationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.EnableTransitGatewayRouteTablePropagationFuture)
		}
	}

	return r0
}

// EnableVgwRoutePropagation provides a mock function.
func (_m *Mockec2clientstub) EnableVgwRoutePropagation(ctx internal.Context, input *ec2.EnableVgwRoutePropagationInput) (_result_0 *ec2.EnableVgwRoutePropagationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.EnableVgwRoutePropagationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableVgwRoutePropagationInput) *ec2.EnableVgwRoutePropagationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVgwRoutePropagationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.EnableVgwRoutePropagationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVgwRoutePropagationAsync provides a mock function.
func (_m *Mockec2clientstub) EnableVgwRoutePropagationAsync(ctx internal.Context, input *ec2.EnableVgwRoutePropagationInput) (_result_0 *ec2stub.EnableVgwRoutePropagationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.EnableVgwRoutePropagationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableVgwRoutePropagationInput) *ec2stub.EnableVgwRoutePropagationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.EnableVgwRoutePropagationFuture)
		}
	}

	return r0
}

// EnableVolumeIO provides a mock function.
func (_m *Mockec2clientstub) EnableVolumeIO(ctx internal.Context, input *ec2.EnableVolumeIOInput) (_result_0 *ec2.EnableVolumeIOOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.EnableVolumeIOOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableVolumeIOInput) *ec2.EnableVolumeIOOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVolumeIOOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.EnableVolumeIOInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVolumeIOAsync provides a mock function.
func (_m *Mockec2clientstub) EnableVolumeIOAsync(ctx internal.Context, input *ec2.EnableVolumeIOInput) (_result_0 *ec2stub.EnableVolumeIOFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.EnableVolumeIOFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableVolumeIOInput) *ec2stub.EnableVolumeIOFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.EnableVolumeIOFuture)
		}
	}

	return r0
}

// EnableVpcClassicLink provides a mock function.
func (_m *Mockec2clientstub) EnableVpcClassicLink(ctx internal.Context, input *ec2.EnableVpcClassicLinkInput) (_result_0 *ec2.EnableVpcClassicLinkOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.EnableVpcClassicLinkOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableVpcClassicLinkInput) *ec2.EnableVpcClassicLinkOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVpcClassicLinkOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.EnableVpcClassicLinkInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVpcClassicLinkAsync provides a mock function.
func (_m *Mockec2clientstub) EnableVpcClassicLinkAsync(ctx internal.Context, input *ec2.EnableVpcClassicLinkInput) (_result_0 *ec2stub.EnableVpcClassicLinkFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.EnableVpcClassicLinkFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableVpcClassicLinkInput) *ec2stub.EnableVpcClassicLinkFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.EnableVpcClassicLinkFuture)
		}
	}

	return r0
}

// EnableVpcClassicLinkDnsSupport provides a mock function.
func (_m *Mockec2clientstub) EnableVpcClassicLinkDnsSupport(ctx internal.Context, input *ec2.EnableVpcClassicLinkDnsSupportInput) (_result_0 *ec2.EnableVpcClassicLinkDnsSupportOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.EnableVpcClassicLinkDnsSupportOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableVpcClassicLinkDnsSupportInput) *ec2.EnableVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVpcClassicLinkDnsSupportOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.EnableVpcClassicLinkDnsSupportInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVpcClassicLinkDnsSupportAsync provides a mock function.
func (_m *Mockec2clientstub) EnableVpcClassicLinkDnsSupportAsync(ctx internal.Context, input *ec2.EnableVpcClassicLinkDnsSupportInput) (_result_0 *ec2stub.EnableVpcClassicLinkDnsSupportFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.EnableVpcClassicLinkDnsSupportFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.EnableVpcClassicLinkDnsSupportInput) *ec2stub.EnableVpcClassicLinkDnsSupportFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.EnableVpcClassicLinkDnsSupportFuture)
		}
	}

	return r0
}

// ExportClientVpnClientCertificateRevocationList provides a mock function.
func (_m *Mockec2clientstub) ExportClientVpnClientCertificateRevocationList(ctx internal.Context, input *ec2.ExportClientVpnClientCertificateRevocationListInput) (_result_0 *ec2.ExportClientVpnClientCertificateRevocationListOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ExportClientVpnClientCertificateRevocationListOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput) *ec2.ExportClientVpnClientCertificateRevocationListOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportClientVpnClientCertificateRevocationListOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportClientVpnClientCertificateRevocationListAsync provides a mock function.
func (_m *Mockec2clientstub) ExportClientVpnClientCertificateRevocationListAsync(ctx internal.Context, input *ec2.ExportClientVpnClientCertificateRevocationListInput) (_result_0 *ec2stub.ExportClientVpnClientCertificateRevocationListFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ExportClientVpnClientCertificateRevocationListFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput) *ec2stub.ExportClientVpnClientCertificateRevocationListFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ExportClientVpnClientCertificateRevocationListFuture)
		}
	}

	return r0
}

// ExportClientVpnClientConfiguration provides a mock function.
func (_m *Mockec2clientstub) ExportClientVpnClientConfiguration(ctx internal.Context, input *ec2.ExportClientVpnClientConfigurationInput) (_result_0 *ec2.ExportClientVpnClientConfigurationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ExportClientVpnClientConfigurationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ExportClientVpnClientConfigurationInput) *ec2.ExportClientVpnClientConfigurationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportClientVpnClientConfigurationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ExportClientVpnClientConfigurationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportClientVpnClientConfigurationAsync provides a mock function.
func (_m *Mockec2clientstub) ExportClientVpnClientConfigurationAsync(ctx internal.Context, input *ec2.ExportClientVpnClientConfigurationInput) (_result_0 *ec2stub.ExportClientVpnClientConfigurationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ExportClientVpnClientConfigurationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ExportClientVpnClientConfigurationInput) *ec2stub.ExportClientVpnClientConfigurationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ExportClientVpnClientConfigurationFuture)
		}
	}

	return r0
}

// ExportImage provides a mock function.
func (_m *Mockec2clientstub) ExportImage(ctx internal.Context, input *ec2.ExportImageInput) (_result_0 *ec2.ExportImageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ExportImageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ExportImageInput) *ec2.ExportImageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportImageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ExportImageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportImageAsync provides a mock function.
func (_m *Mockec2clientstub) ExportImageAsync(ctx internal.Context, input *ec2.ExportImageInput) (_result_0 *ec2stub.ExportImageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ExportImageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ExportImageInput) *ec2stub.ExportImageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ExportImageFuture)
		}
	}

	return r0
}

// ExportTransitGatewayRoutes provides a mock function.
func (_m *Mockec2clientstub) ExportTransitGatewayRoutes(ctx internal.Context, input *ec2.ExportTransitGatewayRoutesInput) (_result_0 *ec2.ExportTransitGatewayRoutesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ExportTransitGatewayRoutesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ExportTransitGatewayRoutesInput) *ec2.ExportTransitGatewayRoutesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportTransitGatewayRoutesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ExportTransitGatewayRoutesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportTransitGatewayRoutesAsync provides a mock function.
func (_m *Mockec2clientstub) ExportTransitGatewayRoutesAsync(ctx internal.Context, input *ec2.ExportTransitGatewayRoutesInput) (_result_0 *ec2stub.ExportTransitGatewayRoutesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ExportTransitGatewayRoutesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ExportTransitGatewayRoutesInput) *ec2stub.ExportTransitGatewayRoutesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ExportTransitGatewayRoutesFuture)
		}
	}

	return r0
}

// GetAssociatedEnclaveCertificateIamRoles provides a mock function.
func (_m *Mockec2clientstub) GetAssociatedEnclaveCertificateIamRoles(ctx internal.Context, input *ec2.GetAssociatedEnclaveCertificateIamRolesInput) (_result_0 *ec2.GetAssociatedEnclaveCertificateIamRolesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetAssociatedEnclaveCertificateIamRolesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput) *ec2.GetAssociatedEnclaveCertificateIamRolesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAssociatedEnclaveCertificateIamRolesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssociatedEnclaveCertificateIamRolesAsync provides a mock function.
func (_m *Mockec2clientstub) GetAssociatedEnclaveCertificateIamRolesAsync(ctx internal.Context, input *ec2.GetAssociatedEnclaveCertificateIamRolesInput) (_result_0 *ec2stub.GetAssociatedEnclaveCertificateIamRolesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetAssociatedEnclaveCertificateIamRolesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput) *ec2stub.GetAssociatedEnclaveCertificateIamRolesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetAssociatedEnclaveCertificateIamRolesFuture)
		}
	}

	return r0
}

// GetAssociatedIpv6PoolCidrs provides a mock function.
func (_m *Mockec2clientstub) GetAssociatedIpv6PoolCidrs(ctx internal.Context, input *ec2.GetAssociatedIpv6PoolCidrsInput) (_result_0 *ec2.GetAssociatedIpv6PoolCidrsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetAssociatedIpv6PoolCidrsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetAssociatedIpv6PoolCidrsInput) *ec2.GetAssociatedIpv6PoolCidrsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAssociatedIpv6PoolCidrsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetAssociatedIpv6PoolCidrsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssociatedIpv6PoolCidrsAsync provides a mock function.
func (_m *Mockec2clientstub) GetAssociatedIpv6PoolCidrsAsync(ctx internal.Context, input *ec2.GetAssociatedIpv6PoolCidrsInput) (_result_0 *ec2stub.GetAssociatedIpv6PoolCidrsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetAssociatedIpv6PoolCidrsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetAssociatedIpv6PoolCidrsInput) *ec2stub.GetAssociatedIpv6PoolCidrsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetAssociatedIpv6PoolCidrsFuture)
		}
	}

	return r0
}

// GetCapacityReservationUsage provides a mock function.
func (_m *Mockec2clientstub) GetCapacityReservationUsage(ctx internal.Context, input *ec2.GetCapacityReservationUsageInput) (_result_0 *ec2.GetCapacityReservationUsageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetCapacityReservationUsageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetCapacityReservationUsageInput) *ec2.GetCapacityReservationUsageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCapacityReservationUsageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetCapacityReservationUsageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCapacityReservationUsageAsync provides a mock function.
func (_m *Mockec2clientstub) GetCapacityReservationUsageAsync(ctx internal.Context, input *ec2.GetCapacityReservationUsageInput) (_result_0 *ec2stub.GetCapacityReservationUsageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetCapacityReservationUsageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetCapacityReservationUsageInput) *ec2stub.GetCapacityReservationUsageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetCapacityReservationUsageFuture)
		}
	}

	return r0
}

// GetCoipPoolUsage provides a mock function.
func (_m *Mockec2clientstub) GetCoipPoolUsage(ctx internal.Context, input *ec2.GetCoipPoolUsageInput) (_result_0 *ec2.GetCoipPoolUsageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetCoipPoolUsageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetCoipPoolUsageInput) *ec2.GetCoipPoolUsageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCoipPoolUsageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetCoipPoolUsageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCoipPoolUsageAsync provides a mock function.
func (_m *Mockec2clientstub) GetCoipPoolUsageAsync(ctx internal.Context, input *ec2.GetCoipPoolUsageInput) (_result_0 *ec2stub.GetCoipPoolUsageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetCoipPoolUsageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetCoipPoolUsageInput) *ec2stub.GetCoipPoolUsageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetCoipPoolUsageFuture)
		}
	}

	return r0
}

// GetConsoleOutput provides a mock function.
func (_m *Mockec2clientstub) GetConsoleOutput(ctx internal.Context, input *ec2.GetConsoleOutputInput) (_result_0 *ec2.GetConsoleOutputOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetConsoleOutputOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetConsoleOutputInput) *ec2.GetConsoleOutputOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetConsoleOutputOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetConsoleOutputInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConsoleOutputAsync provides a mock function.
func (_m *Mockec2clientstub) GetConsoleOutputAsync(ctx internal.Context, input *ec2.GetConsoleOutputInput) (_result_0 *ec2stub.GetConsoleOutputFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetConsoleOutputFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetConsoleOutputInput) *ec2stub.GetConsoleOutputFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetConsoleOutputFuture)
		}
	}

	return r0
}

// GetConsoleScreenshot provides a mock function.
func (_m *Mockec2clientstub) GetConsoleScreenshot(ctx internal.Context, input *ec2.GetConsoleScreenshotInput) (_result_0 *ec2.GetConsoleScreenshotOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetConsoleScreenshotOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetConsoleScreenshotInput) *ec2.GetConsoleScreenshotOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetConsoleScreenshotOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetConsoleScreenshotInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConsoleScreenshotAsync provides a mock function.
func (_m *Mockec2clientstub) GetConsoleScreenshotAsync(ctx internal.Context, input *ec2.GetConsoleScreenshotInput) (_result_0 *ec2stub.GetConsoleScreenshotFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetConsoleScreenshotFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetConsoleScreenshotInput) *ec2stub.GetConsoleScreenshotFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetConsoleScreenshotFuture)
		}
	}

	return r0
}

// GetDefaultCreditSpecification provides a mock function.
func (_m *Mockec2clientstub) GetDefaultCreditSpecification(ctx internal.Context, input *ec2.GetDefaultCreditSpecificationInput) (_result_0 *ec2.GetDefaultCreditSpecificationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetDefaultCreditSpecificationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetDefaultCreditSpecificationInput) *ec2.GetDefaultCreditSpecificationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetDefaultCreditSpecificationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetDefaultCreditSpecificationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultCreditSpecificationAsync provides a mock function.
func (_m *Mockec2clientstub) GetDefaultCreditSpecificationAsync(ctx internal.Context, input *ec2.GetDefaultCreditSpecificationInput) (_result_0 *ec2stub.GetDefaultCreditSpecificationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetDefaultCreditSpecificationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetDefaultCreditSpecificationInput) *ec2stub.GetDefaultCreditSpecificationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetDefaultCreditSpecificationFuture)
		}
	}

	return r0
}

// GetEbsDefaultKmsKeyId provides a mock function.
func (_m *Mockec2clientstub) GetEbsDefaultKmsKeyId(ctx internal.Context, input *ec2.GetEbsDefaultKmsKeyIdInput) (_result_0 *ec2.GetEbsDefaultKmsKeyIdOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetEbsDefaultKmsKeyIdOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetEbsDefaultKmsKeyIdInput) *ec2.GetEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetEbsDefaultKmsKeyIdOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetEbsDefaultKmsKeyIdInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEbsDefaultKmsKeyIdAsync provides a mock function.
func (_m *Mockec2clientstub) GetEbsDefaultKmsKeyIdAsync(ctx internal.Context, input *ec2.GetEbsDefaultKmsKeyIdInput) (_result_0 *ec2stub.GetEbsDefaultKmsKeyIdFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetEbsDefaultKmsKeyIdFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetEbsDefaultKmsKeyIdInput) *ec2stub.GetEbsDefaultKmsKeyIdFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetEbsDefaultKmsKeyIdFuture)
		}
	}

	return r0
}

// GetEbsEncryptionByDefault provides a mock function.
func (_m *Mockec2clientstub) GetEbsEncryptionByDefault(ctx internal.Context, input *ec2.GetEbsEncryptionByDefaultInput) (_result_0 *ec2.GetEbsEncryptionByDefaultOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetEbsEncryptionByDefaultOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetEbsEncryptionByDefaultInput) *ec2.GetEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetEbsEncryptionByDefaultOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetEbsEncryptionByDefaultInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEbsEncryptionByDefaultAsync provides a mock function.
func (_m *Mockec2clientstub) GetEbsEncryptionByDefaultAsync(ctx internal.Context, input *ec2.GetEbsEncryptionByDefaultInput) (_result_0 *ec2stub.GetEbsEncryptionByDefaultFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetEbsEncryptionByDefaultFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetEbsEncryptionByDefaultInput) *ec2stub.GetEbsEncryptionByDefaultFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetEbsEncryptionByDefaultFuture)
		}
	}

	return r0
}

// GetGroupsForCapacityReservation provides a mock function.
func (_m *Mockec2clientstub) GetGroupsForCapacityReservation(ctx internal.Context, input *ec2.GetGroupsForCapacityReservationInput) (_result_0 *ec2.GetGroupsForCapacityReservationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetGroupsForCapacityReservationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetGroupsForCapacityReservationInput) *ec2.GetGroupsForCapacityReservationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetGroupsForCapacityReservationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetGroupsForCapacityReservationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupsForCapacityReservationAsync provides a mock function.
func (_m *Mockec2clientstub) GetGroupsForCapacityReservationAsync(ctx internal.Context, input *ec2.GetGroupsForCapacityReservationInput) (_result_0 *ec2stub.GetGroupsForCapacityReservationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetGroupsForCapacityReservationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetGroupsForCapacityReservationInput) *ec2stub.GetGroupsForCapacityReservationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetGroupsForCapacityReservationFuture)
		}
	}

	return r0
}

// GetHostReservationPurchasePreview provides a mock function.
func (_m *Mockec2clientstub) GetHostReservationPurchasePreview(ctx internal.Context, input *ec2.GetHostReservationPurchasePreviewInput) (_result_0 *ec2.GetHostReservationPurchasePreviewOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetHostReservationPurchasePreviewOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetHostReservationPurchasePreviewInput) *ec2.GetHostReservationPurchasePreviewOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetHostReservationPurchasePreviewOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetHostReservationPurchasePreviewInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHostReservationPurchasePreviewAsync provides a mock function.
func (_m *Mockec2clientstub) GetHostReservationPurchasePreviewAsync(ctx internal.Context, input *ec2.GetHostReservationPurchasePreviewInput) (_result_0 *ec2stub.GetHostReservationPurchasePreviewFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetHostReservationPurchasePreviewFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetHostReservationPurchasePreviewInput) *ec2stub.GetHostReservationPurchasePreviewFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetHostReservationPurchasePreviewFuture)
		}
	}

	return r0
}

// GetLaunchTemplateData provides a mock function.
func (_m *Mockec2clientstub) GetLaunchTemplateData(ctx internal.Context, input *ec2.GetLaunchTemplateDataInput) (_result_0 *ec2.GetLaunchTemplateDataOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetLaunchTemplateDataOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetLaunchTemplateDataInput) *ec2.GetLaunchTemplateDataOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetLaunchTemplateDataOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetLaunchTemplateDataInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLaunchTemplateDataAsync provides a mock function.
func (_m *Mockec2clientstub) GetLaunchTemplateDataAsync(ctx internal.Context, input *ec2.GetLaunchTemplateDataInput) (_result_0 *ec2stub.GetLaunchTemplateDataFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetLaunchTemplateDataFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetLaunchTemplateDataInput) *ec2stub.GetLaunchTemplateDataFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetLaunchTemplateDataFuture)
		}
	}

	return r0
}

// GetManagedPrefixListAssociations provides a mock function.
func (_m *Mockec2clientstub) GetManagedPrefixListAssociations(ctx internal.Context, input *ec2.GetManagedPrefixListAssociationsInput) (_result_0 *ec2.GetManagedPrefixListAssociationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetManagedPrefixListAssociationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetManagedPrefixListAssociationsInput) *ec2.GetManagedPrefixListAssociationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetManagedPrefixListAssociationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetManagedPrefixListAssociationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagedPrefixListAssociationsAsync provides a mock function.
func (_m *Mockec2clientstub) GetManagedPrefixListAssociationsAsync(ctx internal.Context, input *ec2.GetManagedPrefixListAssociationsInput) (_result_0 *ec2stub.GetManagedPrefixListAssociationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetManagedPrefixListAssociationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetManagedPrefixListAssociationsInput) *ec2stub.GetManagedPrefixListAssociationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetManagedPrefixListAssociationsFuture)
		}
	}

	return r0
}

// GetManagedPrefixListEntries provides a mock function.
func (_m *Mockec2clientstub) GetManagedPrefixListEntries(ctx internal.Context, input *ec2.GetManagedPrefixListEntriesInput) (_result_0 *ec2.GetManagedPrefixListEntriesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetManagedPrefixListEntriesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetManagedPrefixListEntriesInput) *ec2.GetManagedPrefixListEntriesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetManagedPrefixListEntriesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetManagedPrefixListEntriesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagedPrefixListEntriesAsync provides a mock function.
func (_m *Mockec2clientstub) GetManagedPrefixListEntriesAsync(ctx internal.Context, input *ec2.GetManagedPrefixListEntriesInput) (_result_0 *ec2stub.GetManagedPrefixListEntriesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetManagedPrefixListEntriesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetManagedPrefixListEntriesInput) *ec2stub.GetManagedPrefixListEntriesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetManagedPrefixListEntriesFuture)
		}
	}

	return r0
}

// GetPasswordData provides a mock function.
func (_m *Mockec2clientstub) GetPasswordData(ctx internal.Context, input *ec2.GetPasswordDataInput) (_result_0 *ec2.GetPasswordDataOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetPasswordDataOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetPasswordDataInput) *ec2.GetPasswordDataOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetPasswordDataOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetPasswordDataInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPasswordDataAsync provides a mock function.
func (_m *Mockec2clientstub) GetPasswordDataAsync(ctx internal.Context, input *ec2.GetPasswordDataInput) (_result_0 *ec2stub.GetPasswordDataFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetPasswordDataFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetPasswordDataInput) *ec2stub.GetPasswordDataFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetPasswordDataFuture)
		}
	}

	return r0
}

// GetReservedInstancesExchangeQuote provides a mock function.
func (_m *Mockec2clientstub) GetReservedInstancesExchangeQuote(ctx internal.Context, input *ec2.GetReservedInstancesExchangeQuoteInput) (_result_0 *ec2.GetReservedInstancesExchangeQuoteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetReservedInstancesExchangeQuoteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetReservedInstancesExchangeQuoteInput) *ec2.GetReservedInstancesExchangeQuoteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetReservedInstancesExchangeQuoteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetReservedInstancesExchangeQuoteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReservedInstancesExchangeQuoteAsync provides a mock function.
func (_m *Mockec2clientstub) GetReservedInstancesExchangeQuoteAsync(ctx internal.Context, input *ec2.GetReservedInstancesExchangeQuoteInput) (_result_0 *ec2stub.GetReservedInstancesExchangeQuoteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetReservedInstancesExchangeQuoteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetReservedInstancesExchangeQuoteInput) *ec2stub.GetReservedInstancesExchangeQuoteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetReservedInstancesExchangeQuoteFuture)
		}
	}

	return r0
}

// GetTransitGatewayAttachmentPropagations provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayAttachmentPropagations(ctx internal.Context, input *ec2.GetTransitGatewayAttachmentPropagationsInput) (_result_0 *ec2.GetTransitGatewayAttachmentPropagationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetTransitGatewayAttachmentPropagationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput) *ec2.GetTransitGatewayAttachmentPropagationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayAttachmentPropagationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayAttachmentPropagationsAsync provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayAttachmentPropagationsAsync(ctx internal.Context, input *ec2.GetTransitGatewayAttachmentPropagationsInput) (_result_0 *ec2stub.GetTransitGatewayAttachmentPropagationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetTransitGatewayAttachmentPropagationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput) *ec2stub.GetTransitGatewayAttachmentPropagationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetTransitGatewayAttachmentPropagationsFuture)
		}
	}

	return r0
}

// GetTransitGatewayMulticastDomainAssociations provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayMulticastDomainAssociations(ctx internal.Context, input *ec2.GetTransitGatewayMulticastDomainAssociationsInput) (_result_0 *ec2.GetTransitGatewayMulticastDomainAssociationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetTransitGatewayMulticastDomainAssociationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput) *ec2.GetTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayMulticastDomainAssociationsAsync provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayMulticastDomainAssociationsAsync(ctx internal.Context, input *ec2.GetTransitGatewayMulticastDomainAssociationsInput) (_result_0 *ec2stub.GetTransitGatewayMulticastDomainAssociationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetTransitGatewayMulticastDomainAssociationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput) *ec2stub.GetTransitGatewayMulticastDomainAssociationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetTransitGatewayMulticastDomainAssociationsFuture)
		}
	}

	return r0
}

// GetTransitGatewayPrefixListReferences provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayPrefixListReferences(ctx internal.Context, input *ec2.GetTransitGatewayPrefixListReferencesInput) (_result_0 *ec2.GetTransitGatewayPrefixListReferencesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetTransitGatewayPrefixListReferencesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayPrefixListReferencesInput) *ec2.GetTransitGatewayPrefixListReferencesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayPrefixListReferencesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetTransitGatewayPrefixListReferencesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayPrefixListReferencesAsync provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayPrefixListReferencesAsync(ctx internal.Context, input *ec2.GetTransitGatewayPrefixListReferencesInput) (_result_0 *ec2stub.GetTransitGatewayPrefixListReferencesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetTransitGatewayPrefixListReferencesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayPrefixListReferencesInput) *ec2stub.GetTransitGatewayPrefixListReferencesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetTransitGatewayPrefixListReferencesFuture)
		}
	}

	return r0
}

// GetTransitGatewayRouteTableAssociations provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayRouteTableAssociations(ctx internal.Context, input *ec2.GetTransitGatewayRouteTableAssociationsInput) (_result_0 *ec2.GetTransitGatewayRouteTableAssociationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetTransitGatewayRouteTableAssociationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput) *ec2.GetTransitGatewayRouteTableAssociationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayRouteTableAssociationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayRouteTableAssociationsAsync provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayRouteTableAssociationsAsync(ctx internal.Context, input *ec2.GetTransitGatewayRouteTableAssociationsInput) (_result_0 *ec2stub.GetTransitGatewayRouteTableAssociationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetTransitGatewayRouteTableAssociationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput) *ec2stub.GetTransitGatewayRouteTableAssociationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetTransitGatewayRouteTableAssociationsFuture)
		}
	}

	return r0
}

// GetTransitGatewayRouteTablePropagations provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayRouteTablePropagations(ctx internal.Context, input *ec2.GetTransitGatewayRouteTablePropagationsInput) (_result_0 *ec2.GetTransitGatewayRouteTablePropagationsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.GetTransitGatewayRouteTablePropagationsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput) *ec2.GetTransitGatewayRouteTablePropagationsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayRouteTablePropagationsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayRouteTablePropagationsAsync provides a mock function.
func (_m *Mockec2clientstub) GetTransitGatewayRouteTablePropagationsAsync(ctx internal.Context, input *ec2.GetTransitGatewayRouteTablePropagationsInput) (_result_0 *ec2stub.GetTransitGatewayRouteTablePropagationsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.GetTransitGatewayRouteTablePropagationsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput) *ec2stub.GetTransitGatewayRouteTablePropagationsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.GetTransitGatewayRouteTablePropagationsFuture)
		}
	}

	return r0
}

// ImportClientVpnClientCertificateRevocationList provides a mock function.
func (_m *Mockec2clientstub) ImportClientVpnClientCertificateRevocationList(ctx internal.Context, input *ec2.ImportClientVpnClientCertificateRevocationListInput) (_result_0 *ec2.ImportClientVpnClientCertificateRevocationListOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ImportClientVpnClientCertificateRevocationListOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput) *ec2.ImportClientVpnClientCertificateRevocationListOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportClientVpnClientCertificateRevocationListOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportClientVpnClientCertificateRevocationListAsync provides a mock function.
func (_m *Mockec2clientstub) ImportClientVpnClientCertificateRevocationListAsync(ctx internal.Context, input *ec2.ImportClientVpnClientCertificateRevocationListInput) (_result_0 *ec2stub.ImportClientVpnClientCertificateRevocationListFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ImportClientVpnClientCertificateRevocationListFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput) *ec2stub.ImportClientVpnClientCertificateRevocationListFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ImportClientVpnClientCertificateRevocationListFuture)
		}
	}

	return r0
}

// ImportImage provides a mock function.
func (_m *Mockec2clientstub) ImportImage(ctx internal.Context, input *ec2.ImportImageInput) (_result_0 *ec2.ImportImageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ImportImageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportImageInput) *ec2.ImportImageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportImageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ImportImageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportImageAsync provides a mock function.
func (_m *Mockec2clientstub) ImportImageAsync(ctx internal.Context, input *ec2.ImportImageInput) (_result_0 *ec2stub.ImportImageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ImportImageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportImageInput) *ec2stub.ImportImageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ImportImageFuture)
		}
	}

	return r0
}

// ImportInstance provides a mock function.
func (_m *Mockec2clientstub) ImportInstance(ctx internal.Context, input *ec2.ImportInstanceInput) (_result_0 *ec2.ImportInstanceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ImportInstanceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportInstanceInput) *ec2.ImportInstanceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportInstanceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ImportInstanceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportInstanceAsync provides a mock function.
func (_m *Mockec2clientstub) ImportInstanceAsync(ctx internal.Context, input *ec2.ImportInstanceInput) (_result_0 *ec2stub.ImportInstanceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ImportInstanceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportInstanceInput) *ec2stub.ImportInstanceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ImportInstanceFuture)
		}
	}

	return r0
}

// ImportKeyPair provides a mock function.
func (_m *Mockec2clientstub) ImportKeyPair(ctx internal.Context, input *ec2.ImportKeyPairInput) (_result_0 *ec2.ImportKeyPairOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ImportKeyPairOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportKeyPairInput) *ec2.ImportKeyPairOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportKeyPairOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ImportKeyPairInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportKeyPairAsync provides a mock function.
func (_m *Mockec2clientstub) ImportKeyPairAsync(ctx internal.Context, input *ec2.ImportKeyPairInput) (_result_0 *ec2stub.ImportKeyPairFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ImportKeyPairFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportKeyPairInput) *ec2stub.ImportKeyPairFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ImportKeyPairFuture)
		}
	}

	return r0
}

// ImportSnapshot provides a mock function.
func (_m *Mockec2clientstub) ImportSnapshot(ctx internal.Context, input *ec2.ImportSnapshotInput) (_result_0 *ec2.ImportSnapshotOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ImportSnapshotOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportSnapshotInput) *ec2.ImportSnapshotOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportSnapshotOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ImportSnapshotInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportSnapshotAsync provides a mock function.
func (_m *Mockec2clientstub) ImportSnapshotAsync(ctx internal.Context, input *ec2.ImportSnapshotInput) (_result_0 *ec2stub.ImportSnapshotFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ImportSnapshotFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportSnapshotInput) *ec2stub.ImportSnapshotFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ImportSnapshotFuture)
		}
	}

	return r0
}

// ImportVolume provides a mock function.
func (_m *Mockec2clientstub) ImportVolume(ctx internal.Context, input *ec2.ImportVolumeInput) (_result_0 *ec2.ImportVolumeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ImportVolumeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportVolumeInput) *ec2.ImportVolumeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportVolumeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ImportVolumeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportVolumeAsync provides a mock function.
func (_m *Mockec2clientstub) ImportVolumeAsync(ctx internal.Context, input *ec2.ImportVolumeInput) (_result_0 *ec2stub.ImportVolumeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ImportVolumeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ImportVolumeInput) *ec2stub.ImportVolumeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ImportVolumeFuture)
		}
	}

	return r0
}

// ModifyAvailabilityZoneGroup provides a mock function.
func (_m *Mockec2clientstub) ModifyAvailabilityZoneGroup(ctx internal.Context, input *ec2.ModifyAvailabilityZoneGroupInput) (_result_0 *ec2.ModifyAvailabilityZoneGroupOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyAvailabilityZoneGroupOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyAvailabilityZoneGroupInput) *ec2.ModifyAvailabilityZoneGroupOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyAvailabilityZoneGroupOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyAvailabilityZoneGroupInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyAvailabilityZoneGroupAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyAvailabilityZoneGroupAsync(ctx internal.Context, input *ec2.ModifyAvailabilityZoneGroupInput) (_result_0 *ec2stub.ModifyAvailabilityZoneGroupFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyAvailabilityZoneGroupFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyAvailabilityZoneGroupInput) *ec2stub.ModifyAvailabilityZoneGroupFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyAvailabilityZoneGroupFuture)
		}
	}

	return r0
}

// ModifyCapacityReservation provides a mock function.
func (_m *Mockec2clientstub) ModifyCapacityReservation(ctx internal.Context, input *ec2.ModifyCapacityReservationInput) (_result_0 *ec2.ModifyCapacityReservationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyCapacityReservationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyCapacityReservationInput) *ec2.ModifyCapacityReservationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyCapacityReservationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyCapacityReservationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCapacityReservationAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyCapacityReservationAsync(ctx internal.Context, input *ec2.ModifyCapacityReservationInput) (_result_0 *ec2stub.ModifyCapacityReservationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyCapacityReservationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyCapacityReservationInput) *ec2stub.ModifyCapacityReservationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyCapacityReservationFuture)
		}
	}

	return r0
}

// ModifyClientVpnEndpoint provides a mock function.
func (_m *Mockec2clientstub) ModifyClientVpnEndpoint(ctx internal.Context, input *ec2.ModifyClientVpnEndpointInput) (_result_0 *ec2.ModifyClientVpnEndpointOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyClientVpnEndpointOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyClientVpnEndpointInput) *ec2.ModifyClientVpnEndpointOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyClientVpnEndpointOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyClientVpnEndpointInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClientVpnEndpointAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyClientVpnEndpointAsync(ctx internal.Context, input *ec2.ModifyClientVpnEndpointInput) (_result_0 *ec2stub.ModifyClientVpnEndpointFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyClientVpnEndpointFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyClientVpnEndpointInput) *ec2stub.ModifyClientVpnEndpointFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyClientVpnEndpointFuture)
		}
	}

	return r0
}

// ModifyDefaultCreditSpecification provides a mock function.
func (_m *Mockec2clientstub) ModifyDefaultCreditSpecification(ctx internal.Context, input *ec2.ModifyDefaultCreditSpecificationInput) (_result_0 *ec2.ModifyDefaultCreditSpecificationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyDefaultCreditSpecificationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyDefaultCreditSpecificationInput) *ec2.ModifyDefaultCreditSpecificationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyDefaultCreditSpecificationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyDefaultCreditSpecificationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyDefaultCreditSpecificationAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyDefaultCreditSpecificationAsync(ctx internal.Context, input *ec2.ModifyDefaultCreditSpecificationInput) (_result_0 *ec2stub.ModifyDefaultCreditSpecificationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyDefaultCreditSpecificationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyDefaultCreditSpecificationInput) *ec2stub.ModifyDefaultCreditSpecificationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyDefaultCreditSpecificationFuture)
		}
	}

	return r0
}

// ModifyEbsDefaultKmsKeyId provides a mock function.
func (_m *Mockec2clientstub) ModifyEbsDefaultKmsKeyId(ctx internal.Context, input *ec2.ModifyEbsDefaultKmsKeyIdInput) (_result_0 *ec2.ModifyEbsDefaultKmsKeyIdOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyEbsDefaultKmsKeyIdOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput) *ec2.ModifyEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyEbsDefaultKmsKeyIdOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyEbsDefaultKmsKeyIdAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyEbsDefaultKmsKeyIdAsync(ctx internal.Context, input *ec2.ModifyEbsDefaultKmsKeyIdInput) (_result_0 *ec2stub.ModifyEbsDefaultKmsKeyIdFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyEbsDefaultKmsKeyIdFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput) *ec2stub.ModifyEbsDefaultKmsKeyIdFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyEbsDefaultKmsKeyIdFuture)
		}
	}

	return r0
}

// ModifyFleet provides a mock function.
func (_m *Mockec2clientstub) ModifyFleet(ctx internal.Context, input *ec2.ModifyFleetInput) (_result_0 *ec2.ModifyFleetOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyFleetOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyFleetInput) *ec2.ModifyFleetOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyFleetOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyFleetInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyFleetAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyFleetAsync(ctx internal.Context, input *ec2.ModifyFleetInput) (_result_0 *ec2stub.ModifyFleetFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyFleetFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyFleetInput) *ec2stub.ModifyFleetFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyFleetFuture)
		}
	}

	return r0
}

// ModifyFpgaImageAttribute provides a mock function.
func (_m *Mockec2clientstub) ModifyFpgaImageAttribute(ctx internal.Context, input *ec2.ModifyFpgaImageAttributeInput) (_result_0 *ec2.ModifyFpgaImageAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyFpgaImageAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyFpgaImageAttributeInput) *ec2.ModifyFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyFpgaImageAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyFpgaImageAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyFpgaImageAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyFpgaImageAttributeAsync(ctx internal.Context, input *ec2.ModifyFpgaImageAttributeInput) (_result_0 *ec2stub.ModifyFpgaImageAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyFpgaImageAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyFpgaImageAttributeInput) *ec2stub.ModifyFpgaImageAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyFpgaImageAttributeFuture)
		}
	}

	return r0
}

// ModifyHosts provides a mock function.
func (_m *Mockec2clientstub) ModifyHosts(ctx internal.Context, input *ec2.ModifyHostsInput) (_result_0 *ec2.ModifyHostsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyHostsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyHostsInput) *ec2.ModifyHostsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyHostsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyHostsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyHostsAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyHostsAsync(ctx internal.Context, input *ec2.ModifyHostsInput) (_result_0 *ec2stub.ModifyHostsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyHostsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyHostsInput) *ec2stub.ModifyHostsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyHostsFuture)
		}
	}

	return r0
}

// ModifyIdFormat provides a mock function.
func (_m *Mockec2clientstub) ModifyIdFormat(ctx internal.Context, input *ec2.ModifyIdFormatInput) (_result_0 *ec2.ModifyIdFormatOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyIdFormatOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyIdFormatInput) *ec2.ModifyIdFormatOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIdFormatOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyIdFormatInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIdFormatAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyIdFormatAsync(ctx internal.Context, input *ec2.ModifyIdFormatInput) (_result_0 *ec2stub.ModifyIdFormatFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyIdFormatFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyIdFormatInput) *ec2stub.ModifyIdFormatFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyIdFormatFuture)
		}
	}

	return r0
}

// ModifyIdentityIdFormat provides a mock function.
func (_m *Mockec2clientstub) ModifyIdentityIdFormat(ctx internal.Context, input *ec2.ModifyIdentityIdFormatInput) (_result_0 *ec2.ModifyIdentityIdFormatOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyIdentityIdFormatOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyIdentityIdFormatInput) *ec2.ModifyIdentityIdFormatOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIdentityIdFormatOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyIdentityIdFormatInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIdentityIdFormatAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyIdentityIdFormatAsync(ctx internal.Context, input *ec2.ModifyIdentityIdFormatInput) (_result_0 *ec2stub.ModifyIdentityIdFormatFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyIdentityIdFormatFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyIdentityIdFormatInput) *ec2stub.ModifyIdentityIdFormatFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyIdentityIdFormatFuture)
		}
	}

	return r0
}

// ModifyImageAttribute provides a mock function.
func (_m *Mockec2clientstub) ModifyImageAttribute(ctx internal.Context, input *ec2.ModifyImageAttributeInput) (_result_0 *ec2.ModifyImageAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyImageAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyImageAttributeInput) *ec2.ModifyImageAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyImageAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyImageAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyImageAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyImageAttributeAsync(ctx internal.Context, input *ec2.ModifyImageAttributeInput) (_result_0 *ec2stub.ModifyImageAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyImageAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyImageAttributeInput) *ec2stub.ModifyImageAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyImageAttributeFuture)
		}
	}

	return r0
}

// ModifyInstanceAttribute provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceAttribute(ctx internal.Context, input *ec2.ModifyInstanceAttributeInput) (_result_0 *ec2.ModifyInstanceAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyInstanceAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceAttributeInput) *ec2.ModifyInstanceAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyInstanceAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceAttributeAsync(ctx internal.Context, input *ec2.ModifyInstanceAttributeInput) (_result_0 *ec2stub.ModifyInstanceAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyInstanceAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceAttributeInput) *ec2stub.ModifyInstanceAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyInstanceAttributeFuture)
		}
	}

	return r0
}

// ModifyInstanceCapacityReservationAttributes provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceCapacityReservationAttributes(ctx internal.Context, input *ec2.ModifyInstanceCapacityReservationAttributesInput) (_result_0 *ec2.ModifyInstanceCapacityReservationAttributesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyInstanceCapacityReservationAttributesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput) *ec2.ModifyInstanceCapacityReservationAttributesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceCapacityReservationAttributesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceCapacityReservationAttributesAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceCapacityReservationAttributesAsync(ctx internal.Context, input *ec2.ModifyInstanceCapacityReservationAttributesInput) (_result_0 *ec2stub.ModifyInstanceCapacityReservationAttributesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyInstanceCapacityReservationAttributesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput) *ec2stub.ModifyInstanceCapacityReservationAttributesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyInstanceCapacityReservationAttributesFuture)
		}
	}

	return r0
}

// ModifyInstanceCreditSpecification provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceCreditSpecification(ctx internal.Context, input *ec2.ModifyInstanceCreditSpecificationInput) (_result_0 *ec2.ModifyInstanceCreditSpecificationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyInstanceCreditSpecificationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceCreditSpecificationInput) *ec2.ModifyInstanceCreditSpecificationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceCreditSpecificationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyInstanceCreditSpecificationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceCreditSpecificationAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceCreditSpecificationAsync(ctx internal.Context, input *ec2.ModifyInstanceCreditSpecificationInput) (_result_0 *ec2stub.ModifyInstanceCreditSpecificationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyInstanceCreditSpecificationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceCreditSpecificationInput) *ec2stub.ModifyInstanceCreditSpecificationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyInstanceCreditSpecificationFuture)
		}
	}

	return r0
}

// ModifyInstanceEventStartTime provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceEventStartTime(ctx internal.Context, input *ec2.ModifyInstanceEventStartTimeInput) (_result_0 *ec2.ModifyInstanceEventStartTimeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyInstanceEventStartTimeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceEventStartTimeInput) *ec2.ModifyInstanceEventStartTimeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceEventStartTimeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyInstanceEventStartTimeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceEventStartTimeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceEventStartTimeAsync(ctx internal.Context, input *ec2.ModifyInstanceEventStartTimeInput) (_result_0 *ec2stub.ModifyInstanceEventStartTimeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyInstanceEventStartTimeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceEventStartTimeInput) *ec2stub.ModifyInstanceEventStartTimeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyInstanceEventStartTimeFuture)
		}
	}

	return r0
}

// ModifyInstanceMetadataOptions provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceMetadataOptions(ctx internal.Context, input *ec2.ModifyInstanceMetadataOptionsInput) (_result_0 *ec2.ModifyInstanceMetadataOptionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyInstanceMetadataOptionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceMetadataOptionsInput) *ec2.ModifyInstanceMetadataOptionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceMetadataOptionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyInstanceMetadataOptionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceMetadataOptionsAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyInstanceMetadataOptionsAsync(ctx internal.Context, input *ec2.ModifyInstanceMetadataOptionsInput) (_result_0 *ec2stub.ModifyInstanceMetadataOptionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyInstanceMetadataOptionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstanceMetadataOptionsInput) *ec2stub.ModifyInstanceMetadataOptionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyInstanceMetadataOptionsFuture)
		}
	}

	return r0
}

// ModifyInstancePlacement provides a mock function.
func (_m *Mockec2clientstub) ModifyInstancePlacement(ctx internal.Context, input *ec2.ModifyInstancePlacementInput) (_result_0 *ec2.ModifyInstancePlacementOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyInstancePlacementOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstancePlacementInput) *ec2.ModifyInstancePlacementOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstancePlacementOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyInstancePlacementInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstancePlacementAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyInstancePlacementAsync(ctx internal.Context, input *ec2.ModifyInstancePlacementInput) (_result_0 *ec2stub.ModifyInstancePlacementFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyInstancePlacementFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyInstancePlacementInput) *ec2stub.ModifyInstancePlacementFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyInstancePlacementFuture)
		}
	}

	return r0
}

// ModifyLaunchTemplate provides a mock function.
func (_m *Mockec2clientstub) ModifyLaunchTemplate(ctx internal.Context, input *ec2.ModifyLaunchTemplateInput) (_result_0 *ec2.ModifyLaunchTemplateOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyLaunchTemplateOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyLaunchTemplateInput) *ec2.ModifyLaunchTemplateOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyLaunchTemplateOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyLaunchTemplateInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyLaunchTemplateAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyLaunchTemplateAsync(ctx internal.Context, input *ec2.ModifyLaunchTemplateInput) (_result_0 *ec2stub.ModifyLaunchTemplateFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyLaunchTemplateFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyLaunchTemplateInput) *ec2stub.ModifyLaunchTemplateFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyLaunchTemplateFuture)
		}
	}

	return r0
}

// ModifyManagedPrefixList provides a mock function.
func (_m *Mockec2clientstub) ModifyManagedPrefixList(ctx internal.Context, input *ec2.ModifyManagedPrefixListInput) (_result_0 *ec2.ModifyManagedPrefixListOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyManagedPrefixListOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyManagedPrefixListInput) *ec2.ModifyManagedPrefixListOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyManagedPrefixListOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyManagedPrefixListInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyManagedPrefixListAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyManagedPrefixListAsync(ctx internal.Context, input *ec2.ModifyManagedPrefixListInput) (_result_0 *ec2stub.ModifyManagedPrefixListFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyManagedPrefixListFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyManagedPrefixListInput) *ec2stub.ModifyManagedPrefixListFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyManagedPrefixListFuture)
		}
	}

	return r0
}

// ModifyNetworkInterfaceAttribute provides a mock function.
func (_m *Mockec2clientstub) ModifyNetworkInterfaceAttribute(ctx internal.Context, input *ec2.ModifyNetworkInterfaceAttributeInput) (_result_0 *ec2.ModifyNetworkInterfaceAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyNetworkInterfaceAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyNetworkInterfaceAttributeInput) *ec2.ModifyNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyNetworkInterfaceAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyNetworkInterfaceAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyNetworkInterfaceAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyNetworkInterfaceAttributeAsync(ctx internal.Context, input *ec2.ModifyNetworkInterfaceAttributeInput) (_result_0 *ec2stub.ModifyNetworkInterfaceAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyNetworkInterfaceAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyNetworkInterfaceAttributeInput) *ec2stub.ModifyNetworkInterfaceAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyNetworkInterfaceAttributeFuture)
		}
	}

	return r0
}

// ModifyReservedInstances provides a mock function.
func (_m *Mockec2clientstub) ModifyReservedInstances(ctx internal.Context, input *ec2.ModifyReservedInstancesInput) (_result_0 *ec2.ModifyReservedInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyReservedInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyReservedInstancesInput) *ec2.ModifyReservedInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyReservedInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyReservedInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyReservedInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyReservedInstancesAsync(ctx internal.Context, input *ec2.ModifyReservedInstancesInput) (_result_0 *ec2stub.ModifyReservedInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyReservedInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyReservedInstancesInput) *ec2stub.ModifyReservedInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyReservedInstancesFuture)
		}
	}

	return r0
}

// ModifySnapshotAttribute provides a mock function.
func (_m *Mockec2clientstub) ModifySnapshotAttribute(ctx internal.Context, input *ec2.ModifySnapshotAttributeInput) (_result_0 *ec2.ModifySnapshotAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifySnapshotAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifySnapshotAttributeInput) *ec2.ModifySnapshotAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySnapshotAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifySnapshotAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySnapshotAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifySnapshotAttributeAsync(ctx internal.Context, input *ec2.ModifySnapshotAttributeInput) (_result_0 *ec2stub.ModifySnapshotAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifySnapshotAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifySnapshotAttributeInput) *ec2stub.ModifySnapshotAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifySnapshotAttributeFuture)
		}
	}

	return r0
}

// ModifySubnetAttribute provides a mock function.
func (_m *Mockec2clientstub) ModifySubnetAttribute(ctx internal.Context, input *ec2.ModifySubnetAttributeInput) (_result_0 *ec2.ModifySubnetAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifySubnetAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifySubnetAttributeInput) *ec2.ModifySubnetAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySubnetAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifySubnetAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySubnetAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifySubnetAttributeAsync(ctx internal.Context, input *ec2.ModifySubnetAttributeInput) (_result_0 *ec2stub.ModifySubnetAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifySubnetAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifySubnetAttributeInput) *ec2stub.ModifySubnetAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifySubnetAttributeFuture)
		}
	}

	return r0
}

// ModifyTrafficMirrorFilterNetworkServices provides a mock function.
func (_m *Mockec2clientstub) ModifyTrafficMirrorFilterNetworkServices(ctx internal.Context, input *ec2.ModifyTrafficMirrorFilterNetworkServicesInput) (_result_0 *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput) *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrafficMirrorFilterNetworkServicesAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyTrafficMirrorFilterNetworkServicesAsync(ctx internal.Context, input *ec2.ModifyTrafficMirrorFilterNetworkServicesInput) (_result_0 *ec2stub.ModifyTrafficMirrorFilterNetworkServicesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyTrafficMirrorFilterNetworkServicesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput) *ec2stub.ModifyTrafficMirrorFilterNetworkServicesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyTrafficMirrorFilterNetworkServicesFuture)
		}
	}

	return r0
}

// ModifyTrafficMirrorFilterRule provides a mock function.
func (_m *Mockec2clientstub) ModifyTrafficMirrorFilterRule(ctx internal.Context, input *ec2.ModifyTrafficMirrorFilterRuleInput) (_result_0 *ec2.ModifyTrafficMirrorFilterRuleOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyTrafficMirrorFilterRuleOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTrafficMirrorFilterRuleInput) *ec2.ModifyTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorFilterRuleOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyTrafficMirrorFilterRuleInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrafficMirrorFilterRuleAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyTrafficMirrorFilterRuleAsync(ctx internal.Context, input *ec2.ModifyTrafficMirrorFilterRuleInput) (_result_0 *ec2stub.ModifyTrafficMirrorFilterRuleFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyTrafficMirrorFilterRuleFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTrafficMirrorFilterRuleInput) *ec2stub.ModifyTrafficMirrorFilterRuleFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyTrafficMirrorFilterRuleFuture)
		}
	}

	return r0
}

// ModifyTrafficMirrorSession provides a mock function.
func (_m *Mockec2clientstub) ModifyTrafficMirrorSession(ctx internal.Context, input *ec2.ModifyTrafficMirrorSessionInput) (_result_0 *ec2.ModifyTrafficMirrorSessionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyTrafficMirrorSessionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTrafficMirrorSessionInput) *ec2.ModifyTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorSessionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyTrafficMirrorSessionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrafficMirrorSessionAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyTrafficMirrorSessionAsync(ctx internal.Context, input *ec2.ModifyTrafficMirrorSessionInput) (_result_0 *ec2stub.ModifyTrafficMirrorSessionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyTrafficMirrorSessionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTrafficMirrorSessionInput) *ec2stub.ModifyTrafficMirrorSessionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyTrafficMirrorSessionFuture)
		}
	}

	return r0
}

// ModifyTransitGateway provides a mock function.
func (_m *Mockec2clientstub) ModifyTransitGateway(ctx internal.Context, input *ec2.ModifyTransitGatewayInput) (_result_0 *ec2.ModifyTransitGatewayOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyTransitGatewayOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTransitGatewayInput) *ec2.ModifyTransitGatewayOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyTransitGatewayInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGatewayAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyTransitGatewayAsync(ctx internal.Context, input *ec2.ModifyTransitGatewayInput) (_result_0 *ec2stub.ModifyTransitGatewayFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyTransitGatewayFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTransitGatewayInput) *ec2stub.ModifyTransitGatewayFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyTransitGatewayFuture)
		}
	}

	return r0
}

// ModifyTransitGatewayPrefixListReference provides a mock function.
func (_m *Mockec2clientstub) ModifyTransitGatewayPrefixListReference(ctx internal.Context, input *ec2.ModifyTransitGatewayPrefixListReferenceInput) (_result_0 *ec2.ModifyTransitGatewayPrefixListReferenceOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyTransitGatewayPrefixListReferenceOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput) *ec2.ModifyTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayPrefixListReferenceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGatewayPrefixListReferenceAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyTransitGatewayPrefixListReferenceAsync(ctx internal.Context, input *ec2.ModifyTransitGatewayPrefixListReferenceInput) (_result_0 *ec2stub.ModifyTransitGatewayPrefixListReferenceFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyTransitGatewayPrefixListReferenceFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput) *ec2stub.ModifyTransitGatewayPrefixListReferenceFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyTransitGatewayPrefixListReferenceFuture)
		}
	}

	return r0
}

// ModifyTransitGatewayVpcAttachment provides a mock function.
func (_m *Mockec2clientstub) ModifyTransitGatewayVpcAttachment(ctx internal.Context, input *ec2.ModifyTransitGatewayVpcAttachmentInput) (_result_0 *ec2.ModifyTransitGatewayVpcAttachmentOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyTransitGatewayVpcAttachmentOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput) *ec2.ModifyTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayVpcAttachmentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGatewayVpcAttachmentAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyTransitGatewayVpcAttachmentAsync(ctx internal.Context, input *ec2.ModifyTransitGatewayVpcAttachmentInput) (_result_0 *ec2stub.ModifyTransitGatewayVpcAttachmentFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyTransitGatewayVpcAttachmentFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput) *ec2stub.ModifyTransitGatewayVpcAttachmentFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyTransitGatewayVpcAttachmentFuture)
		}
	}

	return r0
}

// ModifyVolume provides a mock function.
func (_m *Mockec2clientstub) ModifyVolume(ctx internal.Context, input *ec2.ModifyVolumeInput) (_result_0 *ec2.ModifyVolumeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVolumeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVolumeInput) *ec2.ModifyVolumeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVolumeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVolumeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVolumeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVolumeAsync(ctx internal.Context, input *ec2.ModifyVolumeInput) (_result_0 *ec2stub.ModifyVolumeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVolumeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVolumeInput) *ec2stub.ModifyVolumeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVolumeFuture)
		}
	}

	return r0
}

// ModifyVolumeAttribute provides a mock function.
func (_m *Mockec2clientstub) ModifyVolumeAttribute(ctx internal.Context, input *ec2.ModifyVolumeAttributeInput) (_result_0 *ec2.ModifyVolumeAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVolumeAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVolumeAttributeInput) *ec2.ModifyVolumeAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVolumeAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVolumeAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVolumeAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVolumeAttributeAsync(ctx internal.Context, input *ec2.ModifyVolumeAttributeInput) (_result_0 *ec2stub.ModifyVolumeAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVolumeAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVolumeAttributeInput) *ec2stub.ModifyVolumeAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVolumeAttributeFuture)
		}
	}

	return r0
}

// ModifyVpcAttribute provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcAttribute(ctx internal.Context, input *ec2.ModifyVpcAttributeInput) (_result_0 *ec2.ModifyVpcAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpcAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcAttributeInput) *ec2.ModifyVpcAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpcAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcAttributeAsync(ctx internal.Context, input *ec2.ModifyVpcAttributeInput) (_result_0 *ec2stub.ModifyVpcAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpcAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcAttributeInput) *ec2stub.ModifyVpcAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpcAttributeFuture)
		}
	}

	return r0
}

// ModifyVpcEndpoint provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcEndpoint(ctx internal.Context, input *ec2.ModifyVpcEndpointInput) (_result_0 *ec2.ModifyVpcEndpointOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpcEndpointOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcEndpointInput) *ec2.ModifyVpcEndpointOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpcEndpointInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcEndpointAsync(ctx internal.Context, input *ec2.ModifyVpcEndpointInput) (_result_0 *ec2stub.ModifyVpcEndpointFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpcEndpointFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcEndpointInput) *ec2stub.ModifyVpcEndpointFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpcEndpointFuture)
		}
	}

	return r0
}

// ModifyVpcEndpointConnectionNotification provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcEndpointConnectionNotification(ctx internal.Context, input *ec2.ModifyVpcEndpointConnectionNotificationInput) (_result_0 *ec2.ModifyVpcEndpointConnectionNotificationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpcEndpointConnectionNotificationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput) *ec2.ModifyVpcEndpointConnectionNotificationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointConnectionNotificationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointConnectionNotificationAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcEndpointConnectionNotificationAsync(ctx internal.Context, input *ec2.ModifyVpcEndpointConnectionNotificationInput) (_result_0 *ec2stub.ModifyVpcEndpointConnectionNotificationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpcEndpointConnectionNotificationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput) *ec2stub.ModifyVpcEndpointConnectionNotificationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpcEndpointConnectionNotificationFuture)
		}
	}

	return r0
}

// ModifyVpcEndpointServiceConfiguration provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcEndpointServiceConfiguration(ctx internal.Context, input *ec2.ModifyVpcEndpointServiceConfigurationInput) (_result_0 *ec2.ModifyVpcEndpointServiceConfigurationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpcEndpointServiceConfigurationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput) *ec2.ModifyVpcEndpointServiceConfigurationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServiceConfigurationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointServiceConfigurationAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcEndpointServiceConfigurationAsync(ctx internal.Context, input *ec2.ModifyVpcEndpointServiceConfigurationInput) (_result_0 *ec2stub.ModifyVpcEndpointServiceConfigurationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpcEndpointServiceConfigurationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput) *ec2stub.ModifyVpcEndpointServiceConfigurationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpcEndpointServiceConfigurationFuture)
		}
	}

	return r0
}

// ModifyVpcEndpointServicePermissions provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcEndpointServicePermissions(ctx internal.Context, input *ec2.ModifyVpcEndpointServicePermissionsInput) (_result_0 *ec2.ModifyVpcEndpointServicePermissionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpcEndpointServicePermissionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcEndpointServicePermissionsInput) *ec2.ModifyVpcEndpointServicePermissionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServicePermissionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpcEndpointServicePermissionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointServicePermissionsAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcEndpointServicePermissionsAsync(ctx internal.Context, input *ec2.ModifyVpcEndpointServicePermissionsInput) (_result_0 *ec2stub.ModifyVpcEndpointServicePermissionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpcEndpointServicePermissionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcEndpointServicePermissionsInput) *ec2stub.ModifyVpcEndpointServicePermissionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpcEndpointServicePermissionsFuture)
		}
	}

	return r0
}

// ModifyVpcPeeringConnectionOptions provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcPeeringConnectionOptions(ctx internal.Context, input *ec2.ModifyVpcPeeringConnectionOptionsInput) (_result_0 *ec2.ModifyVpcPeeringConnectionOptionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpcPeeringConnectionOptionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput) *ec2.ModifyVpcPeeringConnectionOptionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcPeeringConnectionOptionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcPeeringConnectionOptionsAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcPeeringConnectionOptionsAsync(ctx internal.Context, input *ec2.ModifyVpcPeeringConnectionOptionsInput) (_result_0 *ec2stub.ModifyVpcPeeringConnectionOptionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpcPeeringConnectionOptionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput) *ec2stub.ModifyVpcPeeringConnectionOptionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpcPeeringConnectionOptionsFuture)
		}
	}

	return r0
}

// ModifyVpcTenancy provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcTenancy(ctx internal.Context, input *ec2.ModifyVpcTenancyInput) (_result_0 *ec2.ModifyVpcTenancyOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpcTenancyOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcTenancyInput) *ec2.ModifyVpcTenancyOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcTenancyOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpcTenancyInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcTenancyAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpcTenancyAsync(ctx internal.Context, input *ec2.ModifyVpcTenancyInput) (_result_0 *ec2stub.ModifyVpcTenancyFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpcTenancyFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpcTenancyInput) *ec2stub.ModifyVpcTenancyFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpcTenancyFuture)
		}
	}

	return r0
}

// ModifyVpnConnection provides a mock function.
func (_m *Mockec2clientstub) ModifyVpnConnection(ctx internal.Context, input *ec2.ModifyVpnConnectionInput) (_result_0 *ec2.ModifyVpnConnectionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpnConnectionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpnConnectionInput) *ec2.ModifyVpnConnectionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnConnectionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpnConnectionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnConnectionAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpnConnectionAsync(ctx internal.Context, input *ec2.ModifyVpnConnectionInput) (_result_0 *ec2stub.ModifyVpnConnectionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpnConnectionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpnConnectionInput) *ec2stub.ModifyVpnConnectionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpnConnectionFuture)
		}
	}

	return r0
}

// ModifyVpnConnectionOptions provides a mock function.
func (_m *Mockec2clientstub) ModifyVpnConnectionOptions(ctx internal.Context, input *ec2.ModifyVpnConnectionOptionsInput) (_result_0 *ec2.ModifyVpnConnectionOptionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpnConnectionOptionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpnConnectionOptionsInput) *ec2.ModifyVpnConnectionOptionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnConnectionOptionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpnConnectionOptionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnConnectionOptionsAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpnConnectionOptionsAsync(ctx internal.Context, input *ec2.ModifyVpnConnectionOptionsInput) (_result_0 *ec2stub.ModifyVpnConnectionOptionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpnConnectionOptionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpnConnectionOptionsInput) *ec2stub.ModifyVpnConnectionOptionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpnConnectionOptionsFuture)
		}
	}

	return r0
}

// ModifyVpnTunnelCertificate provides a mock function.
func (_m *Mockec2clientstub) ModifyVpnTunnelCertificate(ctx internal.Context, input *ec2.ModifyVpnTunnelCertificateInput) (_result_0 *ec2.ModifyVpnTunnelCertificateOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpnTunnelCertificateOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpnTunnelCertificateInput) *ec2.ModifyVpnTunnelCertificateOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnTunnelCertificateOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpnTunnelCertificateInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnTunnelCertificateAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpnTunnelCertificateAsync(ctx internal.Context, input *ec2.ModifyVpnTunnelCertificateInput) (_result_0 *ec2stub.ModifyVpnTunnelCertificateFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpnTunnelCertificateFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpnTunnelCertificateInput) *ec2stub.ModifyVpnTunnelCertificateFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpnTunnelCertificateFuture)
		}
	}

	return r0
}

// ModifyVpnTunnelOptions provides a mock function.
func (_m *Mockec2clientstub) ModifyVpnTunnelOptions(ctx internal.Context, input *ec2.ModifyVpnTunnelOptionsInput) (_result_0 *ec2.ModifyVpnTunnelOptionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ModifyVpnTunnelOptionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpnTunnelOptionsInput) *ec2.ModifyVpnTunnelOptionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnTunnelOptionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ModifyVpnTunnelOptionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnTunnelOptionsAsync provides a mock function.
func (_m *Mockec2clientstub) ModifyVpnTunnelOptionsAsync(ctx internal.Context, input *ec2.ModifyVpnTunnelOptionsInput) (_result_0 *ec2stub.ModifyVpnTunnelOptionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ModifyVpnTunnelOptionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ModifyVpnTunnelOptionsInput) *ec2stub.ModifyVpnTunnelOptionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ModifyVpnTunnelOptionsFuture)
		}
	}

	return r0
}

// MonitorInstances provides a mock function.
func (_m *Mockec2clientstub) MonitorInstances(ctx internal.Context, input *ec2.MonitorInstancesInput) (_result_0 *ec2.MonitorInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.MonitorInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.MonitorInstancesInput) *ec2.MonitorInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MonitorInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.MonitorInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MonitorInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) MonitorInstancesAsync(ctx internal.Context, input *ec2.MonitorInstancesInput) (_result_0 *ec2stub.MonitorInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.MonitorInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.MonitorInstancesInput) *ec2stub.MonitorInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.MonitorInstancesFuture)
		}
	}

	return r0
}

// MoveAddressToVpc provides a mock function.
func (_m *Mockec2clientstub) MoveAddressToVpc(ctx internal.Context, input *ec2.MoveAddressToVpcInput) (_result_0 *ec2.MoveAddressToVpcOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.MoveAddressToVpcOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.MoveAddressToVpcInput) *ec2.MoveAddressToVpcOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MoveAddressToVpcOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.MoveAddressToVpcInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MoveAddressToVpcAsync provides a mock function.
func (_m *Mockec2clientstub) MoveAddressToVpcAsync(ctx internal.Context, input *ec2.MoveAddressToVpcInput) (_result_0 *ec2stub.MoveAddressToVpcFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.MoveAddressToVpcFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.MoveAddressToVpcInput) *ec2stub.MoveAddressToVpcFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.MoveAddressToVpcFuture)
		}
	}

	return r0
}

// ProvisionByoipCidr provides a mock function.
func (_m *Mockec2clientstub) ProvisionByoipCidr(ctx internal.Context, input *ec2.ProvisionByoipCidrInput) (_result_0 *ec2.ProvisionByoipCidrOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ProvisionByoipCidrOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ProvisionByoipCidrInput) *ec2.ProvisionByoipCidrOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionByoipCidrOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ProvisionByoipCidrInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProvisionByoipCidrAsync provides a mock function.
func (_m *Mockec2clientstub) ProvisionByoipCidrAsync(ctx internal.Context, input *ec2.ProvisionByoipCidrInput) (_result_0 *ec2stub.ProvisionByoipCidrFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ProvisionByoipCidrFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ProvisionByoipCidrInput) *ec2stub.ProvisionByoipCidrFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ProvisionByoipCidrFuture)
		}
	}

	return r0
}

// PurchaseHostReservation provides a mock function.
func (_m *Mockec2clientstub) PurchaseHostReservation(ctx internal.Context, input *ec2.PurchaseHostReservationInput) (_result_0 *ec2.PurchaseHostReservationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.PurchaseHostReservationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.PurchaseHostReservationInput) *ec2.PurchaseHostReservationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseHostReservationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.PurchaseHostReservationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseHostReservationAsync provides a mock function.
func (_m *Mockec2clientstub) PurchaseHostReservationAsync(ctx internal.Context, input *ec2.PurchaseHostReservationInput) (_result_0 *ec2stub.PurchaseHostReservationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.PurchaseHostReservationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.PurchaseHostReservationInput) *ec2stub.PurchaseHostReservationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.PurchaseHostReservationFuture)
		}
	}

	return r0
}

// PurchaseReservedInstancesOffering provides a mock function.
func (_m *Mockec2clientstub) PurchaseReservedInstancesOffering(ctx internal.Context, input *ec2.PurchaseReservedInstancesOfferingInput) (_result_0 *ec2.PurchaseReservedInstancesOfferingOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.PurchaseReservedInstancesOfferingOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.PurchaseReservedInstancesOfferingInput) *ec2.PurchaseReservedInstancesOfferingOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseReservedInstancesOfferingOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.PurchaseReservedInstancesOfferingInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseReservedInstancesOfferingAsync provides a mock function.
func (_m *Mockec2clientstub) PurchaseReservedInstancesOfferingAsync(ctx internal.Context, input *ec2.PurchaseReservedInstancesOfferingInput) (_result_0 *ec2stub.PurchaseReservedInstancesOfferingFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.PurchaseReservedInstancesOfferingFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.PurchaseReservedInstancesOfferingInput) *ec2stub.PurchaseReservedInstancesOfferingFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.PurchaseReservedInstancesOfferingFuture)
		}
	}

	return r0
}

// PurchaseScheduledInstances provides a mock function.
func (_m *Mockec2clientstub) PurchaseScheduledInstances(ctx internal.Context, input *ec2.PurchaseScheduledInstancesInput) (_result_0 *ec2.PurchaseScheduledInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.PurchaseScheduledInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.PurchaseScheduledInstancesInput) *ec2.PurchaseScheduledInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseScheduledInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.PurchaseScheduledInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseScheduledInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) PurchaseScheduledInstancesAsync(ctx internal.Context, input *ec2.PurchaseScheduledInstancesInput) (_result_0 *ec2stub.PurchaseScheduledInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.PurchaseScheduledInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.PurchaseScheduledInstancesInput) *ec2stub.PurchaseScheduledInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.PurchaseScheduledInstancesFuture)
		}
	}

	return r0
}

// RebootInstances provides a mock function.
func (_m *Mockec2clientstub) RebootInstances(ctx internal.Context, input *ec2.RebootInstancesInput) (_result_0 *ec2.RebootInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RebootInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RebootInstancesInput) *ec2.RebootInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RebootInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RebootInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebootInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) RebootInstancesAsync(ctx internal.Context, input *ec2.RebootInstancesInput) (_result_0 *ec2stub.RebootInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RebootInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RebootInstancesInput) *ec2stub.RebootInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RebootInstancesFuture)
		}
	}

	return r0
}

// RegisterImage provides a mock function.
func (_m *Mockec2clientstub) RegisterImage(ctx internal.Context, input *ec2.RegisterImageInput) (_result_0 *ec2.RegisterImageOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RegisterImageOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RegisterImageInput) *ec2.RegisterImageOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterImageOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RegisterImageInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterImageAsync provides a mock function.
func (_m *Mockec2clientstub) RegisterImageAsync(ctx internal.Context, input *ec2.RegisterImageInput) (_result_0 *ec2stub.RegisterImageFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RegisterImageFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RegisterImageInput) *ec2stub.RegisterImageFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RegisterImageFuture)
		}
	}

	return r0
}

// RegisterInstanceEventNotificationAttributes provides a mock function.
func (_m *Mockec2clientstub) RegisterInstanceEventNotificationAttributes(ctx internal.Context, input *ec2.RegisterInstanceEventNotificationAttributesInput) (_result_0 *ec2.RegisterInstanceEventNotificationAttributesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RegisterInstanceEventNotificationAttributesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RegisterInstanceEventNotificationAttributesInput) *ec2.RegisterInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterInstanceEventNotificationAttributesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RegisterInstanceEventNotificationAttributesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterInstanceEventNotificationAttributesAsync provides a mock function.
func (_m *Mockec2clientstub) RegisterInstanceEventNotificationAttributesAsync(ctx internal.Context, input *ec2.RegisterInstanceEventNotificationAttributesInput) (_result_0 *ec2stub.RegisterInstanceEventNotificationAttributesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RegisterInstanceEventNotificationAttributesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RegisterInstanceEventNotificationAttributesInput) *ec2stub.RegisterInstanceEventNotificationAttributesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RegisterInstanceEventNotificationAttributesFuture)
		}
	}

	return r0
}

// RegisterTransitGatewayMulticastGroupMembers provides a mock function.
func (_m *Mockec2clientstub) RegisterTransitGatewayMulticastGroupMembers(ctx internal.Context, input *ec2.RegisterTransitGatewayMulticastGroupMembersInput) (_result_0 *ec2.RegisterTransitGatewayMulticastGroupMembersOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RegisterTransitGatewayMulticastGroupMembersOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput) *ec2.RegisterTransitGatewayMulticastGroupMembersOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterTransitGatewayMulticastGroupMembersOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterTransitGatewayMulticastGroupMembersAsync provides a mock function.
func (_m *Mockec2clientstub) RegisterTransitGatewayMulticastGroupMembersAsync(ctx internal.Context, input *ec2.RegisterTransitGatewayMulticastGroupMembersInput) (_result_0 *ec2stub.RegisterTransitGatewayMulticastGroupMembersFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RegisterTransitGatewayMulticastGroupMembersFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput) *ec2stub.RegisterTransitGatewayMulticastGroupMembersFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RegisterTransitGatewayMulticastGroupMembersFuture)
		}
	}

	return r0
}

// RegisterTransitGatewayMulticastGroupSources provides a mock function.
func (_m *Mockec2clientstub) RegisterTransitGatewayMulticastGroupSources(ctx internal.Context, input *ec2.RegisterTransitGatewayMulticastGroupSourcesInput) (_result_0 *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput) *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterTransitGatewayMulticastGroupSourcesAsync provides a mock function.
func (_m *Mockec2clientstub) RegisterTransitGatewayMulticastGroupSourcesAsync(ctx internal.Context, input *ec2.RegisterTransitGatewayMulticastGroupSourcesInput) (_result_0 *ec2stub.RegisterTransitGatewayMulticastGroupSourcesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RegisterTransitGatewayMulticastGroupSourcesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput) *ec2stub.RegisterTransitGatewayMulticastGroupSourcesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RegisterTransitGatewayMulticastGroupSourcesFuture)
		}
	}

	return r0
}

// RejectTransitGatewayPeeringAttachment provides a mock function.
func (_m *Mockec2clientstub) RejectTransitGatewayPeeringAttachment(ctx internal.Context, input *ec2.RejectTransitGatewayPeeringAttachmentInput) (_result_0 *ec2.RejectTransitGatewayPeeringAttachmentOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RejectTransitGatewayPeeringAttachmentOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput) *ec2.RejectTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayPeeringAttachmentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectTransitGatewayPeeringAttachmentAsync provides a mock function.
func (_m *Mockec2clientstub) RejectTransitGatewayPeeringAttachmentAsync(ctx internal.Context, input *ec2.RejectTransitGatewayPeeringAttachmentInput) (_result_0 *ec2stub.RejectTransitGatewayPeeringAttachmentFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RejectTransitGatewayPeeringAttachmentFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput) *ec2stub.RejectTransitGatewayPeeringAttachmentFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RejectTransitGatewayPeeringAttachmentFuture)
		}
	}

	return r0
}

// RejectTransitGatewayVpcAttachment provides a mock function.
func (_m *Mockec2clientstub) RejectTransitGatewayVpcAttachment(ctx internal.Context, input *ec2.RejectTransitGatewayVpcAttachmentInput) (_result_0 *ec2.RejectTransitGatewayVpcAttachmentOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RejectTransitGatewayVpcAttachmentOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RejectTransitGatewayVpcAttachmentInput) *ec2.RejectTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayVpcAttachmentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RejectTransitGatewayVpcAttachmentInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectTransitGatewayVpcAttachmentAsync provides a mock function.
func (_m *Mockec2clientstub) RejectTransitGatewayVpcAttachmentAsync(ctx internal.Context, input *ec2.RejectTransitGatewayVpcAttachmentInput) (_result_0 *ec2stub.RejectTransitGatewayVpcAttachmentFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RejectTransitGatewayVpcAttachmentFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RejectTransitGatewayVpcAttachmentInput) *ec2stub.RejectTransitGatewayVpcAttachmentFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RejectTransitGatewayVpcAttachmentFuture)
		}
	}

	return r0
}

// RejectVpcEndpointConnections provides a mock function.
func (_m *Mockec2clientstub) RejectVpcEndpointConnections(ctx internal.Context, input *ec2.RejectVpcEndpointConnectionsInput) (_result_0 *ec2.RejectVpcEndpointConnectionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RejectVpcEndpointConnectionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RejectVpcEndpointConnectionsInput) *ec2.RejectVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectVpcEndpointConnectionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RejectVpcEndpointConnectionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectVpcEndpointConnectionsAsync provides a mock function.
func (_m *Mockec2clientstub) RejectVpcEndpointConnectionsAsync(ctx internal.Context, input *ec2.RejectVpcEndpointConnectionsInput) (_result_0 *ec2stub.RejectVpcEndpointConnectionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RejectVpcEndpointConnectionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RejectVpcEndpointConnectionsInput) *ec2stub.RejectVpcEndpointConnectionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RejectVpcEndpointConnectionsFuture)
		}
	}

	return r0
}

// RejectVpcPeeringConnection provides a mock function.
func (_m *Mockec2clientstub) RejectVpcPeeringConnection(ctx internal.Context, input *ec2.RejectVpcPeeringConnectionInput) (_result_0 *ec2.RejectVpcPeeringConnectionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RejectVpcPeeringConnectionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RejectVpcPeeringConnectionInput) *ec2.RejectVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectVpcPeeringConnectionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RejectVpcPeeringConnectionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectVpcPeeringConnectionAsync provides a mock function.
func (_m *Mockec2clientstub) RejectVpcPeeringConnectionAsync(ctx internal.Context, input *ec2.RejectVpcPeeringConnectionInput) (_result_0 *ec2stub.RejectVpcPeeringConnectionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RejectVpcPeeringConnectionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RejectVpcPeeringConnectionInput) *ec2stub.RejectVpcPeeringConnectionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RejectVpcPeeringConnectionFuture)
		}
	}

	return r0
}

// ReleaseAddress provides a mock function.
func (_m *Mockec2clientstub) ReleaseAddress(ctx internal.Context, input *ec2.ReleaseAddressInput) (_result_0 *ec2.ReleaseAddressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ReleaseAddressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReleaseAddressInput) *ec2.ReleaseAddressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseAddressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ReleaseAddressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseAddressAsync provides a mock function.
func (_m *Mockec2clientstub) ReleaseAddressAsync(ctx internal.Context, input *ec2.ReleaseAddressInput) (_result_0 *ec2stub.ReleaseAddressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ReleaseAddressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReleaseAddressInput) *ec2stub.ReleaseAddressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ReleaseAddressFuture)
		}
	}

	return r0
}

// ReleaseHosts provides a mock function.
func (_m *Mockec2clientstub) ReleaseHosts(ctx internal.Context, input *ec2.ReleaseHostsInput) (_result_0 *ec2.ReleaseHostsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ReleaseHostsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReleaseHostsInput) *ec2.ReleaseHostsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseHostsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ReleaseHostsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseHostsAsync provides a mock function.
func (_m *Mockec2clientstub) ReleaseHostsAsync(ctx internal.Context, input *ec2.ReleaseHostsInput) (_result_0 *ec2stub.ReleaseHostsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ReleaseHostsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReleaseHostsInput) *ec2stub.ReleaseHostsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ReleaseHostsFuture)
		}
	}

	return r0
}

// ReplaceIamInstanceProfileAssociation provides a mock function.
func (_m *Mockec2clientstub) ReplaceIamInstanceProfileAssociation(ctx internal.Context, input *ec2.ReplaceIamInstanceProfileAssociationInput) (_result_0 *ec2.ReplaceIamInstanceProfileAssociationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ReplaceIamInstanceProfileAssociationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceIamInstanceProfileAssociationInput) *ec2.ReplaceIamInstanceProfileAssociationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceIamInstanceProfileAssociationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ReplaceIamInstanceProfileAssociationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceIamInstanceProfileAssociationAsync provides a mock function.
func (_m *Mockec2clientstub) ReplaceIamInstanceProfileAssociationAsync(ctx internal.Context, input *ec2.ReplaceIamInstanceProfileAssociationInput) (_result_0 *ec2stub.ReplaceIamInstanceProfileAssociationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ReplaceIamInstanceProfileAssociationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceIamInstanceProfileAssociationInput) *ec2stub.ReplaceIamInstanceProfileAssociationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ReplaceIamInstanceProfileAssociationFuture)
		}
	}

	return r0
}

// ReplaceNetworkAclAssociation provides a mock function.
func (_m *Mockec2clientstub) ReplaceNetworkAclAssociation(ctx internal.Context, input *ec2.ReplaceNetworkAclAssociationInput) (_result_0 *ec2.ReplaceNetworkAclAssociationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ReplaceNetworkAclAssociationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceNetworkAclAssociationInput) *ec2.ReplaceNetworkAclAssociationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceNetworkAclAssociationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ReplaceNetworkAclAssociationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceNetworkAclAssociationAsync provides a mock function.
func (_m *Mockec2clientstub) ReplaceNetworkAclAssociationAsync(ctx internal.Context, input *ec2.ReplaceNetworkAclAssociationInput) (_result_0 *ec2stub.ReplaceNetworkAclAssociationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ReplaceNetworkAclAssociationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceNetworkAclAssociationInput) *ec2stub.ReplaceNetworkAclAssociationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ReplaceNetworkAclAssociationFuture)
		}
	}

	return r0
}

// ReplaceNetworkAclEntry provides a mock function.
func (_m *Mockec2clientstub) ReplaceNetworkAclEntry(ctx internal.Context, input *ec2.ReplaceNetworkAclEntryInput) (_result_0 *ec2.ReplaceNetworkAclEntryOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ReplaceNetworkAclEntryOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceNetworkAclEntryInput) *ec2.ReplaceNetworkAclEntryOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceNetworkAclEntryOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ReplaceNetworkAclEntryInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceNetworkAclEntryAsync provides a mock function.
func (_m *Mockec2clientstub) ReplaceNetworkAclEntryAsync(ctx internal.Context, input *ec2.ReplaceNetworkAclEntryInput) (_result_0 *ec2stub.ReplaceNetworkAclEntryFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ReplaceNetworkAclEntryFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceNetworkAclEntryInput) *ec2stub.ReplaceNetworkAclEntryFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ReplaceNetworkAclEntryFuture)
		}
	}

	return r0
}

// ReplaceRoute provides a mock function.
func (_m *Mockec2clientstub) ReplaceRoute(ctx internal.Context, input *ec2.ReplaceRouteInput) (_result_0 *ec2.ReplaceRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ReplaceRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceRouteInput) *ec2.ReplaceRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ReplaceRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceRouteAsync provides a mock function.
func (_m *Mockec2clientstub) ReplaceRouteAsync(ctx internal.Context, input *ec2.ReplaceRouteInput) (_result_0 *ec2stub.ReplaceRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ReplaceRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceRouteInput) *ec2stub.ReplaceRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ReplaceRouteFuture)
		}
	}

	return r0
}

// ReplaceRouteTableAssociation provides a mock function.
func (_m *Mockec2clientstub) ReplaceRouteTableAssociation(ctx internal.Context, input *ec2.ReplaceRouteTableAssociationInput) (_result_0 *ec2.ReplaceRouteTableAssociationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ReplaceRouteTableAssociationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceRouteTableAssociationInput) *ec2.ReplaceRouteTableAssociationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceRouteTableAssociationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ReplaceRouteTableAssociationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceRouteTableAssociationAsync provides a mock function.
func (_m *Mockec2clientstub) ReplaceRouteTableAssociationAsync(ctx internal.Context, input *ec2.ReplaceRouteTableAssociationInput) (_result_0 *ec2stub.ReplaceRouteTableAssociationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ReplaceRouteTableAssociationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceRouteTableAssociationInput) *ec2stub.ReplaceRouteTableAssociationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ReplaceRouteTableAssociationFuture)
		}
	}

	return r0
}

// ReplaceTransitGatewayRoute provides a mock function.
func (_m *Mockec2clientstub) ReplaceTransitGatewayRoute(ctx internal.Context, input *ec2.ReplaceTransitGatewayRouteInput) (_result_0 *ec2.ReplaceTransitGatewayRouteOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ReplaceTransitGatewayRouteOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceTransitGatewayRouteInput) *ec2.ReplaceTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceTransitGatewayRouteOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ReplaceTransitGatewayRouteInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceTransitGatewayRouteAsync provides a mock function.
func (_m *Mockec2clientstub) ReplaceTransitGatewayRouteAsync(ctx internal.Context, input *ec2.ReplaceTransitGatewayRouteInput) (_result_0 *ec2stub.ReplaceTransitGatewayRouteFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ReplaceTransitGatewayRouteFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReplaceTransitGatewayRouteInput) *ec2stub.ReplaceTransitGatewayRouteFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ReplaceTransitGatewayRouteFuture)
		}
	}

	return r0
}

// ReportInstanceStatus provides a mock function.
func (_m *Mockec2clientstub) ReportInstanceStatus(ctx internal.Context, input *ec2.ReportInstanceStatusInput) (_result_0 *ec2.ReportInstanceStatusOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ReportInstanceStatusOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReportInstanceStatusInput) *ec2.ReportInstanceStatusOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReportInstanceStatusOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ReportInstanceStatusInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReportInstanceStatusAsync provides a mock function.
func (_m *Mockec2clientstub) ReportInstanceStatusAsync(ctx internal.Context, input *ec2.ReportInstanceStatusInput) (_result_0 *ec2stub.ReportInstanceStatusFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ReportInstanceStatusFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ReportInstanceStatusInput) *ec2stub.ReportInstanceStatusFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ReportInstanceStatusFuture)
		}
	}

	return r0
}

// RequestSpotFleet provides a mock function.
func (_m *Mockec2clientstub) RequestSpotFleet(ctx internal.Context, input *ec2.RequestSpotFleetInput) (_result_0 *ec2.RequestSpotFleetOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RequestSpotFleetOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RequestSpotFleetInput) *ec2.RequestSpotFleetOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RequestSpotFleetOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RequestSpotFleetInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestSpotFleetAsync provides a mock function.
func (_m *Mockec2clientstub) RequestSpotFleetAsync(ctx internal.Context, input *ec2.RequestSpotFleetInput) (_result_0 *ec2stub.RequestSpotFleetFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RequestSpotFleetFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RequestSpotFleetInput) *ec2stub.RequestSpotFleetFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RequestSpotFleetFuture)
		}
	}

	return r0
}

// RequestSpotInstances provides a mock function.
func (_m *Mockec2clientstub) RequestSpotInstances(ctx internal.Context, input *ec2.RequestSpotInstancesInput) (_result_0 *ec2.RequestSpotInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RequestSpotInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RequestSpotInstancesInput) *ec2.RequestSpotInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RequestSpotInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RequestSpotInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestSpotInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) RequestSpotInstancesAsync(ctx internal.Context, input *ec2.RequestSpotInstancesInput) (_result_0 *ec2stub.RequestSpotInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RequestSpotInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RequestSpotInstancesInput) *ec2stub.RequestSpotInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RequestSpotInstancesFuture)
		}
	}

	return r0
}

// ResetEbsDefaultKmsKeyId provides a mock function.
func (_m *Mockec2clientstub) ResetEbsDefaultKmsKeyId(ctx internal.Context, input *ec2.ResetEbsDefaultKmsKeyIdInput) (_result_0 *ec2.ResetEbsDefaultKmsKeyIdOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ResetEbsDefaultKmsKeyIdOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetEbsDefaultKmsKeyIdInput) *ec2.ResetEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetEbsDefaultKmsKeyIdOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ResetEbsDefaultKmsKeyIdInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetEbsDefaultKmsKeyIdAsync provides a mock function.
func (_m *Mockec2clientstub) ResetEbsDefaultKmsKeyIdAsync(ctx internal.Context, input *ec2.ResetEbsDefaultKmsKeyIdInput) (_result_0 *ec2stub.ResetEbsDefaultKmsKeyIdFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ResetEbsDefaultKmsKeyIdFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetEbsDefaultKmsKeyIdInput) *ec2stub.ResetEbsDefaultKmsKeyIdFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ResetEbsDefaultKmsKeyIdFuture)
		}
	}

	return r0
}

// ResetFpgaImageAttribute provides a mock function.
func (_m *Mockec2clientstub) ResetFpgaImageAttribute(ctx internal.Context, input *ec2.ResetFpgaImageAttributeInput) (_result_0 *ec2.ResetFpgaImageAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ResetFpgaImageAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetFpgaImageAttributeInput) *ec2.ResetFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetFpgaImageAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ResetFpgaImageAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetFpgaImageAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ResetFpgaImageAttributeAsync(ctx internal.Context, input *ec2.ResetFpgaImageAttributeInput) (_result_0 *ec2stub.ResetFpgaImageAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ResetFpgaImageAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetFpgaImageAttributeInput) *ec2stub.ResetFpgaImageAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ResetFpgaImageAttributeFuture)
		}
	}

	return r0
}

// ResetImageAttribute provides a mock function.
func (_m *Mockec2clientstub) ResetImageAttribute(ctx internal.Context, input *ec2.ResetImageAttributeInput) (_result_0 *ec2.ResetImageAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ResetImageAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetImageAttributeInput) *ec2.ResetImageAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetImageAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ResetImageAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetImageAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ResetImageAttributeAsync(ctx internal.Context, input *ec2.ResetImageAttributeInput) (_result_0 *ec2stub.ResetImageAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ResetImageAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetImageAttributeInput) *ec2stub.ResetImageAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ResetImageAttributeFuture)
		}
	}

	return r0
}

// ResetInstanceAttribute provides a mock function.
func (_m *Mockec2clientstub) ResetInstanceAttribute(ctx internal.Context, input *ec2.ResetInstanceAttributeInput) (_result_0 *ec2.ResetInstanceAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ResetInstanceAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetInstanceAttributeInput) *ec2.ResetInstanceAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetInstanceAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ResetInstanceAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetInstanceAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ResetInstanceAttributeAsync(ctx internal.Context, input *ec2.ResetInstanceAttributeInput) (_result_0 *ec2stub.ResetInstanceAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ResetInstanceAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetInstanceAttributeInput) *ec2stub.ResetInstanceAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ResetInstanceAttributeFuture)
		}
	}

	return r0
}

// ResetNetworkInterfaceAttribute provides a mock function.
func (_m *Mockec2clientstub) ResetNetworkInterfaceAttribute(ctx internal.Context, input *ec2.ResetNetworkInterfaceAttributeInput) (_result_0 *ec2.ResetNetworkInterfaceAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ResetNetworkInterfaceAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetNetworkInterfaceAttributeInput) *ec2.ResetNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetNetworkInterfaceAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ResetNetworkInterfaceAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetNetworkInterfaceAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ResetNetworkInterfaceAttributeAsync(ctx internal.Context, input *ec2.ResetNetworkInterfaceAttributeInput) (_result_0 *ec2stub.ResetNetworkInterfaceAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ResetNetworkInterfaceAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetNetworkInterfaceAttributeInput) *ec2stub.ResetNetworkInterfaceAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ResetNetworkInterfaceAttributeFuture)
		}
	}

	return r0
}

// ResetSnapshotAttribute provides a mock function.
func (_m *Mockec2clientstub) ResetSnapshotAttribute(ctx internal.Context, input *ec2.ResetSnapshotAttributeInput) (_result_0 *ec2.ResetSnapshotAttributeOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.ResetSnapshotAttributeOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetSnapshotAttributeInput) *ec2.ResetSnapshotAttributeOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetSnapshotAttributeOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.ResetSnapshotAttributeInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetSnapshotAttributeAsync provides a mock function.
func (_m *Mockec2clientstub) ResetSnapshotAttributeAsync(ctx internal.Context, input *ec2.ResetSnapshotAttributeInput) (_result_0 *ec2stub.ResetSnapshotAttributeFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.ResetSnapshotAttributeFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.ResetSnapshotAttributeInput) *ec2stub.ResetSnapshotAttributeFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.ResetSnapshotAttributeFuture)
		}
	}

	return r0
}

// RestoreAddressToClassic provides a mock function.
func (_m *Mockec2clientstub) RestoreAddressToClassic(ctx internal.Context, input *ec2.RestoreAddressToClassicInput) (_result_0 *ec2.RestoreAddressToClassicOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RestoreAddressToClassicOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RestoreAddressToClassicInput) *ec2.RestoreAddressToClassicOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreAddressToClassicOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RestoreAddressToClassicInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreAddressToClassicAsync provides a mock function.
func (_m *Mockec2clientstub) RestoreAddressToClassicAsync(ctx internal.Context, input *ec2.RestoreAddressToClassicInput) (_result_0 *ec2stub.RestoreAddressToClassicFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RestoreAddressToClassicFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RestoreAddressToClassicInput) *ec2stub.RestoreAddressToClassicFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RestoreAddressToClassicFuture)
		}
	}

	return r0
}

// RestoreManagedPrefixListVersion provides a mock function.
func (_m *Mockec2clientstub) RestoreManagedPrefixListVersion(ctx internal.Context, input *ec2.RestoreManagedPrefixListVersionInput) (_result_0 *ec2.RestoreManagedPrefixListVersionOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RestoreManagedPrefixListVersionOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RestoreManagedPrefixListVersionInput) *ec2.RestoreManagedPrefixListVersionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreManagedPrefixListVersionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RestoreManagedPrefixListVersionInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreManagedPrefixListVersionAsync provides a mock function.
func (_m *Mockec2clientstub) RestoreManagedPrefixListVersionAsync(ctx internal.Context, input *ec2.RestoreManagedPrefixListVersionInput) (_result_0 *ec2stub.RestoreManagedPrefixListVersionFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RestoreManagedPrefixListVersionFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RestoreManagedPrefixListVersionInput) *ec2stub.RestoreManagedPrefixListVersionFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RestoreManagedPrefixListVersionFuture)
		}
	}

	return r0
}

// RevokeClientVpnIngress provides a mock function.
func (_m *Mockec2clientstub) RevokeClientVpnIngress(ctx internal.Context, input *ec2.RevokeClientVpnIngressInput) (_result_0 *ec2.RevokeClientVpnIngressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RevokeClientVpnIngressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RevokeClientVpnIngressInput) *ec2.RevokeClientVpnIngressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeClientVpnIngressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RevokeClientVpnIngressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeClientVpnIngressAsync provides a mock function.
func (_m *Mockec2clientstub) RevokeClientVpnIngressAsync(ctx internal.Context, input *ec2.RevokeClientVpnIngressInput) (_result_0 *ec2stub.RevokeClientVpnIngressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RevokeClientVpnIngressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RevokeClientVpnIngressInput) *ec2stub.RevokeClientVpnIngressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RevokeClientVpnIngressFuture)
		}
	}

	return r0
}

// RevokeSecurityGroupEgress provides a mock function.
func (_m *Mockec2clientstub) RevokeSecurityGroupEgress(ctx internal.Context, input *ec2.RevokeSecurityGroupEgressInput) (_result_0 *ec2.RevokeSecurityGroupEgressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RevokeSecurityGroupEgressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RevokeSecurityGroupEgressInput) *ec2.RevokeSecurityGroupEgressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeSecurityGroupEgressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RevokeSecurityGroupEgressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeSecurityGroupEgressAsync provides a mock function.
func (_m *Mockec2clientstub) RevokeSecurityGroupEgressAsync(ctx internal.Context, input *ec2.RevokeSecurityGroupEgressInput) (_result_0 *ec2stub.RevokeSecurityGroupEgressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RevokeSecurityGroupEgressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RevokeSecurityGroupEgressInput) *ec2stub.RevokeSecurityGroupEgressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RevokeSecurityGroupEgressFuture)
		}
	}

	return r0
}

// RevokeSecurityGroupIngress provides a mock function.
func (_m *Mockec2clientstub) RevokeSecurityGroupIngress(ctx internal.Context, input *ec2.RevokeSecurityGroupIngressInput) (_result_0 *ec2.RevokeSecurityGroupIngressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RevokeSecurityGroupIngressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RevokeSecurityGroupIngressInput) *ec2.RevokeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeSecurityGroupIngressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RevokeSecurityGroupIngressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeSecurityGroupIngressAsync provides a mock function.
func (_m *Mockec2clientstub) RevokeSecurityGroupIngressAsync(ctx internal.Context, input *ec2.RevokeSecurityGroupIngressInput) (_result_0 *ec2stub.RevokeSecurityGroupIngressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RevokeSecurityGroupIngressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RevokeSecurityGroupIngressInput) *ec2stub.RevokeSecurityGroupIngressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RevokeSecurityGroupIngressFuture)
		}
	}

	return r0
}

// RunInstances provides a mock function.
func (_m *Mockec2clientstub) RunInstances(ctx internal.Context, input *ec2.RunInstancesInput) (_result_0 *ec2.Reservation, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.Reservation
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RunInstancesInput) *ec2.Reservation); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.Reservation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RunInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) RunInstancesAsync(ctx internal.Context, input *ec2.RunInstancesInput) (_result_0 *ec2stub.RunInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RunInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RunInstancesInput) *ec2stub.RunInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RunInstancesFuture)
		}
	}

	return r0
}

// RunScheduledInstances provides a mock function.
func (_m *Mockec2clientstub) RunScheduledInstances(ctx internal.Context, input *ec2.RunScheduledInstancesInput) (_result_0 *ec2.RunScheduledInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.RunScheduledInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RunScheduledInstancesInput) *ec2.RunScheduledInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RunScheduledInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.RunScheduledInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunScheduledInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) RunScheduledInstancesAsync(ctx internal.Context, input *ec2.RunScheduledInstancesInput) (_result_0 *ec2stub.RunScheduledInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.RunScheduledInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.RunScheduledInstancesInput) *ec2stub.RunScheduledInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.RunScheduledInstancesFuture)
		}
	}

	return r0
}

// SearchLocalGatewayRoutes provides a mock function.
func (_m *Mockec2clientstub) SearchLocalGatewayRoutes(ctx internal.Context, input *ec2.SearchLocalGatewayRoutesInput) (_result_0 *ec2.SearchLocalGatewayRoutesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.SearchLocalGatewayRoutesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.SearchLocalGatewayRoutesInput) *ec2.SearchLocalGatewayRoutesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchLocalGatewayRoutesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.SearchLocalGatewayRoutesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchLocalGatewayRoutesAsync provides a mock function.
func (_m *Mockec2clientstub) SearchLocalGatewayRoutesAsync(ctx internal.Context, input *ec2.SearchLocalGatewayRoutesInput) (_result_0 *ec2stub.SearchLocalGatewayRoutesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.SearchLocalGatewayRoutesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.SearchLocalGatewayRoutesInput) *ec2stub.SearchLocalGatewayRoutesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.SearchLocalGatewayRoutesFuture)
		}
	}

	return r0
}

// SearchTransitGatewayMulticastGroups provides a mock function.
func (_m *Mockec2clientstub) SearchTransitGatewayMulticastGroups(ctx internal.Context, input *ec2.SearchTransitGatewayMulticastGroupsInput) (_result_0 *ec2.SearchTransitGatewayMulticastGroupsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.SearchTransitGatewayMulticastGroupsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.SearchTransitGatewayMulticastGroupsInput) *ec2.SearchTransitGatewayMulticastGroupsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchTransitGatewayMulticastGroupsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.SearchTransitGatewayMulticastGroupsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchTransitGatewayMulticastGroupsAsync provides a mock function.
func (_m *Mockec2clientstub) SearchTransitGatewayMulticastGroupsAsync(ctx internal.Context, input *ec2.SearchTransitGatewayMulticastGroupsInput) (_result_0 *ec2stub.SearchTransitGatewayMulticastGroupsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.SearchTransitGatewayMulticastGroupsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.SearchTransitGatewayMulticastGroupsInput) *ec2stub.SearchTransitGatewayMulticastGroupsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.SearchTransitGatewayMulticastGroupsFuture)
		}
	}

	return r0
}

// SearchTransitGatewayRoutes provides a mock function.
func (_m *Mockec2clientstub) SearchTransitGatewayRoutes(ctx internal.Context, input *ec2.SearchTransitGatewayRoutesInput) (_result_0 *ec2.SearchTransitGatewayRoutesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.SearchTransitGatewayRoutesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.SearchTransitGatewayRoutesInput) *ec2.SearchTransitGatewayRoutesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchTransitGatewayRoutesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.SearchTransitGatewayRoutesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchTransitGatewayRoutesAsync provides a mock function.
func (_m *Mockec2clientstub) SearchTransitGatewayRoutesAsync(ctx internal.Context, input *ec2.SearchTransitGatewayRoutesInput) (_result_0 *ec2stub.SearchTransitGatewayRoutesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.SearchTransitGatewayRoutesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.SearchTransitGatewayRoutesInput) *ec2stub.SearchTransitGatewayRoutesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.SearchTransitGatewayRoutesFuture)
		}
	}

	return r0
}

// SendDiagnosticInterrupt provides a mock function.
func (_m *Mockec2clientstub) SendDiagnosticInterrupt(ctx internal.Context, input *ec2.SendDiagnosticInterruptInput) (_result_0 *ec2.SendDiagnosticInterruptOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.SendDiagnosticInterruptOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.SendDiagnosticInterruptInput) *ec2.SendDiagnosticInterruptOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SendDiagnosticInterruptOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.SendDiagnosticInterruptInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendDiagnosticInterruptAsync provides a mock function.
func (_m *Mockec2clientstub) SendDiagnosticInterruptAsync(ctx internal.Context, input *ec2.SendDiagnosticInterruptInput) (_result_0 *ec2stub.SendDiagnosticInterruptFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.SendDiagnosticInterruptFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.SendDiagnosticInterruptInput) *ec2stub.SendDiagnosticInterruptFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.SendDiagnosticInterruptFuture)
		}
	}

	return r0
}

// StartInstances provides a mock function.
func (_m *Mockec2clientstub) StartInstances(ctx internal.Context, input *ec2.StartInstancesInput) (_result_0 *ec2.StartInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.StartInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.StartInstancesInput) *ec2.StartInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.StartInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) StartInstancesAsync(ctx internal.Context, input *ec2.StartInstancesInput) (_result_0 *ec2stub.StartInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.StartInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.StartInstancesInput) *ec2stub.StartInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.StartInstancesFuture)
		}
	}

	return r0
}

// StartVpcEndpointServicePrivateDnsVerification provides a mock function.
func (_m *Mockec2clientstub) StartVpcEndpointServicePrivateDnsVerification(ctx internal.Context, input *ec2.StartVpcEndpointServicePrivateDnsVerificationInput) (_result_0 *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput) *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartVpcEndpointServicePrivateDnsVerificationAsync provides a mock function.
func (_m *Mockec2clientstub) StartVpcEndpointServicePrivateDnsVerificationAsync(ctx internal.Context, input *ec2.StartVpcEndpointServicePrivateDnsVerificationInput) (_result_0 *ec2stub.StartVpcEndpointServicePrivateDnsVerificationFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.StartVpcEndpointServicePrivateDnsVerificationFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput) *ec2stub.StartVpcEndpointServicePrivateDnsVerificationFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.StartVpcEndpointServicePrivateDnsVerificationFuture)
		}
	}

	return r0
}

// StopInstances provides a mock function.
func (_m *Mockec2clientstub) StopInstances(ctx internal.Context, input *ec2.StopInstancesInput) (_result_0 *ec2.StopInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.StopInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.StopInstancesInput) *ec2.StopInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StopInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.StopInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) StopInstancesAsync(ctx internal.Context, input *ec2.StopInstancesInput) (_result_0 *ec2stub.StopInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.StopInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.StopInstancesInput) *ec2stub.StopInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.StopInstancesFuture)
		}
	}

	return r0
}

// TerminateClientVpnConnections provides a mock function.
func (_m *Mockec2clientstub) TerminateClientVpnConnections(ctx internal.Context, input *ec2.TerminateClientVpnConnectionsInput) (_result_0 *ec2.TerminateClientVpnConnectionsOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.TerminateClientVpnConnectionsOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.TerminateClientVpnConnectionsInput) *ec2.TerminateClientVpnConnectionsOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.TerminateClientVpnConnectionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.TerminateClientVpnConnectionsInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateClientVpnConnectionsAsync provides a mock function.
func (_m *Mockec2clientstub) TerminateClientVpnConnectionsAsync(ctx internal.Context, input *ec2.TerminateClientVpnConnectionsInput) (_result_0 *ec2stub.TerminateClientVpnConnectionsFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.TerminateClientVpnConnectionsFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.TerminateClientVpnConnectionsInput) *ec2stub.TerminateClientVpnConnectionsFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.TerminateClientVpnConnectionsFuture)
		}
	}

	return r0
}

// TerminateInstances provides a mock function.
func (_m *Mockec2clientstub) TerminateInstances(ctx internal.Context, input *ec2.TerminateInstancesInput) (_result_0 *ec2.TerminateInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.TerminateInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.TerminateInstancesInput) *ec2.TerminateInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.TerminateInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.TerminateInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) TerminateInstancesAsync(ctx internal.Context, input *ec2.TerminateInstancesInput) (_result_0 *ec2stub.TerminateInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.TerminateInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.TerminateInstancesInput) *ec2stub.TerminateInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.TerminateInstancesFuture)
		}
	}

	return r0
}

// UnassignIpv6Addresses provides a mock function.
func (_m *Mockec2clientstub) UnassignIpv6Addresses(ctx internal.Context, input *ec2.UnassignIpv6AddressesInput) (_result_0 *ec2.UnassignIpv6AddressesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.UnassignIpv6AddressesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UnassignIpv6AddressesInput) *ec2.UnassignIpv6AddressesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnassignIpv6AddressesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.UnassignIpv6AddressesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnassignIpv6AddressesAsync provides a mock function.
func (_m *Mockec2clientstub) UnassignIpv6AddressesAsync(ctx internal.Context, input *ec2.UnassignIpv6AddressesInput) (_result_0 *ec2stub.UnassignIpv6AddressesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.UnassignIpv6AddressesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UnassignIpv6AddressesInput) *ec2stub.UnassignIpv6AddressesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.UnassignIpv6AddressesFuture)
		}
	}

	return r0
}

// UnassignPrivateIpAddresses provides a mock function.
func (_m *Mockec2clientstub) UnassignPrivateIpAddresses(ctx internal.Context, input *ec2.UnassignPrivateIpAddressesInput) (_result_0 *ec2.UnassignPrivateIpAddressesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.UnassignPrivateIpAddressesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UnassignPrivateIpAddressesInput) *ec2.UnassignPrivateIpAddressesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnassignPrivateIpAddressesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.UnassignPrivateIpAddressesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnassignPrivateIpAddressesAsync provides a mock function.
func (_m *Mockec2clientstub) UnassignPrivateIpAddressesAsync(ctx internal.Context, input *ec2.UnassignPrivateIpAddressesInput) (_result_0 *ec2stub.UnassignPrivateIpAddressesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.UnassignPrivateIpAddressesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UnassignPrivateIpAddressesInput) *ec2stub.UnassignPrivateIpAddressesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.UnassignPrivateIpAddressesFuture)
		}
	}

	return r0
}

// UnmonitorInstances provides a mock function.
func (_m *Mockec2clientstub) UnmonitorInstances(ctx internal.Context, input *ec2.UnmonitorInstancesInput) (_result_0 *ec2.UnmonitorInstancesOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.UnmonitorInstancesOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UnmonitorInstancesInput) *ec2.UnmonitorInstancesOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnmonitorInstancesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.UnmonitorInstancesInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnmonitorInstancesAsync provides a mock function.
func (_m *Mockec2clientstub) UnmonitorInstancesAsync(ctx internal.Context, input *ec2.UnmonitorInstancesInput) (_result_0 *ec2stub.UnmonitorInstancesFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.UnmonitorInstancesFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UnmonitorInstancesInput) *ec2stub.UnmonitorInstancesFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.UnmonitorInstancesFuture)
		}
	}

	return r0
}

// UpdateSecurityGroupRuleDescriptionsEgress provides a mock function.
func (_m *Mockec2clientstub) UpdateSecurityGroupRuleDescriptionsEgress(ctx internal.Context, input *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput) (_result_0 *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput) *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurityGroupRuleDescriptionsEgressAsync provides a mock function.
func (_m *Mockec2clientstub) UpdateSecurityGroupRuleDescriptionsEgressAsync(ctx internal.Context, input *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput) (_result_0 *ec2stub.UpdateSecurityGroupRuleDescriptionsEgressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.UpdateSecurityGroupRuleDescriptionsEgressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput) *ec2stub.UpdateSecurityGroupRuleDescriptionsEgressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.UpdateSecurityGroupRuleDescriptionsEgressFuture)
		}
	}

	return r0
}

// UpdateSecurityGroupRuleDescriptionsIngress provides a mock function.
func (_m *Mockec2clientstub) UpdateSecurityGroupRuleDescriptionsIngress(ctx internal.Context, input *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput) (_result_0 *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput) *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurityGroupRuleDescriptionsIngressAsync provides a mock function.
func (_m *Mockec2clientstub) UpdateSecurityGroupRuleDescriptionsIngressAsync(ctx internal.Context, input *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput) (_result_0 *ec2stub.UpdateSecurityGroupRuleDescriptionsIngressFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.UpdateSecurityGroupRuleDescriptionsIngressFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput) *ec2stub.UpdateSecurityGroupRuleDescriptionsIngressFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.UpdateSecurityGroupRuleDescriptionsIngressFuture)
		}
	}

	return r0
}

// WaitUntilBundleTaskComplete provides a mock function.
func (_m *Mockec2clientstub) WaitUntilBundleTaskComplete(ctx internal.Context, input *ec2.DescribeBundleTasksInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeBundleTasksInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilBundleTaskCompleteAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilBundleTaskCompleteAsync(ctx internal.Context, input *ec2.DescribeBundleTasksInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeBundleTasksInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilConversionTaskCancelled provides a mock function.
func (_m *Mockec2clientstub) WaitUntilConversionTaskCancelled(ctx internal.Context, input *ec2.DescribeConversionTasksInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeConversionTasksInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilConversionTaskCancelledAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilConversionTaskCancelledAsync(ctx internal.Context, input *ec2.DescribeConversionTasksInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeConversionTasksInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilConversionTaskCompleted provides a mock function.
func (_m *Mockec2clientstub) WaitUntilConversionTaskCompleted(ctx internal.Context, input *ec2.DescribeConversionTasksInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeConversionTasksInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilConversionTaskCompletedAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilConversionTaskCompletedAsync(ctx internal.Context, input *ec2.DescribeConversionTasksInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeConversionTasksInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilConversionTaskDeleted provides a mock function.
func (_m *Mockec2clientstub) WaitUntilConversionTaskDeleted(ctx internal.Context, input *ec2.DescribeConversionTasksInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeConversionTasksInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilConversionTaskDeletedAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilConversionTaskDeletedAsync(ctx internal.Context, input *ec2.DescribeConversionTasksInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeConversionTasksInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilCustomerGatewayAvailable provides a mock function.
func (_m *Mockec2clientstub) WaitUntilCustomerGatewayAvailable(ctx internal.Context, input *ec2.DescribeCustomerGatewaysInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCustomerGatewaysInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilCustomerGatewayAvailableAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilCustomerGatewayAvailableAsync(ctx internal.Context, input *ec2.DescribeCustomerGatewaysInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeCustomerGatewaysInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilExportTaskCancelled provides a mock function.
func (_m *Mockec2clientstub) WaitUntilExportTaskCancelled(ctx internal.Context, input *ec2.DescribeExportTasksInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeExportTasksInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilExportTaskCancelledAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilExportTaskCancelledAsync(ctx internal.Context, input *ec2.DescribeExportTasksInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeExportTasksInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilExportTaskCompleted provides a mock function.
func (_m *Mockec2clientstub) WaitUntilExportTaskCompleted(ctx internal.Context, input *ec2.DescribeExportTasksInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeExportTasksInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilExportTaskCompletedAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilExportTaskCompletedAsync(ctx internal.Context, input *ec2.DescribeExportTasksInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeExportTasksInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilImageAvailable provides a mock function.
func (_m *Mockec2clientstub) WaitUntilImageAvailable(ctx internal.Context, input *ec2.DescribeImagesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImagesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilImageAvailableAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilImageAvailableAsync(ctx internal.Context, input *ec2.DescribeImagesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImagesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilImageExists provides a mock function.
func (_m *Mockec2clientstub) WaitUntilImageExists(ctx internal.Context, input *ec2.DescribeImagesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImagesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilImageExistsAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilImageExistsAsync(ctx internal.Context, input *ec2.DescribeImagesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeImagesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilInstanceExists provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceExists(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilInstanceExistsAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceExistsAsync(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilInstanceRunning provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceRunning(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilInstanceRunningAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceRunningAsync(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilInstanceStatusOk provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceStatusOk(ctx internal.Context, input *ec2.DescribeInstanceStatusInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceStatusInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilInstanceStatusOkAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceStatusOkAsync(ctx internal.Context, input *ec2.DescribeInstanceStatusInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceStatusInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilInstanceStopped provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceStopped(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilInstanceStoppedAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceStoppedAsync(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilInstanceTerminated provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceTerminated(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilInstanceTerminatedAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilInstanceTerminatedAsync(ctx internal.Context, input *ec2.DescribeInstancesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstancesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilKeyPairExists provides a mock function.
func (_m *Mockec2clientstub) WaitUntilKeyPairExists(ctx internal.Context, input *ec2.DescribeKeyPairsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeKeyPairsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilKeyPairExistsAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilKeyPairExistsAsync(ctx internal.Context, input *ec2.DescribeKeyPairsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeKeyPairsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilNatGatewayAvailable provides a mock function.
func (_m *Mockec2clientstub) WaitUntilNatGatewayAvailable(ctx internal.Context, input *ec2.DescribeNatGatewaysInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNatGatewaysInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilNatGatewayAvailableAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilNatGatewayAvailableAsync(ctx internal.Context, input *ec2.DescribeNatGatewaysInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNatGatewaysInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilNetworkInterfaceAvailable provides a mock function.
func (_m *Mockec2clientstub) WaitUntilNetworkInterfaceAvailable(ctx internal.Context, input *ec2.DescribeNetworkInterfacesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkInterfacesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilNetworkInterfaceAvailableAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilNetworkInterfaceAvailableAsync(ctx internal.Context, input *ec2.DescribeNetworkInterfacesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeNetworkInterfacesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilPasswordDataAvailable provides a mock function.
func (_m *Mockec2clientstub) WaitUntilPasswordDataAvailable(ctx internal.Context, input *ec2.GetPasswordDataInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetPasswordDataInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilPasswordDataAvailableAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilPasswordDataAvailableAsync(ctx internal.Context, input *ec2.GetPasswordDataInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.GetPasswordDataInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilSecurityGroupExists provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSecurityGroupExists(ctx internal.Context, input *ec2.DescribeSecurityGroupsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSecurityGroupsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilSecurityGroupExistsAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSecurityGroupExistsAsync(ctx internal.Context, input *ec2.DescribeSecurityGroupsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSecurityGroupsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilSnapshotCompleted provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSnapshotCompleted(ctx internal.Context, input *ec2.DescribeSnapshotsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSnapshotsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilSnapshotCompletedAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSnapshotCompletedAsync(ctx internal.Context, input *ec2.DescribeSnapshotsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSnapshotsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilSpotInstanceRequestFulfilled provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSpotInstanceRequestFulfilled(ctx internal.Context, input *ec2.DescribeSpotInstanceRequestsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotInstanceRequestsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilSpotInstanceRequestFulfilledAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSpotInstanceRequestFulfilledAsync(ctx internal.Context, input *ec2.DescribeSpotInstanceRequestsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSpotInstanceRequestsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilSubnetAvailable provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSubnetAvailable(ctx internal.Context, input *ec2.DescribeSubnetsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSubnetsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilSubnetAvailableAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSubnetAvailableAsync(ctx internal.Context, input *ec2.DescribeSubnetsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeSubnetsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilSystemStatusOk provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSystemStatusOk(ctx internal.Context, input *ec2.DescribeInstanceStatusInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceStatusInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilSystemStatusOkAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilSystemStatusOkAsync(ctx internal.Context, input *ec2.DescribeInstanceStatusInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeInstanceStatusInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilVolumeAvailable provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVolumeAvailable(ctx internal.Context, input *ec2.DescribeVolumesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilVolumeAvailableAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVolumeAvailableAsync(ctx internal.Context, input *ec2.DescribeVolumesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilVolumeDeleted provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVolumeDeleted(ctx internal.Context, input *ec2.DescribeVolumesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilVolumeDeletedAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVolumeDeletedAsync(ctx internal.Context, input *ec2.DescribeVolumesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilVolumeInUse provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVolumeInUse(ctx internal.Context, input *ec2.DescribeVolumesInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilVolumeInUseAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVolumeInUseAsync(ctx internal.Context, input *ec2.DescribeVolumesInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVolumesInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilVpcAvailable provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpcAvailable(ctx internal.Context, input *ec2.DescribeVpcsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilVpcAvailableAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpcAvailableAsync(ctx internal.Context, input *ec2.DescribeVpcsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilVpcExists provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpcExists(ctx internal.Context, input *ec2.DescribeVpcsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilVpcExistsAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpcExistsAsync(ctx internal.Context, input *ec2.DescribeVpcsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilVpcPeeringConnectionDeleted provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpcPeeringConnectionDeleted(ctx internal.Context, input *ec2.DescribeVpcPeeringConnectionsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcPeeringConnectionsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilVpcPeeringConnectionDeletedAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpcPeeringConnectionDeletedAsync(ctx internal.Context, input *ec2.DescribeVpcPeeringConnectionsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcPeeringConnectionsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilVpcPeeringConnectionExists provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpcPeeringConnectionExists(ctx internal.Context, input *ec2.DescribeVpcPeeringConnectionsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcPeeringConnectionsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilVpcPeeringConnectionExistsAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpcPeeringConnectionExistsAsync(ctx internal.Context, input *ec2.DescribeVpcPeeringConnectionsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpcPeeringConnectionsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilVpnConnectionAvailable provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpnConnectionAvailable(ctx internal.Context, input *ec2.DescribeVpnConnectionsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpnConnectionsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilVpnConnectionAvailableAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpnConnectionAvailableAsync(ctx internal.Context, input *ec2.DescribeVpnConnectionsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpnConnectionsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WaitUntilVpnConnectionDeleted provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpnConnectionDeleted(ctx internal.Context, input *ec2.DescribeVpnConnectionsInput) (_result_0 error) {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpnConnectionsInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitUntilVpnConnectionDeletedAsync provides a mock function.
func (_m *Mockec2clientstub) WaitUntilVpnConnectionDeletedAsync(ctx internal.Context, input *ec2.DescribeVpnConnectionsInput) (_result_0 *clients.VoidFuture) {
	ret := _m.Called(ctx, input)

	var r0 *clients.VoidFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.DescribeVpnConnectionsInput) *clients.VoidFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clients.VoidFuture)
		}
	}

	return r0
}

// WithdrawByoipCidr provides a mock function.
func (_m *Mockec2clientstub) WithdrawByoipCidr(ctx internal.Context, input *ec2.WithdrawByoipCidrInput) (_result_0 *ec2.WithdrawByoipCidrOutput, _result_1 error) {
	ret := _m.Called(ctx, input)

	var r0 *ec2.WithdrawByoipCidrOutput
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.WithdrawByoipCidrInput) *ec2.WithdrawByoipCidrOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.WithdrawByoipCidrOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(internal.Context, *ec2.WithdrawByoipCidrInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawByoipCidrAsync provides a mock function.
func (_m *Mockec2clientstub) WithdrawByoipCidrAsync(ctx internal.Context, input *ec2.WithdrawByoipCidrInput) (_result_0 *ec2stub.WithdrawByoipCidrFuture) {
	ret := _m.Called(ctx, input)

	var r0 *ec2stub.WithdrawByoipCidrFuture
	if rf, ok := ret.Get(0).(func(internal.Context, *ec2.WithdrawByoipCidrInput) *ec2stub.WithdrawByoipCidrFuture); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2stub.WithdrawByoipCidrFuture)
		}
	}

	return r0
}
