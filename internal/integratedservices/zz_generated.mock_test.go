//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by mga tool. DO NOT EDIT.

package integratedservices

import (
	"context"
	"github.com/stretchr/testify/mock"
)

// MockIntegratedServiceManagerRegistry is an autogenerated mock for the IntegratedServiceManagerRegistry type.
type MockIntegratedServiceManagerRegistry struct {
	mock.Mock
}

// GetIntegratedServiceManager provides a mock function.
func (_m *MockIntegratedServiceManagerRegistry) GetIntegratedServiceManager(integratedServiceName string) (_result_0 IntegratedServiceManager, _result_1 error) {
	ret := _m.Called(integratedServiceName)

	var r0 IntegratedServiceManager
	if rf, ok := ret.Get(0).(func(string) IntegratedServiceManager); ok {
		r0 = rf(integratedServiceName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(IntegratedServiceManager)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(integratedServiceName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIntegratedServiceNames provides a mock function.
func (_m *MockIntegratedServiceManagerRegistry) GetIntegratedServiceNames() (_result_0 []string) {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// MockIntegratedServiceRepository is an autogenerated mock for the IntegratedServiceRepository type.
type MockIntegratedServiceRepository struct {
	mock.Mock
}

// DeleteIntegratedService provides a mock function.
func (_m *MockIntegratedServiceRepository) DeleteIntegratedService(ctx context.Context, clusterID uint, integratedServiceName string) (_result_0 error) {
	ret := _m.Called(ctx, clusterID, integratedServiceName)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, string) error); ok {
		r0 = rf(ctx, clusterID, integratedServiceName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetIntegratedService provides a mock function.
func (_m *MockIntegratedServiceRepository) GetIntegratedService(ctx context.Context, clusterID uint, integratedServiceName string) (_result_0 IntegratedService, _result_1 error) {
	ret := _m.Called(ctx, clusterID, integratedServiceName)

	var r0 IntegratedService
	if rf, ok := ret.Get(0).(func(context.Context, uint, string) IntegratedService); ok {
		r0 = rf(ctx, clusterID, integratedServiceName)
	} else {
		r0 = ret.Get(0).(IntegratedService)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint, string) error); ok {
		r1 = rf(ctx, clusterID, integratedServiceName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIntegratedServices provides a mock function.
func (_m *MockIntegratedServiceRepository) GetIntegratedServices(ctx context.Context, clusterID uint) (_result_0 []IntegratedService, _result_1 error) {
	ret := _m.Called(ctx, clusterID)

	var r0 []IntegratedService
	if rf, ok := ret.Get(0).(func(context.Context, uint) []IntegratedService); ok {
		r0 = rf(ctx, clusterID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]IntegratedService)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = rf(ctx, clusterID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveIntegratedService provides a mock function.
func (_m *MockIntegratedServiceRepository) SaveIntegratedService(ctx context.Context, clusterID uint, integratedServiceName string, spec map[string]interface{}, status string) (_result_0 error) {
	ret := _m.Called(ctx, clusterID, integratedServiceName, spec, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, string, map[string]interface{}, string) error); ok {
		r0 = rf(ctx, clusterID, integratedServiceName, spec, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateIntegratedServiceSpec provides a mock function.
func (_m *MockIntegratedServiceRepository) UpdateIntegratedServiceSpec(ctx context.Context, clusterID uint, integratedServiceName string, spec map[string]interface{}) (_result_0 error) {
	ret := _m.Called(ctx, clusterID, integratedServiceName, spec)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, string, map[string]interface{}) error); ok {
		r0 = rf(ctx, clusterID, integratedServiceName, spec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateIntegratedServiceStatus provides a mock function.
func (_m *MockIntegratedServiceRepository) UpdateIntegratedServiceStatus(ctx context.Context, clusterID uint, integratedServiceName string, status string) (_result_0 error) {
	ret := _m.Called(ctx, clusterID, integratedServiceName, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, string, string) error); ok {
		r0 = rf(ctx, clusterID, integratedServiceName, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIntegratedServiceOperationDispatcher is an autogenerated mock for the IntegratedServiceOperationDispatcher type.
type MockIntegratedServiceOperationDispatcher struct {
	mock.Mock
}

// DispatchApply provides a mock function.
func (_m *MockIntegratedServiceOperationDispatcher) DispatchApply(ctx context.Context, clusterID uint, integratedServiceName string, spec map[string]interface{}) (_result_0 error) {
	ret := _m.Called(ctx, clusterID, integratedServiceName, spec)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, string, map[string]interface{}) error); ok {
		r0 = rf(ctx, clusterID, integratedServiceName, spec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DispatchDeactivate provides a mock function.
func (_m *MockIntegratedServiceOperationDispatcher) DispatchDeactivate(ctx context.Context, clusterID uint, integratedServiceName string, spec map[string]interface{}) (_result_0 error) {
	ret := _m.Called(ctx, clusterID, integratedServiceName, spec)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, string, map[string]interface{}) error); ok {
		r0 = rf(ctx, clusterID, integratedServiceName, spec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IsBeingDispatched provides a mock function.
func (_m *MockIntegratedServiceOperationDispatcher) IsBeingDispatched(ctx context.Context, clusterID uint, integratedServiceName string) (_result_0 bool, _result_1 error) {
	ret := _m.Called(ctx, clusterID, integratedServiceName)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, uint, string) bool); ok {
		r0 = rf(ctx, clusterID, integratedServiceName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint, string) error); ok {
		r1 = rf(ctx, clusterID, integratedServiceName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
